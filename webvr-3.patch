diff --git a/build/common.gypi b/build/common.gypi
index 0706226..e32a928 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -1028,9 +1028,9 @@
           'pkg-config': 'pkg-config'
         }],
 
-        # Enable WebVR support by default on Android
+        # Enable WebVR support by on Android and Windows
         # Still requires command line flag to access API
-        ['OS=="android"', {
+        ['OS=="android" or OS=="win"', {
           'enable_webvr%': 1,
         }, {
           'enable_webvr%': 0,
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index af77d2f..9c9ebb4 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -164,6 +164,8 @@
 #include "storage/browser/fileapi/external_mount_points.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/resource/resource_bundle.h"
+#include "ui/base/ui_base_switches.h"
+#include "ui/gl/gl_switches.h"
 #include "ui/resources/grit/ui_resources.h"
 #include "url/gurl.h"
 #include "url/origin.h"
@@ -1706,6 +1708,15 @@ void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(
         !command_line->HasSwitch(switches::kDisableBreakpad))
       command_line->AppendSwitch(switches::kDisableBreakpad);
   }
+  
+#if !defined(OS_ANDROID)
+  // Temp workarounds for WebVR
+  if (browser_command_line.HasSwitch(switches::kEnableWebVR)) {
+    command_line->AppendSwitchASCII(switches::kUseGL,
+        gfx::kGLImplementationDesktopName);
+    command_line->AppendSwitch(switches::kDisableGpuSandbox);
+  }
+#endif
 
   // The command line switch kEnableBenchmarking needs to be specified along
   // with the kEnableStatsTable switch to ensure that the stats table global
diff --git a/content/browser/DEPS b/content/browser/DEPS
index 8a7a51a..d73e600 100644
--- a/content/browser/DEPS
+++ b/content/browser/DEPS
@@ -41,6 +41,7 @@ include_rules = [
   "+third_party/iaccessible2",
   "+third_party/isimpledom",
   "+third_party/khronos",   # For enum definitions only
+  "+third_party/libovr",
   "+third_party/re2",
 
   # Allow non-browser Chrome OS code to be used.
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_linux.cc b/content/browser/gamepad/gamepad_platform_data_fetcher_linux.cc
index daf44f1..6d88bf5 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_linux.cc
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_linux.cc
@@ -79,10 +79,10 @@ GamepadPlatformDataFetcherLinux::~GamepadPlatformDataFetcherLinux() {
 }
 
 void GamepadPlatformDataFetcherLinux::OnAddedToProvider() {
-  std::vector<UdevLinux::UdevMonitorFilter> filters;
+  std::vector<device::UdevLinux::UdevMonitorFilter> filters;
   filters.push_back(
       device::UdevLinux::UdevMonitorFilter(kInputSubsystem, NULL));
-  udev_.reset(new UdevLinux(
+  udev_.reset(new device::UdevLinux(
       filters, base::Bind(&GamepadPlatformDataFetcherLinux::RefreshDevice,
                           base::Unretained(this))));
 
diff --git a/content/browser/gamepad/gamepad_provider.cc b/content/browser/gamepad/gamepad_provider.cc
index f4d0ab4..62521ba 100644
--- a/content/browser/gamepad/gamepad_provider.cc
+++ b/content/browser/gamepad/gamepad_provider.cc
@@ -177,6 +177,9 @@ void GamepadProvider::AddGamepadDataFetcher(
 void GamepadProvider::DoAddGamepadDataFetcher(
     std::unique_ptr<GamepadDataFetcher> fetcher) {
   DCHECK(base::MessageLoop::current() == polling_thread_->message_loop());
+  
+  if (!fetcher)
+    return;
 
   fetcher->InitializeProvider(this);
 
diff --git a/content/browser/gamepad/gamepad_provider.h b/content/browser/gamepad/gamepad_provider.h
index f46be16..3e2bcab 100644
--- a/content/browser/gamepad/gamepad_provider.h
+++ b/content/browser/gamepad/gamepad_provider.h
@@ -36,6 +36,8 @@ enum GamepadSource {
   GAMEPAD_SOURCE_LINUX_UDEV,
   GAMEPAD_SOURCE_MAC_HID,
   GAMEPAD_SOURCE_MAC_XBOX,
+  GAMEPAD_SOURCE_OCULUS,
+  GAMEPAD_SOURCE_OPENVR,
   GAMEPAD_SOURCE_TEST,
   GAMEPAD_SOURCE_WIN_XINPUT,
   GAMEPAD_SOURCE_WIN_RAW,
@@ -95,6 +97,9 @@ class CONTENT_EXPORT GamepadProvider :
   // given process.
   base::SharedMemoryHandle GetSharedMemoryHandleForProcess(
       base::ProcessHandle renderer_process);
+      
+  void AddGamepadDataFetcher(GamepadDataFetcher* fetcher);
+  void RemoveGamepadDataFetcher(GamepadDataFetcher* fetcher);
 
   void GetCurrentGamepadData(blink::WebGamepads* data);
 
@@ -151,7 +156,7 @@ class CONTENT_EXPORT GamepadProvider :
   void MapAndSanitizeGamepadData(PadState* pad_state,
                                  blink::WebGamepad* pad);
 
-  enum { kDesiredSamplingIntervalMs = 16 };
+  enum { kDesiredSamplingIntervalMs = 10 }; // FIXME: Bumped from 16 for WebVR build
 
   // Keeps track of when the background thread is paused. Access to is_paused_
   // must be guarded by is_paused_lock_.
diff --git a/content/browser/gamepad/gamepad_standard_mappings.cc b/content/browser/gamepad/gamepad_standard_mappings.cc
index 687d4ce..f633cc4 100644
--- a/content/browser/gamepad/gamepad_standard_mappings.cc
+++ b/content/browser/gamepad/gamepad_standard_mappings.cc
@@ -9,29 +9,29 @@ namespace content {
 blink::WebGamepadButton AxisToButton(float input) {
   float value = (input + 1.f) / 2.f;
   return blink::WebGamepadButton(
-    value > kDefaultButtonPressedThreshold, value);
+    value > kDefaultButtonPressedThreshold, false, value);
 }
 
 blink::WebGamepadButton AxisNegativeAsButton(float input) {
   float value = (input < -0.5f) ? 1.f : 0.f;
   return blink::WebGamepadButton(
-    value > kDefaultButtonPressedThreshold, value);
+    value > kDefaultButtonPressedThreshold, false, value);
 }
 
 blink::WebGamepadButton AxisPositiveAsButton(float input) {
   float value = (input > 0.5f) ? 1.f : 0.f;
   return blink::WebGamepadButton(
-    value > kDefaultButtonPressedThreshold, value);
+    value > kDefaultButtonPressedThreshold, false, value);
 }
 
 blink::WebGamepadButton ButtonFromButtonAndAxis(
     blink::WebGamepadButton button, float axis) {
   float value = (axis + 1.f) / 2.f;
-  return blink::WebGamepadButton(button.pressed, value);
+  return blink::WebGamepadButton(button.pressed, false, value);
 }
 
 blink::WebGamepadButton NullButton() {
-  return blink::WebGamepadButton(false, 0.0);
+  return blink::WebGamepadButton(false, false, 0.0);
 }
 
 void DpadFromAxis(blink::WebGamepad* mapped, float dir) {
@@ -52,12 +52,16 @@ void DpadFromAxis(blink::WebGamepad* mapped, float dir) {
   }
 
   mapped->buttons[BUTTON_INDEX_DPAD_UP].pressed = up;
+  mapped->buttons[BUTTON_INDEX_DPAD_UP].touched = false;
   mapped->buttons[BUTTON_INDEX_DPAD_UP].value = up ? 1.f : 0.f;
   mapped->buttons[BUTTON_INDEX_DPAD_RIGHT].pressed = right;
+  mapped->buttons[BUTTON_INDEX_DPAD_RIGHT].touched = false;
   mapped->buttons[BUTTON_INDEX_DPAD_RIGHT].value = right ? 1.f : 0.f;
   mapped->buttons[BUTTON_INDEX_DPAD_DOWN].pressed = down;
+  mapped->buttons[BUTTON_INDEX_DPAD_DOWN].touched = false;
   mapped->buttons[BUTTON_INDEX_DPAD_DOWN].value = down ? 1.f : 0.f;
   mapped->buttons[BUTTON_INDEX_DPAD_LEFT].pressed = left;
+  mapped->buttons[BUTTON_INDEX_DPAD_LEFT].touched = false;
   mapped->buttons[BUTTON_INDEX_DPAD_LEFT].value = left ? 1.f : 0.f;
 }
 
diff --git a/content/browser/vr/android/cardboard/cardboard_vr_device.cc b/content/browser/vr/android/cardboard/cardboard_vr_device.cc
index 9d9aca7..daec75e 100644
--- a/content/browser/vr/android/cardboard/cardboard_vr_device.cc
+++ b/content/browser/vr/android/cardboard/cardboard_vr_device.cc
@@ -28,7 +28,7 @@ bool CardboardVRDevice::RegisterCardboardVRDevice(JNIEnv* env) {
 }
 
 CardboardVRDevice::CardboardVRDevice(VRDeviceProvider* provider)
-    : VRDevice(provider), frame_index_(0) {
+    : VRDevice(provider) {
   JNIEnv* env = AttachCurrentThread();
   j_cardboard_device_.Reset(Java_CardboardVRDevice_create(
       env, base::android::GetApplicationContext()));
@@ -40,9 +40,9 @@ CardboardVRDevice::~CardboardVRDevice() {
                                       j_cardboard_device_.obj());
 }
 
-VRDeviceInfoPtr CardboardVRDevice::GetVRDevice() {
+mojom::VRDeviceInfoPtr CardboardVRDevice::GetVRDevice() {
   TRACE_EVENT0("input", "CardboardVRDevice::GetVRDevice");
-  VRDeviceInfoPtr device = VRDeviceInfo::New();
+  mojom::VRDeviceInfoPtr device = mojom::VRDeviceInfo::New();
 
   JNIEnv* env = AttachCurrentThread();
 
@@ -58,45 +58,42 @@ VRDeviceInfoPtr CardboardVRDevice::GetVRDevice() {
   std::vector<float> fov;
   base::android::JavaFloatArrayToFloatVector(env, j_fov.obj(), &fov);
 
-  device->hmdInfo = VRHMDInfo::New();
-  VRHMDInfoPtr& hmdInfo = device->hmdInfo;
+  device->capabilities = mojom::VRDeviceCapabilities::New();
+  device->capabilities->hasOrientation = true;
+  device->capabilities->hasPosition = false;
+  device->capabilities->hasExternalDisplay = false;
+  device->capabilities->canPresent = true;
 
-  hmdInfo->leftEye = VREyeParameters::New();
-  hmdInfo->rightEye = VREyeParameters::New();
-  VREyeParametersPtr& left_eye = hmdInfo->leftEye;
-  VREyeParametersPtr& right_eye = hmdInfo->rightEye;
+  device->leftEye = mojom::VREyeParameters::New();
+  device->rightEye = mojom::VREyeParameters::New();
+  mojom::VREyeParametersPtr& left_eye = device->leftEye;
+  mojom::VREyeParametersPtr& right_eye = device->rightEye;
 
-  left_eye->recommendedFieldOfView = VRFieldOfView::New();
-  left_eye->recommendedFieldOfView->upDegrees = fov[0];
-  left_eye->recommendedFieldOfView->downDegrees = fov[1];
-  left_eye->recommendedFieldOfView->leftDegrees = fov[2];
-  left_eye->recommendedFieldOfView->rightDegrees = fov[3];
+  left_eye->fieldOfView = mojom::VRFieldOfView::New();
+  left_eye->fieldOfView->upDegrees = fov[0];
+  left_eye->fieldOfView->downDegrees = fov[1];
+  left_eye->fieldOfView->leftDegrees = fov[2];
+  left_eye->fieldOfView->rightDegrees = fov[3];
 
   // Cardboard devices always assume a mirrored FOV, so this is just the left
   // eye FOV with the left and right degrees swapped.
-  right_eye->recommendedFieldOfView = VRFieldOfView::New();
-  right_eye->recommendedFieldOfView->upDegrees = fov[0];
-  right_eye->recommendedFieldOfView->downDegrees = fov[1];
-  right_eye->recommendedFieldOfView->leftDegrees = fov[3];
-  right_eye->recommendedFieldOfView->rightDegrees = fov[2];
-
-  // Cardboard does not support configurable FOV.
-  left_eye->maximumFieldOfView = left_eye->recommendedFieldOfView.Clone();
-  right_eye->maximumFieldOfView = right_eye->recommendedFieldOfView.Clone();
-  left_eye->minimumFieldOfView = left_eye->recommendedFieldOfView.Clone();
-  right_eye->minimumFieldOfView = right_eye->recommendedFieldOfView.Clone();
+  right_eye->fieldOfView = mojom::VRFieldOfView::New();
+  right_eye->fieldOfView->upDegrees = fov[0];
+  right_eye->fieldOfView->downDegrees = fov[1];
+  right_eye->fieldOfView->leftDegrees = fov[3];
+  right_eye->fieldOfView->rightDegrees = fov[2];
 
   float ipd = Java_CardboardVRDevice_getIpd(env, j_cardboard_device_.obj());
 
-  left_eye->eyeTranslation = VRVector3::New();
-  left_eye->eyeTranslation->x = ipd * -0.5f;
-  left_eye->eyeTranslation->y = 0.0f;
-  left_eye->eyeTranslation->z = 0.0f;
+  left_eye->offset= mojo::Array<float>::New(3);
+  left_eye->offset[0] = ipd * -0.5f;
+  left_eye->offset[1] = 0.0f;
+  left_eye->offset[2] = 0.0f;
 
-  right_eye->eyeTranslation = VRVector3::New();
-  right_eye->eyeTranslation->x = ipd * 0.5f;
-  right_eye->eyeTranslation->y = 0.0f;
-  right_eye->eyeTranslation->z = 0.0f;
+  right_eye->offset = mojo::Array<float>::New(3);
+  right_eye->offset[0] = ipd * 0.5f;
+  right_eye->offset[1] = 0.0f;
+  right_eye->offset[2] = 0.0f;
 
   ScopedJavaLocalRef<jintArray> j_screen_size(env, env->NewIntArray(2));
   Java_CardboardVRDevice_getScreenSize(env, j_cardboard_device_.obj(),
@@ -106,27 +103,20 @@ VRDeviceInfoPtr CardboardVRDevice::GetVRDevice() {
   base::android::JavaIntArrayToIntVector(env, j_screen_size.obj(),
                                          &screen_size);
 
-  left_eye->renderRect = VRRect::New();
-  left_eye->renderRect->x = 0;
-  left_eye->renderRect->y = 0;
-  left_eye->renderRect->width = screen_size[0] / 2.0;
-  left_eye->renderRect->height = screen_size[1];
+  left_eye->renderWidth = screen_size[0] / 2.0;
+  left_eye->renderHeight = screen_size[1];
 
-  right_eye->renderRect = VRRect::New();
-  right_eye->renderRect->x = screen_size[0] / 2.0;
-  right_eye->renderRect->y = 0;
-  right_eye->renderRect->width = screen_size[0] / 2.0;
-  right_eye->renderRect->height = screen_size[1];
+  right_eye->renderWidth = screen_size[0] / 2.0;
+  right_eye->renderHeight = screen_size[1];
 
   return device;
 }
 
-VRSensorStatePtr CardboardVRDevice::GetSensorState() {
+mojom::VRPosePtr CardboardVRDevice::GetPose() {
   TRACE_EVENT0("input", "CardboardVRDevice::GetSensorState");
-  VRSensorStatePtr state = VRSensorState::New();
+  mojom::VRPosePtr pose = mojom::VRPose::New();
 
-  state->timestamp = base::Time::Now().ToJsTime();
-  state->frameIndex = frame_index_++;
+  pose->timestamp = base::Time::Now().ToJsTime();
 
   JNIEnv* env = AttachCurrentThread();
   Java_CardboardVRDevice_getSensorState(env, j_cardboard_device_.obj(),
@@ -145,21 +135,21 @@ VRSensorStatePtr CardboardVRDevice::GetSensorState() {
   gfx::DecomposedTransform decomposed_transform;
   gfx::DecomposeTransform(&decomposed_transform, transform);
 
-  state->orientation = VRVector4::New();
-  state->orientation->x = decomposed_transform.quaternion[0];
-  state->orientation->y = decomposed_transform.quaternion[1];
-  state->orientation->z = decomposed_transform.quaternion[2];
-  state->orientation->w = decomposed_transform.quaternion[3];
+  pose->orientation = mojo::Array<float>::New(4);
+  pose->orientation[0] = decomposed_transform.quaternion[0];
+  pose->orientation[1] = decomposed_transform.quaternion[1];
+  pose->orientation[2] = decomposed_transform.quaternion[2];
+  pose->orientation[3] = decomposed_transform.quaternion[3];
 
-  state->position = VRVector3::New();
-  state->position->x = decomposed_transform.translate[0];
-  state->position->y = decomposed_transform.translate[1];
-  state->position->z = decomposed_transform.translate[2];
+  pose->position = mojo::Array<float>::New(3);
+  pose->position[0] = decomposed_transform.translate[0];
+  pose->position[1] = decomposed_transform.translate[1];
+  pose->position[2] = decomposed_transform.translate[2];
 
-  return state;
+  return pose;
 }
 
-void CardboardVRDevice::ResetSensor() {
+void CardboardVRDevice::ResetPose() {
   Java_CardboardVRDevice_resetSensor(AttachCurrentThread(),
                                      j_cardboard_device_.obj());
 }
diff --git a/content/browser/vr/android/cardboard/cardboard_vr_device.h b/content/browser/vr/android/cardboard/cardboard_vr_device.h
index 66f8287..33e8f68 100644
--- a/content/browser/vr/android/cardboard/cardboard_vr_device.h
+++ b/content/browser/vr/android/cardboard/cardboard_vr_device.h
@@ -20,16 +20,14 @@ class CardboardVRDevice : public VRDevice {
   explicit CardboardVRDevice(VRDeviceProvider* provider);
   ~CardboardVRDevice() override;
 
-  VRDeviceInfoPtr GetVRDevice() override;
-  VRSensorStatePtr GetSensorState() override;
-  void ResetSensor() override;
+  mojom::VRDeviceInfoPtr GetVRDevice() override;
+  mojom::VRPosePtr GetPose() override;
+  void ResetPose() override;
 
  private:
   base::android::ScopedJavaGlobalRef<jobject> j_cardboard_device_;
   base::android::ScopedJavaGlobalRef<jfloatArray> j_head_matrix_;
 
-  unsigned int frame_index_;
-
   DISALLOW_COPY_AND_ASSIGN(CardboardVRDevice);
 };
 
diff --git a/content/browser/vr/android/cardboard/cardboard_vr_device_provider.h b/content/browser/vr/android/cardboard/cardboard_vr_device_provider.h
index b041316..d8133f4 100644
--- a/content/browser/vr/android/cardboard/cardboard_vr_device_provider.h
+++ b/content/browser/vr/android/cardboard/cardboard_vr_device_provider.h
@@ -6,9 +6,9 @@
 #define CONTENT_BROWSER_VR_CARDBOARD_VR_DEVICE_PROVIDER_H
 
 #include <map>
+#include <memory>
 
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "content/browser/vr/vr_device.h"
 #include "content/browser/vr/vr_device_provider.h"
 
@@ -23,7 +23,7 @@ class CardboardVRDeviceProvider : public VRDeviceProvider {
   void Initialize() override;
 
  private:
-  scoped_ptr<VRDevice> cardboard_device_;
+  std::unique_ptr<VRDevice> cardboard_device_;
 
   DISALLOW_COPY_AND_ASSIGN(CardboardVRDeviceProvider);
 };
diff --git a/content/browser/vr/oculus/oculus_vr_device.cc b/content/browser/vr/oculus/oculus_vr_device.cc
new file mode 100644
index 0000000..abdd4c8
--- /dev/null
+++ b/content/browser/vr/oculus/oculus_vr_device.cc
@@ -0,0 +1,171 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/vr/oculus/oculus_vr_device.h"
+
+#include <algorithm>
+#include <math.h>
+
+#include "base/strings/stringprintf.h"
+#include "base/time/time.h"
+#include "third_party/libovr/LibOVR/Include/OVR_CAPI.h"
+
+namespace content {
+
+namespace {
+const float radToDeg = 180.0f / 3.14159265358979323846f;
+}
+
+OculusVRDevice::OculusVRDevice(VRDeviceProvider* provider, ovrSession session)
+    : VRDevice(provider)
+    , session_(session)
+{
+}
+
+OculusVRDevice::~OculusVRDevice() {
+  if (session_) {
+    ovr_Destroy(session_);
+    session_ = NULL;
+  }
+}
+
+VRFieldOfViewPtr ovrFovPortToWebVR(const ovrFovPort& fov) {
+  VRFieldOfViewPtr out = VRFieldOfView::New();
+  out->upDegrees = atanf(fov.UpTan) * radToDeg;
+  out->downDegrees = atanf(fov.DownTan) * radToDeg;
+  out->leftDegrees = atanf(fov.LeftTan) * radToDeg;
+  out->rightDegrees = atanf(fov.RightTan) * radToDeg;
+  return out;
+}
+
+mojo::Array<float> ovrQuatfToWebVR(const ovrQuatf& quat) {
+  mojo::Array<float> out = mojo::Array<float>::New(4);
+  out[0] = quat.x;
+  out[1] = quat.y;
+  out[2] = quat.z;
+  out[3] = quat.w;
+  return out;
+}
+
+mojo::Array<float> ovrVector3fToWebVR(const ovrVector3f& vec) {
+  mojo::Array<float> out = mojo::Array<float>::New(3);
+  out[0] = vec.x;
+  out[1] = vec.y;
+  out[2] = vec.z;
+  return out;
+}
+
+VRDeviceInfoPtr OculusVRDevice::GetVRDevice() {
+  VRDeviceInfoPtr device = VRDeviceInfo::New();
+
+  ovrHmdDesc session_desc = ovr_GetHmdDesc(session_);
+
+  device->deviceName = base::StringPrintf("%s, %s",
+      session_desc.ProductName, session_desc.Manufacturer);
+
+  device->deviceCompositorType = VRDeviceInfo::CompositorType::OCULUS;
+
+  device->capabilities = VRDeviceCapabilities::New();
+  device->capabilities->hasOrientation = true;
+  device->capabilities->hasPosition = true;
+  device->capabilities->hasExternalDisplay = true;
+  device->capabilities->canPresent = true;
+
+  device->leftEye = VREyeParameters::New();
+  device->rightEye = VREyeParameters::New();
+  VREyeParametersPtr& leftEye = device->leftEye;
+  VREyeParametersPtr& rightEye = device->rightEye;
+
+  leftEye->fieldOfView = ovrFovPortToWebVR(
+      session_desc.DefaultEyeFov[ovrEye_Left]);
+  rightEye->fieldOfView = ovrFovPortToWebVR(
+      session_desc.DefaultEyeFov[ovrEye_Right]);
+
+  ovrEyeRenderDesc leftEyeDesc = ovr_GetRenderDesc(session_, ovrEye_Left,
+      session_desc.DefaultEyeFov[ovrEye_Left]);
+  ovrEyeRenderDesc rightEyeDesc = ovr_GetRenderDesc(session_, ovrEye_Right,
+      session_desc.DefaultEyeFov[ovrEye_Right]);
+
+  leftEye->offset = ovrVector3fToWebVR(leftEyeDesc.HmdToEyeOffset);
+  rightEye->offset = ovrVector3fToWebVR(rightEyeDesc.HmdToEyeOffset);
+
+  ovrSizei targetLeft = ovr_GetFovTextureSize(session_, ovrEye_Left,
+      session_desc.DefaultEyeFov[ovrEye_Left], 1.0f);
+  ovrSizei targetRight = ovr_GetFovTextureSize(session_, ovrEye_Right,
+      session_desc.DefaultEyeFov[ovrEye_Right], 1.0f);
+
+  leftEye->renderWidth = targetLeft.w;
+  leftEye->renderHeight = targetLeft.h;
+
+  rightEye->renderWidth = targetRight.w;
+  rightEye->renderHeight = targetRight.h;
+
+  /*device->stageParameters = mojom::VRStageParameters::New();
+  device->stageParameters->standingTransform = mojo::Array<float>::New(16);
+  mojo::Array<float>& transform =
+      device->stageParameters->standingTransform;
+  transform[0] = 1.0f;
+  transform[1] = 0.0f;
+  transform[2] = 0.0f;
+  transform[3] = 0.0f;
+  transform[4] = 0.0f;
+  transform[5] = 1.0f;
+  transform[6] = 0.0f;
+  transform[7] = 0.0f;
+  transform[8] = 0.0f;
+  transform[9] = 0.0f;
+  transform[10] = 1.0f;
+  transform[11] = 0.0f;
+  transform[12] = 0.0f;
+  transform[13] = GetFloorHeight();
+  transform[14] = 0.0f;
+  transform[15] = 1.0f;
+
+  device->stageParameters->sizeX = 0.0f;
+  device->stageParameters->sizeZ = 0.0f;*/
+
+  return device;
+}
+
+VRPosePtr OculusVRDevice::GetPose() {
+  VRPosePtr pose = VRPose::New();
+
+  ovrTrackingState ovr_state = ovr_GetTrackingState(session_,
+      ovr_GetTimeInSeconds(), true);
+
+  ovrPoseStatef pose_state = ovr_state.HeadPose;
+
+  pose->timestamp = base::Time::Now().ToJsTime();
+
+  // TODO: ovr_state.StatusFlags & (ovrStatus_OrientationTracked | ovrStatus_PositionTracked)
+  pose->orientation = ovrQuatfToWebVR(pose_state.ThePose.Orientation);
+  pose->position = ovrVector3fToWebVR(pose_state.ThePose.Position);
+  pose->angularVelocity = ovrVector3fToWebVR(pose_state.AngularVelocity);
+  pose->linearVelocity = ovrVector3fToWebVR(pose_state.LinearVelocity);
+  pose->angularAcceleration = ovrVector3fToWebVR(
+      pose_state.AngularAcceleration);
+  pose->linearAcceleration = ovrVector3fToWebVR(pose_state.LinearAcceleration);
+
+  return pose;
+}
+
+void OculusVRDevice::ResetPose() {
+  ovr_RecenterTrackingOrigin(session_);
+}
+
+float OculusVRDevice::GetFloorHeight() {
+  double query_time = ovr_GetTimeInSeconds();
+  ovrTrackingState ovr_state = ovr_GetTrackingState(session_, query_time, true);
+  ovrVector3f eye_origin = ovr_state.HeadPose.ThePose.Position;
+
+  ovr_SetTrackingOriginType(session_, ovrTrackingOrigin_FloorLevel);
+  ovr_state = ovr_GetTrackingState(session_, query_time, true);
+  ovrVector3f floor_origin = ovr_state.HeadPose.ThePose.Position;
+
+  ovr_SetTrackingOriginType(session_, ovrTrackingOrigin_EyeLevel);
+
+  return eye_origin.y - floor_origin.y;
+}
+
+}  // namespace content
diff --git a/content/browser/vr/oculus/oculus_vr_device.h b/content/browser/vr/oculus/oculus_vr_device.h
new file mode 100644
index 0000000..62c9fd3
--- /dev/null
+++ b/content/browser/vr/oculus/oculus_vr_device.h
@@ -0,0 +1,31 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_VR_OCULUS_VR_DEVICE_H
+#define CONTENT_BROWSER_VR_OCULUS_VR_DEVICE_H
+
+#include "content/browser/vr/vr_device.h"
+#include "third_party/libovr/LibOVR/Include/OVR_CAPI.h"
+
+namespace content {
+
+class OculusVRDevice : public VRDevice {
+ public:
+  OculusVRDevice(VRDeviceProvider* provider, ovrSession session);
+  ~OculusVRDevice() override;
+
+  VRDeviceInfoPtr GetVRDevice() override;
+  VRPosePtr GetPose() override;
+  void ResetPose() override;
+
+ private:
+
+  float GetFloorHeight();
+
+  ovrSession session_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_VR_OCULUS_VR_DEVICE_H
diff --git a/content/browser/vr/oculus/oculus_vr_device_provider.cc b/content/browser/vr/oculus/oculus_vr_device_provider.cc
new file mode 100644
index 0000000..f819e41
--- /dev/null
+++ b/content/browser/vr/oculus/oculus_vr_device_provider.cc
@@ -0,0 +1,101 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/vr/oculus/oculus_vr_device_provider.h"
+
+#include <algorithm>
+
+#include "base/bind.h"
+#include "content/browser/gamepad/gamepad_consumer.h"
+#include "content/browser/gamepad/gamepad_service.h"
+#include "content/browser/vr/oculus/oculus_vr_device.h"
+#include "content/browser/vr/oculus/oculus_vr_gamepad_data_fetcher.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace content {
+
+// Keeps the GamepadProvider alive while the OpenVRDeviceProvider is in use.
+class OculusVRGamepadConsumer : public GamepadConsumer {
+public:
+  ~OculusVRGamepadConsumer() override {};
+  void OnGamepadConnected(
+      unsigned index,
+      const blink::WebGamepad& gamepad) override {};
+  void OnGamepadDisconnected(
+      unsigned index,
+      const blink::WebGamepad& gamepad) override {};
+};
+
+OculusVRDeviceProvider::OculusVRDeviceProvider()
+    : VRDeviceProvider()
+    , initialized_(false)
+    , device_(false) {
+}
+
+OculusVRDeviceProvider::~OculusVRDeviceProvider() {
+  Shutdown();
+}
+
+void OculusVRDeviceProvider::GetDevices(std::vector<VRDevice*>* devices) {
+  Initialize();
+
+  if (!initialized_)
+    return;
+
+  if (!device_) {
+    ovrSession session;
+    ovrGraphicsLuid luid;
+    ovrResult result = ovr_Create(&session, &luid);
+
+    if (OVR_FAILURE(result)) {
+      return;
+    }
+
+    device_ = new OculusVRDevice(this, session);
+
+    BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&OculusVRDeviceProvider::RegisterGamepad,
+          base::Unretained(this), session));
+  }
+
+  if (device_)
+    devices->push_back(device_);
+}
+
+void OculusVRDeviceProvider::RegisterGamepad(ovrHmdStruct* session) {
+  GamepadService* gamepad_service = GamepadService::GetInstance();
+  gamepad_consumer_ = new OculusVRGamepadConsumer();
+  gamepad_service->ConsumerBecameActive(gamepad_consumer_);
+
+  GamepadProvider* provider = gamepad_service->provider();
+  if (provider) {
+    provider->AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher>(
+        new OculusVRGamepadDataFetcher(session)));
+    // TODO: Remove somewhere.
+  } else {
+    LOG(ERROR) << "No GamepadProvider available.";
+  }
+}
+
+void OculusVRDeviceProvider::Initialize() {
+  if (!initialized_) {
+    if (OVR_SUCCESS(ovr_Initialize(nullptr)))
+      initialized_ = true;
+  }
+}
+
+void OculusVRDeviceProvider::Shutdown() {
+  if (device_) {
+    delete device_;
+    device_ = nullptr;
+  }
+
+  if (initialized_) {
+    ovr_Shutdown();
+    initialized_ = false;
+  }
+}
+
+}  // namespace content
diff --git a/content/browser/vr/oculus/oculus_vr_device_provider.h b/content/browser/vr/oculus/oculus_vr_device_provider.h
new file mode 100644
index 0000000..5076709
--- /dev/null
+++ b/content/browser/vr/oculus/oculus_vr_device_provider.h
@@ -0,0 +1,40 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_VR_OCULUS_VR_DEVICE_PROVIDER_H
+#define CONTENT_BROWSER_VR_OCULUS_VR_DEVICE_PROVIDER_H
+
+#include <map>
+
+#include "content/browser/vr/vr_device.h"
+#include "content/browser/vr/vr_device_provider.h"
+
+struct ovrHmdStruct;
+
+namespace content {
+
+class GamepadConsumer;
+
+class OculusVRDeviceProvider : public VRDeviceProvider {
+ public:
+  OculusVRDeviceProvider();
+  ~OculusVRDeviceProvider() override;
+
+  void GetDevices(std::vector<VRDevice*>* devices) override;
+  void Initialize() override;
+
+ private:
+  void Shutdown();
+
+  void RegisterGamepad(ovrHmdStruct* session);
+
+  bool initialized_;
+
+  VRDevice* device_; // Oculus API only supports one device
+  GamepadConsumer* gamepad_consumer_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_VR_OCULUS_VR_DEVICE_PROVIDER_H
diff --git a/content/browser/vr/oculus/oculus_vr_gamepad_data_fetcher.cc b/content/browser/vr/oculus/oculus_vr_gamepad_data_fetcher.cc
new file mode 100644
index 0000000..7d303a9
--- /dev/null
+++ b/content/browser/vr/oculus/oculus_vr_gamepad_data_fetcher.cc
@@ -0,0 +1,80 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/vr/oculus/oculus_vr_gamepad_data_fetcher.h"
+
+#include "base/logging.h"
+#include "base/strings/stringprintf.h"
+#include "third_party/WebKit/public/platform/WebGamepads.h"
+#include "third_party/libovr/LibOVR/Include/OVR_CAPI.h"
+
+namespace content {
+
+using namespace blink;
+
+OculusVRGamepadDataFetcher::OculusVRGamepadDataFetcher(ovrHmdStruct* session)
+  : session_(session) {
+
+}
+
+OculusVRGamepadDataFetcher::~OculusVRGamepadDataFetcher() {
+  if (session_) {
+    ovr_Destroy(session_);
+    session_ = NULL;
+  }
+}
+
+void OculusVRGamepadDataFetcher::OnAddedToProvider() {
+  if (!session_) {
+    ovrGraphicsLuid luid;
+    if (OVR_FAILURE(ovr_Create(&session_, &luid))) {
+      LOG(ERROR) << "OculusVRGamepadDataFetcher failed ovr_Create";
+    }
+  }
+}
+
+void SetGamepadButton(WebGamepad& pad,
+    const ovrInputState& input_state, ovrButton button_id) {
+  bool pressed = (input_state.Buttons & button_id) != 0;
+  pad.buttons[pad.buttonsLength].pressed = pressed;
+  pad.buttons[pad.buttonsLength].value = pressed ? 1.0f : 0.0f;
+  pad.buttonsLength++;
+}
+
+void OculusVRGamepadDataFetcher::GetGamepadData(bool devices_changed_hint) {
+  if (!session_)
+    return;
+
+  ovrInputState input_state;
+  if ((OVR_SUCCESS(ovr_GetInputState(session_, ovrControllerType_Remote,
+      &input_state)))) {
+
+    PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_OCULUS, 0);
+    if (state) {
+      WebGamepad& pad = state->data;
+
+      if (state->active_state == GAMEPAD_NEWLY_ACTIVE) {
+        swprintf(pad.id, WebGamepad::idLengthCap, L"Oculus Remote");
+        pad.connected = true;
+      }
+
+      pad.timestamp = input_state.TimeInSeconds;
+      pad.axesLength = 0;
+      pad.buttonsLength = 0;
+
+      SetGamepadButton(pad, input_state, ovrButton_Enter);
+      SetGamepadButton(pad, input_state, ovrButton_Back);
+      SetGamepadButton(pad, input_state, ovrButton_Up);
+      SetGamepadButton(pad, input_state, ovrButton_Down);
+      SetGamepadButton(pad, input_state, ovrButton_Left);
+      SetGamepadButton(pad, input_state, ovrButton_Right);
+    }
+  }
+}
+
+void OculusVRGamepadDataFetcher::PauseHint(bool paused) {
+  // TODO
+}
+
+}  // namespace content
diff --git a/content/browser/vr/oculus/oculus_vr_gamepad_data_fetcher.h b/content/browser/vr/oculus/oculus_vr_gamepad_data_fetcher.h
new file mode 100644
index 0000000..148a945
--- /dev/null
+++ b/content/browser/vr/oculus/oculus_vr_gamepad_data_fetcher.h
@@ -0,0 +1,31 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_VR_OCULUS_VR_GAMEPAD_DATA_FETCHER_H_
+#define CONTENT_BROWSER_VR_OCULUS_VR_GAMEPAD_DATA_FETCHER_H_
+
+#include <string>
+
+#include "content/browser/gamepad/gamepad_data_fetcher.h"
+
+struct ovrHmdStruct;
+
+namespace content {
+
+class OculusVRGamepadDataFetcher : public GamepadDataFetcher {
+ public:
+  OculusVRGamepadDataFetcher(ovrHmdStruct* session);
+  ~OculusVRGamepadDataFetcher() override;
+  void GetGamepadData(bool devices_changed_hint) override;
+  void PauseHint(bool paused) override;
+  void OnAddedToProvider() override;
+
+ private:
+  ovrHmdStruct* session_;
+
+  DISALLOW_COPY_AND_ASSIGN(OculusVRGamepadDataFetcher);
+};
+
+}  // namespace content
+#endif // CONTENT_BROWSER_VR_OCULUS_R_GAMEPAD_DATA_FETCHER_H_
diff --git a/content/browser/vr/openvr/open_vr_device.cc b/content/browser/vr/openvr/open_vr_device.cc
new file mode 100644
index 0000000..22466ee
--- /dev/null
+++ b/content/browser/vr/openvr/open_vr_device.cc
@@ -0,0 +1,209 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/vr/openvr/open_vr_device.h"
+
+#include <algorithm>
+#include <math.h>
+
+#include "base/logging.h"
+#include "base/strings/stringprintf.h"
+#include "base/time/time.h"
+#include "third_party/openvr/openvr/headers/openvr.h"
+#include "ui/gfx/transform.h"
+#include "ui/gfx/transform_util.h"
+
+namespace content {
+
+namespace {
+
+const float radToDeg = 180.0f / 3.14159265358979323846f;
+
+VRFieldOfViewPtr openVRFovToWebVR(vr::IVRSystem* vr_system,
+                                         vr::Hmd_Eye eye) {
+  VRFieldOfViewPtr out = VRFieldOfView::New();
+
+  float upTan, downTan, leftTan, rightTan;
+  vr_system->GetProjectionRaw(eye, &leftTan, &rightTan, &upTan, &downTan);
+  out->upDegrees = -(atanf(upTan) * radToDeg);
+  out->downDegrees = atanf(downTan) * radToDeg;
+  out->leftDegrees = -(atanf(leftTan) * radToDeg);
+  out->rightDegrees = atanf(rightTan) * radToDeg;
+  return out;
+}
+
+mojo::Array<float> HmdVector3ToWebVR(const vr::HmdVector3_t& vec) {
+  mojo::Array<float> out = mojo::Array<float>::New(3);
+  out[0] = vec.v[0];
+  out[1] = vec.v[1];
+  out[2] = vec.v[2];
+  return out;
+}
+
+} // namespace
+
+OpenVRDevice::OpenVRDevice(VRDeviceProvider* provider,
+    vr::IVRSystem* vr_system,
+    vr::TrackedDeviceIndex_t device_index)
+    : VRDevice(provider)
+    , vr_system_(vr_system)
+    , device_index_(device_index)
+{
+}
+
+OpenVRDevice::~OpenVRDevice() {
+}
+
+std::string OpenVRDevice::getOpenVRString(vr::TrackedDeviceProperty prop) {
+  std::string out;
+
+  vr::TrackedPropertyError error = vr::TrackedProp_Success;
+  char openvr_string[vr::k_unTrackingStringSize];
+  vr_system_->GetStringTrackedDeviceProperty(
+    device_index_,
+    prop,
+    openvr_string,
+    vr::k_unTrackingStringSize,
+    &error);
+
+  if (error == vr::TrackedProp_Success)
+    out = openvr_string;
+
+  return out;
+}
+
+VRDeviceInfoPtr OpenVRDevice::GetVRDevice() {
+  VRDeviceInfoPtr device = VRDeviceInfo::New();
+
+  device->deviceName = getOpenVRString(vr::Prop_ManufacturerName_String) + " "
+                     + getOpenVRString(vr::Prop_ModelNumber_String);
+
+  vr::TrackedDeviceClass device_class = vr_system_->GetTrackedDeviceClass(
+      device_index_);
+
+  device->deviceCompositorType = VRDeviceInfo::CompositorType::OPENVR;
+
+  // Only populate the HMD info if this is actually an HMD
+  if (device_class == vr::TrackedDeviceClass_HMD) {
+    device->capabilities = VRDeviceCapabilities::New();
+    device->capabilities->hasOrientation = true;
+    device->capabilities->hasPosition = true;
+    device->capabilities->hasExternalDisplay = true;
+    device->capabilities->canPresent = true;
+
+    device->leftEye = VREyeParameters::New();
+    device->rightEye = VREyeParameters::New();
+    VREyeParametersPtr& leftEye = device->leftEye;
+    VREyeParametersPtr& rightEye = device->rightEye;
+
+    leftEye->fieldOfView = openVRFovToWebVR(vr_system_, vr::Eye_Left);
+    rightEye->fieldOfView = openVRFovToWebVR(vr_system_, vr::Eye_Right);
+
+    vr::TrackedPropertyError error = vr::TrackedProp_Success;
+    float ipd = vr_system_->GetFloatTrackedDeviceProperty(device_index_,
+        vr::Prop_UserIpdMeters_Float, &error);
+    if (error != vr::TrackedProp_Success)
+      ipd = 0.06f; // Default average IPD
+
+    leftEye->offset = mojo::Array<float>::New(3);
+    leftEye->offset[0] = -ipd * 0.5;
+    leftEye->offset[1] = 0.0f;
+    leftEye->offset[2] = 0.0f;
+
+    rightEye->offset = mojo::Array<float>::New(3);
+    rightEye->offset[0] = ipd * 0.5;
+    rightEye->offset[1] = 0.0;
+    rightEye->offset[2] = 0.0;
+
+    uint32_t width, height;
+    // This is the render size per-eye. OpenVR docs don't make that clear.
+    vr_system_->GetRecommendedRenderTargetSize(&width, &height);
+
+    leftEye->renderWidth = width;
+    leftEye->renderHeight = height;
+
+    rightEye->renderWidth = width;
+    rightEye->renderHeight = height;
+
+    device->stageParameters = VRStageParameters::New();
+    vr::HmdMatrix34_t mat =
+        vr_system_->GetSeatedZeroPoseToStandingAbsoluteTrackingPose();
+    device->stageParameters->standingTransform = mojo::Array<float>::New(16);
+    mojo::Array<float>& transform =
+        device->stageParameters->standingTransform;
+    transform[0] = mat.m[0][0];
+    transform[1] = mat.m[1][0];
+    transform[2] = mat.m[2][0];
+    transform[3] = 0.0f;
+    transform[4] = mat.m[0][1];
+    transform[5] = mat.m[1][1];
+    transform[6] = mat.m[2][1];
+    transform[7] = 0.0f;
+    transform[8] = mat.m[0][2];
+    transform[9] = mat.m[1][2];
+    transform[10] = mat.m[2][2];
+    transform[11] = 0.0f;
+    transform[12] = mat.m[0][3];
+    transform[13] = mat.m[1][3];
+    transform[14] = mat.m[2][3];
+    transform[15] = 1.0f;
+
+    // Values needed for room-scale experiences
+    vr::IVRChaperone* chaperone = vr::VRChaperone();
+    if (chaperone) {
+      chaperone->GetPlayAreaSize(&device->stageParameters->sizeX,
+                                  &device->stageParameters->sizeZ);
+    } else {
+      device->stageParameters->sizeX = 0.0f;
+      device->stageParameters->sizeZ = 0.0f;
+    }
+  }
+
+  return device;
+}
+
+VRPosePtr OpenVRDevice::GetPose() {
+  VRPosePtr state = VRPose::New();
+
+  state->timestamp = base::Time::Now().ToJsTime();
+
+  vr::TrackedDevicePose_t tracked_devices_poses[vr::k_unMaxTrackedDeviceCount];
+  vr_system_->GetDeviceToAbsoluteTrackingPose(vr::TrackingUniverseSeated,
+      0.04f, tracked_devices_poses, vr::k_unMaxTrackedDeviceCount);
+
+  const vr::TrackedDevicePose_t &pose = tracked_devices_poses[device_index_];
+  if (pose.bPoseIsValid) {
+    const vr::HmdMatrix34_t& mat = pose.mDeviceToAbsoluteTracking;
+    gfx::Transform transform(
+        mat.m[0][0], mat.m[0][1], mat.m[0][2], mat.m[0][3],
+        mat.m[1][0], mat.m[1][1], mat.m[1][2], mat.m[1][3],
+        mat.m[2][0], mat.m[2][1], mat.m[2][2], mat.m[2][3],
+        0, 0, 0, 1);
+
+    gfx::DecomposedTransform decomposed_transform;
+    gfx::DecomposeTransform(&decomposed_transform, transform);
+
+    state->orientation = mojo::Array<float>::New(4);
+    state->orientation[0] = decomposed_transform.quaternion[0];
+    state->orientation[1] = decomposed_transform.quaternion[1];
+    state->orientation[2] = decomposed_transform.quaternion[2];
+    state->orientation[3] = decomposed_transform.quaternion[3];
+
+    state->position = mojo::Array<float>::New(3);
+    state->position[0] = decomposed_transform.translate[0];
+    state->position[1] = decomposed_transform.translate[1];
+    state->position[2] = decomposed_transform.translate[2];
+
+    state->angularVelocity = HmdVector3ToWebVR(pose.vAngularVelocity);
+    state->linearVelocity = HmdVector3ToWebVR(pose.vVelocity);
+  }
+
+  return state;
+}
+
+void OpenVRDevice::ResetPose() {
+  vr_system_->ResetSeatedZeroPose();
+}
+
+}  // namespace content
diff --git a/content/browser/vr/openvr/open_vr_device.h b/content/browser/vr/openvr/open_vr_device.h
new file mode 100644
index 0000000..923c09b
--- /dev/null
+++ b/content/browser/vr/openvr/open_vr_device.h
@@ -0,0 +1,34 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_VR_OPENVR_DEVICE_H
+#define CONTENT_BROWSER_VR_OPENVR_DEVICE_H
+
+#include "content/browser/vr/vr_device.h"
+#include "third_party/openvr/openvr/headers/openvr.h"
+
+namespace content {
+
+class OpenVRDevice : public VRDevice {
+ public:
+  OpenVRDevice(VRDeviceProvider* provider,
+               vr::IVRSystem* vr_system,
+               vr::TrackedDeviceIndex_t device_index);
+  ~OpenVRDevice() override;
+
+  VRDeviceInfoPtr GetVRDevice() override;
+  VRPosePtr GetPose() override;
+  void ResetPose() override;
+
+ private:
+  void EnsureSensorStarted();
+  std::string getOpenVRString(vr::TrackedDeviceProperty prop);
+
+  vr::IVRSystem* vr_system_;
+  vr::TrackedDeviceIndex_t device_index_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_VR_OPENVR_DEVICE_H
diff --git a/content/browser/vr/openvr/open_vr_device_provider.cc b/content/browser/vr/openvr/open_vr_device_provider.cc
new file mode 100644
index 0000000..78e1bc0
--- /dev/null
+++ b/content/browser/vr/openvr/open_vr_device_provider.cc
@@ -0,0 +1,127 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/vr/openvr/open_vr_device_provider.h"
+
+#include <algorithm>
+
+#include "base/logging.h"
+#include "content/browser/gamepad/gamepad_consumer.h"
+#include "content/browser/gamepad/gamepad_service.h"
+#include "content/browser/vr/openvr/open_vr_device.h"
+#include "content/browser/vr/openvr/open_vr_gamepad_data_fetcher.h"
+#include "third_party/openvr/openvr/headers/openvr.h"
+
+namespace content {
+
+// Keeps the GamepadProvider alive while the OpenVRDeviceProvider is in use.
+class OpenVRGamepadConsumer : public GamepadConsumer {
+public:
+  ~OpenVRGamepadConsumer() override {};
+  void OnGamepadConnected(
+      unsigned index,
+      const blink::WebGamepad& gamepad) override {};
+  void OnGamepadDisconnected(
+      unsigned index,
+      const blink::WebGamepad& gamepad) override {};
+};
+
+OpenVRDeviceProvider::OpenVRDeviceProvider()
+    : VRDeviceProvider()
+    , initialized_(false)
+    , device_(nullptr)
+    , vr_system_(nullptr) {
+}
+
+OpenVRDeviceProvider::~OpenVRDeviceProvider() {
+  Shutdown();
+}
+
+void OpenVRDeviceProvider::GetDevices(std::vector<VRDevice*>* devices) {
+  Initialize();
+
+  if (!initialized_ || !vr_system_)
+    return;
+
+  vr::TrackedDevicePose_t tracked_devices_poses[vr::k_unMaxTrackedDeviceCount];
+  vr_system_->GetDeviceToAbsoluteTrackingPose(vr::TrackingUniverseStanding,
+      0, tracked_devices_poses, vr::k_unMaxTrackedDeviceCount);
+
+  if (!device_) {
+    for (uint32_t i = 0; i < vr::k_unMaxTrackedDeviceCount; ++i) {
+      if (vr_system_->GetTrackedDeviceClass(i) != vr::TrackedDeviceClass_HMD)
+        continue;
+
+      // Don't use OpenVR to track Oculus devices.
+      vr::TrackedPropertyError error = vr::TrackedProp_Success;
+      int32_t vendor_id = vr_system_->GetInt32TrackedDeviceProperty(i,
+          vr::Prop_EdidVendorID_Int32, &error);
+      if (error == vr::TrackedProp_Success && vendor_id == 0xD23E)
+        continue;
+
+      device_ = new OpenVRDevice(this, vr_system_, i);
+      break;
+    }
+  }
+
+  if (device_)
+    devices->push_back(device_);
+}
+
+void OpenVRDeviceProvider::Initialize() {
+  if (!initialized_) {
+    // Does a fast check to see if any devices could possibly be connected.
+    if (!vr::VR_IsHmdPresent())
+      return;
+
+    // Loading the SteamVR Runtime
+    vr::EVRInitError error = vr::VRInitError_None;
+    vr_system_ = vr::VR_Init(&error, vr::VRApplication_Scene);
+
+    if (error != vr::VRInitError_None) {
+      vr_system_ = nullptr;
+      return;
+    }
+
+    GamepadService* gamepad_service = GamepadService::GetInstance();
+    gamepad_consumer_ = new OpenVRGamepadConsumer();
+    gamepad_service->ConsumerBecameActive(gamepad_consumer_);
+
+    GamepadProvider* provider = gamepad_service->provider();
+    if (provider) {
+      provider->AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher>(
+          new OpenVRGamepadDataFetcher()));
+      // TODO: Remove somewhere.
+    } else {
+      LOG(ERROR) << "No GamepadProvider available.";
+    }
+
+    initialized_ = true;
+  }
+}
+
+void OpenVRDeviceProvider::Shutdown() {
+  if (gamepad_consumer_) {
+    GamepadService::GetInstance()->RemoveConsumer(gamepad_consumer_);
+    //delete gamepad_consumer_; // EVIL BAD DEVELOPER! NO COOKIE!
+    gamepad_consumer_ = nullptr;
+  }
+
+  if (device_) {
+    delete device_;
+    device_ = nullptr;
+  }
+
+  if (initialized_) {
+    // TODO: Hm... when using the gamepad API we can't call shutdown until the
+    // gamepad is aalso shut down, since it unloads the DLL and will cause
+    // crashiness. For now just letting it live forever. :) Need to build some
+    // type of ref-counting singleton.
+    //vr::VR_Shutdown();
+    vr_system_ = nullptr;
+    initialized_ = false;
+  }
+}
+
+}  // namespace content
diff --git a/content/browser/vr/openvr/open_vr_device_provider.h b/content/browser/vr/openvr/open_vr_device_provider.h
new file mode 100644
index 0000000..79bf66a
--- /dev/null
+++ b/content/browser/vr/openvr/open_vr_device_provider.h
@@ -0,0 +1,43 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_VR_OPENVR_DEVICE_PROVIDER_H
+#define CONTENT_BROWSER_VR_OPENVR_DEVICE_PROVIDER_H
+
+#include <map>
+
+#include "content/browser/vr/vr_device.h"
+#include "content/browser/vr/vr_device_provider.h"
+
+namespace vr {
+
+class IVRSystem;
+
+}  // namespace vr
+
+namespace content {
+
+class GamepadConsumer;
+
+class OpenVRDeviceProvider : public VRDeviceProvider {
+ public:
+  OpenVRDeviceProvider();
+  ~OpenVRDeviceProvider() override;
+
+  void GetDevices(std::vector<VRDevice*>* devices) override;
+  void Initialize() override;
+
+ private:
+  void Shutdown();
+
+  bool initialized_;
+
+  VRDevice* device_;
+  vr::IVRSystem* vr_system_;
+  GamepadConsumer* gamepad_consumer_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_VR_OPENVR_DEVICE_PROVIDER_H
diff --git a/content/browser/vr/openvr/open_vr_gamepad_data_fetcher.cc b/content/browser/vr/openvr/open_vr_gamepad_data_fetcher.cc
new file mode 100644
index 0000000..655ed8b
--- /dev/null
+++ b/content/browser/vr/openvr/open_vr_gamepad_data_fetcher.cc
@@ -0,0 +1,177 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/vr/openvr/open_vr_gamepad_data_fetcher.h"
+
+#include "base/logging.h"
+#include "base/strings/stringprintf.h"
+#include "third_party/WebKit/public/platform/WebGamepads.h"
+#include "third_party/openvr/openvr/headers/openvr.h"
+#include "ui/gfx/transform.h"
+#include "ui/gfx/transform_util.h"
+
+namespace content {
+
+using namespace blink;
+
+OpenVRGamepadDataFetcher::OpenVRGamepadDataFetcher()
+  : vr_system_(nullptr) {
+
+}
+
+OpenVRGamepadDataFetcher::~OpenVRGamepadDataFetcher() {
+  /*if (vr_system_) {
+    vr::VR_Shutdown();
+    vr_system_ = nullptr;
+  }*/
+}
+
+void OpenVRGamepadDataFetcher::OnAddedToProvider() {
+  // Loading the SteamVR Runtime
+  vr::EVRInitError error = vr::VRInitError_None;
+  vr_system_ = vr::VR_Init(&error, vr::VRApplication_Scene);
+
+  if (error != vr::VRInitError_None) {
+    vr_system_ = nullptr;
+    return;
+  }
+}
+
+void SetGamepadButton(WebGamepad& pad,
+    vr::VRControllerState_t& controller_state, uint64_t supported_buttons,
+    vr::EVRButtonId button_id) {
+  uint64_t button_mask = vr::ButtonMaskFromId(button_id);
+  if ((supported_buttons & button_mask) != 0) {
+    bool button_pressed = (controller_state.ulButtonPressed & button_mask) != 0;
+    bool button_touched = (controller_state.ulButtonTouched & button_mask) != 0;
+    pad.buttons[pad.buttonsLength].touched = button_touched;
+    pad.buttons[pad.buttonsLength].pressed = button_pressed;
+    pad.buttons[pad.buttonsLength].value = button_pressed ? 1.0 : 0.0;
+    pad.buttonsLength++;
+  }
+}
+
+void OpenVRGamepadDataFetcher::GetGamepadData(
+    bool devices_changed_hint) {
+  if (!vr_system_)
+    return;
+
+  vr::TrackedDevicePose_t tracked_devices_poses[vr::k_unMaxTrackedDeviceCount];
+  vr_system_->GetDeviceToAbsoluteTrackingPose(vr::TrackingUniverseSeated,
+      0.04f, tracked_devices_poses, vr::k_unMaxTrackedDeviceCount);
+
+  for (uint32_t i = 0; i < vr::k_unMaxTrackedDeviceCount; ++i) {
+    if (vr_system_->GetTrackedDeviceClass(i) !=
+        vr::TrackedDeviceClass_Controller)
+        continue;
+
+    PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_OPENVR, i);
+    if (!state)
+      continue; // No available slot.
+
+    WebGamepad& pad = state->data;
+
+    vr::VRControllerState_t controller_state;
+    if (vr_system_->GetControllerState(i, &controller_state)) {
+      pad.timestamp = controller_state.unPacketNum;
+      pad.connected = true;
+
+      // TODO: vr::Prop_AttachedDeviceId_String
+      swprintf(pad.id, WebGamepad::idLengthCap, L"OpenVR Gamepad");
+
+      uint64_t supported_buttons = vr_system_->GetUint64TrackedDeviceProperty(
+          i, vr::Prop_SupportedButtons_Uint64);
+
+      pad.buttonsLength = 0;
+      pad.axesLength = 0;
+
+      for (int j = 0; j < vr::k_unControllerStateAxisCount; ++j) {
+        int32_t axis_type = vr_system_->GetInt32TrackedDeviceProperty(
+            i, static_cast<vr::TrackedDeviceProperty>(
+                vr::Prop_Axis0Type_Int32+j));
+        switch (axis_type) {
+        case vr::k_eControllerAxis_Joystick:
+        case vr::k_eControllerAxis_TrackPad:
+          pad.axes[pad.axesLength++] = controller_state.rAxis[j].x;
+          pad.axes[pad.axesLength++] = controller_state.rAxis[j].y;
+
+          SetGamepadButton(pad, controller_state, supported_buttons,
+              static_cast<vr::EVRButtonId>(vr::k_EButton_Axis0+j));
+
+          break;
+        case vr::k_eControllerAxis_Trigger:
+          pad.buttons[pad.buttonsLength].value = controller_state.rAxis[j].x;
+
+          uint64_t button_mask = vr::ButtonMaskFromId(
+              static_cast<vr::EVRButtonId>(vr::k_EButton_Axis0+j));
+          if ((supported_buttons & button_mask) != 0) {
+            pad.buttons[pad.buttonsLength].pressed =
+                (controller_state.ulButtonPressed & button_mask) != 0;
+          }
+
+          pad.buttonsLength++;
+          break;
+        }
+      }
+
+      SetGamepadButton(pad, controller_state, supported_buttons,
+          vr::k_EButton_A);
+      SetGamepadButton(pad, controller_state, supported_buttons,
+          vr::k_EButton_Grip);
+      SetGamepadButton(pad, controller_state, supported_buttons,
+          vr::k_EButton_ApplicationMenu);
+      //SetGamepadButton(pad, controller_state, supported_buttons,
+      //  vr::k_EButton_System);
+
+      SetGamepadButton(pad, controller_state, supported_buttons,
+          vr::k_EButton_DPad_Left);
+      SetGamepadButton(pad, controller_state, supported_buttons,
+          vr::k_EButton_DPad_Up);
+      SetGamepadButton(pad, controller_state, supported_buttons,
+          vr::k_EButton_DPad_Right);
+      SetGamepadButton(pad, controller_state, supported_buttons,
+          vr::k_EButton_DPad_Down);
+    }
+
+    const vr::TrackedDevicePose_t &pose = tracked_devices_poses[i];
+    if (pose.bPoseIsValid) {
+      const vr::HmdMatrix34_t& mat = pose.mDeviceToAbsoluteTracking;
+      gfx::Transform transform(
+          mat.m[0][0], mat.m[0][1], mat.m[0][2], mat.m[0][3],
+          mat.m[1][0], mat.m[1][1], mat.m[1][2], mat.m[1][3],
+          mat.m[2][0], mat.m[2][1], mat.m[2][2], mat.m[2][3],
+          0, 0, 0, 1);
+
+      gfx::DecomposedTransform decomposed_transform;
+      gfx::DecomposeTransform(&decomposed_transform, transform);
+
+      pad.pose.isNull = false;
+
+      pad.pose.orientation.isNull = false;
+      pad.pose.orientation.x = decomposed_transform.quaternion[0];
+      pad.pose.orientation.y = decomposed_transform.quaternion[1];
+      pad.pose.orientation.z = decomposed_transform.quaternion[2];
+      pad.pose.orientation.w = decomposed_transform.quaternion[3];
+
+      pad.pose.position.isNull = false;
+      pad.pose.position.x = decomposed_transform.translate[0];
+      pad.pose.position.y = decomposed_transform.translate[1];
+      pad.pose.position.z = decomposed_transform.translate[2];
+      pad.pose.position.w = 0.0f;
+
+      //state->angularVelocity = HmdVector3ToWebVR(pose.vAngularVelocity);
+      //state->linearVelocity = HmdVector3ToWebVR(pose.vVelocity);
+    } else {
+      pad.pose.isNull = true;
+      pad.pose.orientation.isNull = true;
+      pad.pose.position.isNull = true;
+    }
+  }
+}
+
+void OpenVRGamepadDataFetcher::PauseHint(bool paused) {
+  // TODO
+}
+
+}  // namespace content
diff --git a/content/browser/vr/openvr/open_vr_gamepad_data_fetcher.h b/content/browser/vr/openvr/open_vr_gamepad_data_fetcher.h
new file mode 100644
index 0000000..a7b0c3c
--- /dev/null
+++ b/content/browser/vr/openvr/open_vr_gamepad_data_fetcher.h
@@ -0,0 +1,30 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_VR_OPENVR_GAMEPAD_DATA_FETCHER_H_
+#define CONTENT_BROWSER_VR_OPENVR_GAMEPAD_DATA_FETCHER_H_
+
+#include <string>
+
+#include "content/browser/gamepad/gamepad_data_fetcher.h"
+#include "third_party/openvr/openvr/headers/openvr.h"
+
+namespace content {
+
+class OpenVRGamepadDataFetcher : public GamepadDataFetcher {
+ public:
+  OpenVRGamepadDataFetcher();
+  ~OpenVRGamepadDataFetcher() override;
+  void GetGamepadData(bool devices_changed_hint) override;
+  void PauseHint(bool paused) override;
+  void OnAddedToProvider() override;
+
+ private:
+  vr::IVRSystem* vr_system_;
+
+  DISALLOW_COPY_AND_ASSIGN(OpenVRGamepadDataFetcher);
+};
+
+}  // namespace content
+#endif // CONTENT_BROWSER_VR_OPENVR_GAMEPAD_DATA_FETCHER_H_
diff --git a/content/browser/vr/simulated/simulated_vr_device.cc b/content/browser/vr/simulated/simulated_vr_device.cc
new file mode 100644
index 0000000..b5312f0
--- /dev/null
+++ b/content/browser/vr/simulated/simulated_vr_device.cc
@@ -0,0 +1,245 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/vr/simulated/simulated_vr_device.h"
+
+#include <algorithm>
+#include <math.h>
+
+#include "base/strings/stringprintf.h"
+#include "base/time/time.h"
+
+namespace content {
+
+namespace {
+
+const float degToRad = 3.14159265358979323846f / 180.0f;
+
+mojo::Array<float> randomPos() {
+  mojo::Array<float> out = mojo::Array<float>::New(3);
+
+  out[0] = (static_cast<float>(rand() % 10) / 10.0f) - 0.5f;
+  out[1] = (static_cast<float>(rand() % 10) / 10.0f) - 0.5f;
+  out[2] = (static_cast<float>(rand() % 10) / 10.0f) - 0.5f;
+
+  return out;
+}
+
+mojo::Array<float> lerpPos(const mojo::Array<float>& a,
+                           const mojo::Array<float>& b,
+                           float t) {
+  mojo::Array<float> out = mojo::Array<float>::New(3);
+
+  out[0] = a[0] + t * (b[0] - a[0]);
+  out[1] = a[1] + t * (b[1] - a[1]);
+  out[2] = a[2] + t * (b[2] - a[2]);
+
+  return out;
+}
+
+float randomAngle(float min, float max) {
+  float range = (max - min) / 360.0f;
+  float deg = min + (static_cast<float>(rand() % 360) * range);
+  return deg * degToRad;
+};
+
+// Generates a random orientation that tries to be a semi-realistic head pose
+// (So no upside down views or anything)
+mojo::Array<float> randomQuat() {
+  mojo::Array<float> out = mojo::Array<float>::New(4);
+  out[3] = 1.0;
+
+  float ax, ay, az, aw;
+  float bx, by, bw;
+  float rad;
+
+  // Rotate on Y axis
+  rad = randomAngle(-80.0f, 80.0f);
+  by = sinf(rad);
+  bw = cosf(rad);
+  ax = out[0]; ay = out[1]; az = out[2]; aw = out[3];
+  out[0] = ax * bw - az * by;
+  out[1] = ay * bw + aw * by;
+  out[2] = az * bw + ax * by;
+  out[3] = aw * bw - ay * by;
+
+  // Rotate on X axis (Doesn't do quite what you'd think)
+  rad = randomAngle(-20.0f, 20.0f);
+  bx = sinf(rad);
+  bw = cosf(rad);
+  ax = out[0]; ay = out[1]; az = out[2]; aw = out[3];
+  out[0] = ax * bw + aw * bx;
+  out[1] = ay * bw + az * bx;
+  out[2] = az * bw - ay * bx;
+  out[3] = aw * bw - ax * bx;
+
+  // Normalize
+  float len = out[0]*out[0] + out[1]*out[1] + out[2]*out[2] + out[3]*out[3];
+  if (len > 0.0f) {
+      len = 1.0f / sqrtf(len);
+      out[0] *= len;
+      out[1] *= len;
+      out[2] *= len;
+      out[3] *= len;
+  }
+
+  return out;
+}
+
+mojo::Array<float> slerpQuat(const mojo::Array<float>& a,
+                             const mojo::Array<float>& b,
+                             float t) {
+  mojo::Array<float> out = mojo::Array<float>::New(4);
+
+  float ax = a[0], ay = a[1], az = a[2], aw = a[3];
+  float bx = b[0], by = b[1], bz = b[2], bw = b[3];
+  float omega, sinom, scale0, scale1;
+
+  // calc cosine
+  float cosom = ax * bx + ay * by + az * bz + aw * bw;
+  // adjust signs (if necessary)
+  if ( cosom < 0.0 ) {
+      cosom = -cosom;
+      bx = - bx;
+      by = - by;
+      bz = - bz;
+      bw = - bw;
+  }
+  // calculate coefficients
+  if ( (1.0f - cosom) > 0.00001f ) {
+      // standard case (slerp)
+      omega  = acos(cosom);
+      sinom  = sinf(omega);
+      scale0 = sinf((1.0f - t) * omega) / sinom;
+      scale1 = sinf(t * omega) / sinom;
+  } else {
+      // "from" and "to" quaternions are very close
+      //  ... so we can do a linear interpolation
+      scale0 = 1.0f - t;
+      scale1 = t;
+  }
+  // calculate final values
+  out[0] = scale0 * ax + scale1 * bx;
+  out[1] = scale0 * ay + scale1 * by;
+  out[2] = scale0 * az + scale1 * bz;
+  out[3] = scale0 * aw + scale1 * bw;
+
+  return out;
+}
+
+} // namespace
+
+SimulatedVRDevice::SimulatedVRDevice(VRDeviceProvider* provider)
+    : VRDevice(provider)
+    , t(0.0f)
+{
+  lastQuat = mojo::Array<float>::New(4);
+  lastQuat[3] = 1.0;
+  nextQuat = randomQuat();
+
+  lastPos = mojo::Array<float>::New(3);
+  nextPos = randomPos();
+}
+
+SimulatedVRDevice::~SimulatedVRDevice() {
+}
+
+VRDeviceInfoPtr SimulatedVRDevice::GetVRDevice() {
+  VRDeviceInfoPtr device = VRDeviceInfo::New();
+
+  device->deviceName = "Simulated VR Device";
+  device->deviceCompositorType = VRDeviceInfo::CompositorType::NONE;
+
+  device->capabilities = VRDeviceCapabilities::New();
+  device->capabilities->hasOrientation = false;
+  device->capabilities->hasPosition = false;
+  device->capabilities->hasExternalDisplay = false;
+
+  device->leftEye = VREyeParameters::New();
+  device->rightEye = VREyeParameters::New();
+  VREyeParametersPtr& leftEye = device->leftEye;
+  VREyeParametersPtr& rightEye = device->rightEye;
+
+  leftEye->fieldOfView = VRFieldOfView::New();
+  leftEye->fieldOfView->upDegrees = 45.0f;
+  leftEye->fieldOfView->downDegrees = 45.0f;
+  leftEye->fieldOfView->leftDegrees = 45.0f;
+  leftEye->fieldOfView->rightDegrees = 35.0f;
+
+  rightEye->fieldOfView = VRFieldOfView::New();
+  rightEye->fieldOfView->upDegrees = 45.0f;
+  rightEye->fieldOfView->downDegrees = 45.0f;
+  rightEye->fieldOfView->leftDegrees = 35.0f;
+  rightEye->fieldOfView->rightDegrees = 45.0f;
+
+  leftEye->offset = mojo::Array<float>::New(3);
+  leftEye->offset[0] = -0.03f;
+  leftEye->offset[1] = 0.0f;
+  leftEye->offset[2] = 0.0f;
+
+  rightEye->offset = mojo::Array<float>::New(3);
+  rightEye->offset[0] = 0.03f;
+  rightEye->offset[1] = 0.0f;
+  rightEye->offset[2] = 0.0f;
+
+  leftEye->renderWidth = 640;
+  leftEye->renderHeight = 720;
+
+  rightEye->renderWidth = 640;
+  rightEye->renderHeight = 720;
+
+  device->stageParameters = VRStageParameters::New();
+  device->stageParameters->sizeX = 1.5;
+  device->stageParameters->sizeZ = 1.5;
+  device->stageParameters->standingTransform = mojo::Array<float>::New(16);
+  mojo::Array<float>& transform =
+      device->stageParameters->standingTransform;
+  transform[0] = 1.0f;
+  transform[1] = 0.0f;
+  transform[2] = 0.0f;
+  transform[3] = 0.0f;
+  transform[4] = 0.0f;
+  transform[5] = 1.0f;
+  transform[6] = 0.0f;
+  transform[7] = 0.0f;
+  transform[8] = 0.0f;
+  transform[9] = 0.0f;
+  transform[10] = 1.0f;
+  transform[11] = 0.0f;
+  transform[12] = 0.0f;
+  transform[13] = 1.6f; // 1.6 meters height
+  transform[14] = 0.0f;
+  transform[15] = 1.0f;
+
+  return device;
+}
+
+VRPosePtr SimulatedVRDevice::GetPose() {
+  VRPosePtr state = VRPose::New();
+
+  state->timestamp = base::Time::Now().ToJsTime();
+
+  t += 0.01f;
+
+  if (t >= 1.0f) {
+    lastQuat = nextQuat.Clone();
+    nextQuat = randomQuat();
+
+    lastPos = nextPos.Clone();
+    nextPos = randomPos();
+
+    t -= 1.0f;
+  }
+
+  state->orientation = slerpQuat(lastQuat, nextQuat, t);
+  state->position = lerpPos(lastPos, nextPos, t);
+
+  return state;
+}
+
+void SimulatedVRDevice::ResetPose() {
+
+}
+
+}  // namespace content
diff --git a/content/browser/vr/simulated/simulated_vr_device.h b/content/browser/vr/simulated/simulated_vr_device.h
new file mode 100644
index 0000000..bca545b
--- /dev/null
+++ b/content/browser/vr/simulated/simulated_vr_device.h
@@ -0,0 +1,32 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_VR_SIMULATED_VR_DEVICE_H
+#define CONTENT_BROWSER_VR_SIMULATED_VR_DEVICE_H
+
+#include "content/browser/vr/vr_device.h"
+
+namespace content {
+
+class SimulatedVRDevice : public VRDevice {
+ public:
+  SimulatedVRDevice(VRDeviceProvider* provider);
+  ~SimulatedVRDevice() override;
+
+  VRDeviceInfoPtr GetVRDevice() override;
+  VRPosePtr GetPose() override;
+  void ResetPose() override;
+
+ private:
+  mojo::Array<float> lastQuat;
+  mojo::Array<float> nextQuat;
+
+  mojo::Array<float> lastPos;
+  mojo::Array<float> nextPos;
+  float t;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_VR_SIMULATED_VR_DEVICE_H
diff --git a/content/browser/vr/simulated/simulated_vr_device_provider.cc b/content/browser/vr/simulated/simulated_vr_device_provider.cc
new file mode 100644
index 0000000..56fcc0d
--- /dev/null
+++ b/content/browser/vr/simulated/simulated_vr_device_provider.cc
@@ -0,0 +1,33 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/vr/simulated/simulated_vr_device_provider.h"
+
+#include "content/browser/vr/simulated/simulated_vr_device.h"
+
+namespace content {
+
+SimulatedVRDeviceProvider::SimulatedVRDeviceProvider()
+    : device_(nullptr) {
+}
+
+SimulatedVRDeviceProvider::~SimulatedVRDeviceProvider() {
+  if (device_) {
+    delete device_;
+    device_ = nullptr;
+  }
+}
+
+void SimulatedVRDeviceProvider::GetDevices(std::vector<VRDevice*>* devices) {
+  if (!device_)
+    device_ = new SimulatedVRDevice(this);
+
+  devices->push_back(device_);
+}
+
+void SimulatedVRDeviceProvider::Initialize() {
+
+}
+
+}  // namespace content
diff --git a/content/browser/vr/simulated/simulated_vr_device_provider.h b/content/browser/vr/simulated/simulated_vr_device_provider.h
new file mode 100644
index 0000000..bc14d0c
--- /dev/null
+++ b/content/browser/vr/simulated/simulated_vr_device_provider.h
@@ -0,0 +1,29 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_VR_SIMULATED_VR_DEVICE_PROVIDER_H
+#define CONTENT_BROWSER_VR_SIMULATED_VR_DEVICE_PROVIDER_H
+
+#include <map>
+
+#include "content/browser/vr/vr_device.h"
+#include "content/browser/vr/vr_device_provider.h"
+
+namespace content {
+
+class SimulatedVRDeviceProvider : public VRDeviceProvider {
+ public:
+  SimulatedVRDeviceProvider();
+  ~SimulatedVRDeviceProvider() override;
+
+  void GetDevices(std::vector<VRDevice*>* devices) override;
+  void Initialize() override;
+
+ private:
+  VRDevice* device_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_VR_SIMULATED_VR_DEVICE_PROVIDER_H
diff --git a/content/browser/vr/test/fake_vr_device.cc b/content/browser/vr/test/fake_vr_device.cc
index 7ee5e06..30d5a11 100644
--- a/content/browser/vr/test/fake_vr_device.cc
+++ b/content/browser/vr/test/fake_vr_device.cc
@@ -7,18 +7,18 @@
 namespace content {
 
 FakeVRDevice::FakeVRDevice(VRDeviceProvider* provider) : VRDevice(provider) {
-  device_ = VRDeviceInfo::New();
-  state_ = VRSensorState::New();
+  device_ = mojom::VRDeviceInfo::New();
+  state_ = mojom::VRSensorState::New();
 }
 
 FakeVRDevice::~FakeVRDevice() {
 }
 
-void FakeVRDevice::SetVRDevice(const VRDeviceInfoPtr& device) {
+void FakeVRDevice::SetVRDevice(const mojom::VRDeviceInfoPtr& device) {
   device_ = device.Clone();
 }
 
-void FakeVRDevice::SetSensorState(const VRSensorStatePtr& state) {
+void FakeVRDevice::SetSensorState(const mojom::VRSensorStatePtr& state) {
   state_ = state.Clone();
 }
 
diff --git a/content/browser/vr/test/fake_vr_device.h b/content/browser/vr/test/fake_vr_device.h
index b58ac93..2f88a36 100644
--- a/content/browser/vr/test/fake_vr_device.h
+++ b/content/browser/vr/test/fake_vr_device.h
@@ -16,16 +16,16 @@ class FakeVRDevice : public VRDevice {
   explicit FakeVRDevice(VRDeviceProvider* provider);
   ~FakeVRDevice() override;
 
-  void SetVRDevice(const VRDeviceInfoPtr& device);
-  void SetSensorState(const VRSensorStatePtr& state);
+  void SetVRDevice(const mojom::VRDeviceInfoPtr& device);
+  void SetSensorState(const mojom::VRSensorStatePtr& state);
 
-  VRDeviceInfoPtr GetVRDevice() override;
-  VRSensorStatePtr GetSensorState() override;
+  mojom::VRDeviceInfoPtr GetVRDevice() override;
+  mojom::VRSensorStatePtr GetSensorState() override;
   void ResetSensor() override{};
 
  private:
-  VRDeviceInfoPtr device_;
-  VRSensorStatePtr state_;
+  mojom::VRDeviceInfoPtr device_;
+  mojom::VRSensorStatePtr state_;
 
   DISALLOW_COPY_AND_ASSIGN(FakeVRDevice);
 };
diff --git a/content/browser/vr/vr_device.h b/content/browser/vr/vr_device.h
index e3026d7..485bc9c 100644
--- a/content/browser/vr/vr_device.h
+++ b/content/browser/vr/vr_device.h
@@ -31,8 +31,8 @@ class VRDevice {
   unsigned int id() const { return id_; }
 
   virtual VRDeviceInfoPtr GetVRDevice() = 0;
-  virtual VRSensorStatePtr GetSensorState() = 0;
-  virtual void ResetSensor() = 0;
+  virtual VRPosePtr GetPose() = 0;
+  virtual void ResetPose() = 0;
 
  private:
   VRDeviceProvider* provider_;
diff --git a/content/browser/vr/vr_device_manager.cc b/content/browser/vr/vr_device_manager.cc
index ff323f6..d2b3168 100644
--- a/content/browser/vr/vr_device_manager.cc
+++ b/content/browser/vr/vr_device_manager.cc
@@ -11,10 +11,17 @@
 #include "build/build_config.h"
 #include "third_party/WebKit/public/platform/modules/vr/WebVR.h"
 
+#if defined(OS_WIN)
+#include "content/browser/vr/oculus/oculus_vr_device_provider.h"
+#include "content/browser/vr/openvr/open_vr_device_provider.h"
+#endif
+
 #if defined(OS_ANDROID)
 #include "content/browser/vr/android/cardboard/cardboard_vr_device_provider.h"
 #endif
 
+#include "content/browser/vr/simulated/simulated_vr_device_provider.h"
+
 namespace content {
 
 namespace {
@@ -25,15 +32,32 @@ VRDeviceManager::VRDeviceManager()
     : vr_initialized_(false), keep_alive_(false) {
   bindings_.set_connection_error_handler(
       base::Bind(&VRDeviceManager::OnConnectionError, base::Unretained(this)));
+
 // Register VRDeviceProviders for the current platform
 #if defined(OS_ANDROID)
-  scoped_ptr<VRDeviceProvider> cardboard_provider(
+  std::unique_ptr<VRDeviceProvider> cardboard_provider(
       new CardboardVRDeviceProvider());
   RegisterProvider(std::move(cardboard_provider));
 #endif
+
+#if defined(OS_WIN)
+  std::unique_ptr<VRDeviceProvider> oculus_provider(
+      new OculusVRDeviceProvider());
+  RegisterProvider(std::move(oculus_provider));
+
+  std::unique_ptr<VRDeviceProvider> openvr_provider(
+      new OpenVRDeviceProvider());
+  RegisterProvider(std::move(openvr_provider));
+#endif
+
+/*#if defined(WEBVR_USE_SIMULATED)
+  std::unique_ptr<VRDeviceProvider> simulated_vr_provider(
+    new SimulatedVRDeviceProvider());
+  RegisterProvider(std::move(simulated_vr_provider));
+#endif*/
 }
 
-VRDeviceManager::VRDeviceManager(scoped_ptr<VRDeviceProvider> provider)
+VRDeviceManager::VRDeviceManager(std::unique_ptr<VRDeviceProvider> provider)
     : vr_initialized_(false), keep_alive_(true) {
   thread_checker_.DetachFromThread();
   RegisterProvider(std::move(provider));
@@ -45,7 +69,8 @@ VRDeviceManager::~VRDeviceManager() {
   g_vr_device_manager = nullptr;
 }
 
-void VRDeviceManager::BindRequest(mojo::InterfaceRequest<VRService> request) {
+void VRDeviceManager::BindRequest(
+    mojo::InterfaceRequest<VRService> request) {
   VRDeviceManager* device_manager = GetInstance();
   device_manager->bindings_.AddBinding(device_manager, std::move(request));
 }
@@ -108,6 +133,10 @@ mojo::Array<VRDeviceInfoPtr> VRDeviceManager::GetVRDevices() {
 VRDevice* VRDeviceManager::GetDevice(unsigned int index) {
   DCHECK(thread_checker_.CalledOnValidThread());
 
+  if (index == 0) {
+    return NULL;
+  }
+
   DeviceMap::iterator iter = devices_.find(index);
   if (iter == devices_.end()) {
     return nullptr;
@@ -126,7 +155,8 @@ void VRDeviceManager::InitializeProviders() {
   vr_initialized_ = true;
 }
 
-void VRDeviceManager::RegisterProvider(scoped_ptr<VRDeviceProvider> provider) {
+void VRDeviceManager::RegisterProvider(
+    std::unique_ptr<VRDeviceProvider> provider) {
   providers_.push_back(make_linked_ptr(provider.release()));
 }
 
@@ -134,20 +164,20 @@ void VRDeviceManager::GetDevices(const GetDevicesCallback& callback) {
   callback.Run(GetVRDevices());
 }
 
-void VRDeviceManager::GetSensorState(uint32_t index,
-                                     const GetSensorStateCallback& callback) {
+void VRDeviceManager::GetPose(uint32_t index,
+                              const GetPoseCallback& callback) {
   VRDevice* device = GetDevice(index);
   if (device) {
-    callback.Run(device->GetSensorState());
+    callback.Run(device->GetPose());
   } else {
     callback.Run(nullptr);
   }
 }
 
-void VRDeviceManager::ResetSensor(uint32_t index) {
+void VRDeviceManager::ResetPose(uint32_t index) {
   VRDevice* device = GetDevice(index);
   if (device)
-    device->ResetSensor();
+    device->ResetPose();
 }
 
 }  // namespace content
diff --git a/content/browser/vr/vr_device_manager.h b/content/browser/vr/vr_device_manager.h
index 00a51ec..2a5e79c 100644
--- a/content/browser/vr/vr_device_manager.h
+++ b/content/browser/vr/vr_device_manager.h
@@ -8,11 +8,11 @@
 #include <stdint.h>
 
 #include <map>
+#include <memory>
 #include <vector>
 
 #include "base/macros.h"
 #include "base/memory/linked_ptr.h"
-#include "base/memory/scoped_ptr.h"
 #include "base/threading/thread_checker.h"
 #include "content/browser/vr/vr_device.h"
 #include "content/browser/vr/vr_device_provider.h"
@@ -39,19 +39,19 @@ class VRDeviceManager : public VRService {
 
   VRDeviceManager();
   // Constructor for testing.
-  explicit VRDeviceManager(scoped_ptr<VRDeviceProvider> provider);
+  explicit VRDeviceManager(std::unique_ptr<VRDeviceProvider> provider);
 
   static void SetInstance(VRDeviceManager* service);
   static bool HasInstance();
 
   void InitializeProviders();
-  void RegisterProvider(scoped_ptr<VRDeviceProvider> provider);
+  void RegisterProvider(std::unique_ptr<VRDeviceProvider> provider);
 
-  // VRService implementation
+  // mojom::VRService implementation
   void GetDevices(const GetDevicesCallback& callback) override;
-  void GetSensorState(uint32_t index,
-                      const GetSensorStateCallback& callback) override;
-  void ResetSensor(uint32_t index) override;
+  void GetPose(uint32_t index,
+               const GetPoseCallback& callback) override;
+  void ResetPose(uint32_t index) override;
 
   // Mojo connection error handler.
   void OnConnectionError();
diff --git a/content/browser/vr/vr_device_manager_unittest.cc b/content/browser/vr/vr_device_manager_unittest.cc
index 001d440..93c2ada 100644
--- a/content/browser/vr/vr_device_manager_unittest.cc
+++ b/content/browser/vr/vr_device_manager_unittest.cc
@@ -2,12 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "content/browser/vr/vr_device_manager.h"
+
+#include <memory>
+#include <utility>
+
 #include "base/macros.h"
 #include "base/memory/linked_ptr.h"
-#include "base/memory/scoped_ptr.h"
 #include "content/browser/vr/test/fake_vr_device.h"
 #include "content/browser/vr/test/fake_vr_device_provider.h"
-#include "content/browser/vr/vr_device_manager.h"
 #include "content/browser/vr/vr_device_provider.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -24,7 +27,7 @@ class VRDeviceManagerTest : public testing::Test {
 
  protected:
   FakeVRDeviceProvider* provider_;
-  scoped_ptr<VRDeviceManager> device_manager_;
+  std::unique_ptr<VRDeviceManager> device_manager_;
 
   DISALLOW_COPY_AND_ASSIGN(VRDeviceManagerTest);
 };
@@ -36,9 +39,9 @@ VRDeviceManagerTest::~VRDeviceManagerTest() {
 }
 
 void VRDeviceManagerTest::SetUp() {
-  scoped_ptr<FakeVRDeviceProvider> provider(new FakeVRDeviceProvider());
+  std::unique_ptr<FakeVRDeviceProvider> provider(new FakeVRDeviceProvider());
   provider_ = provider.get();
-  device_manager_.reset(new VRDeviceManager(provider.Pass()));
+  device_manager_.reset(new VRDeviceManager(std::move(provider)));
 }
 
 TEST_F(VRDeviceManagerTest, InitializationTest) {
@@ -46,15 +49,15 @@ TEST_F(VRDeviceManagerTest, InitializationTest) {
 
   // Calling GetDevices should initialize the service if it hasn't been
   // initialized yet or the providesr have been released.
-  // The VRService should initialize each of it's providers upon it's own
+  // The mojom::VRService should initialize each of it's providers upon it's own
   // initialization.
-  mojo::Array<VRDeviceInfoPtr> webvr_devices;
+  mojo::Array<mojom::VRDeviceInfoPtr> webvr_devices;
   webvr_devices = device_manager_->GetVRDevices();
   EXPECT_TRUE(provider_->IsInitialized());
 }
 
 TEST_F(VRDeviceManagerTest, GetDevicesBasicTest) {
-  mojo::Array<VRDeviceInfoPtr> webvr_devices;
+  mojo::Array<mojom::VRDeviceInfoPtr> webvr_devices;
   webvr_devices = device_manager_->GetVRDevices();
   // Calling GetVRDevices should initialize the providers.
   EXPECT_TRUE(provider_->IsInitialized());
@@ -65,7 +68,7 @@ TEST_F(VRDeviceManagerTest, GetDevicesBasicTest) {
   VRDevice* queried_device = device_manager_->GetDevice(1);
   EXPECT_EQ(nullptr, queried_device);
 
-  scoped_ptr<FakeVRDevice> device1(new FakeVRDevice(provider_));
+  std::unique_ptr<FakeVRDevice> device1(new FakeVRDevice(provider_));
   provider_->AddDevice(device1.get());
   webvr_devices = device_manager_->GetVRDevices();
   // Should have successfully returned one device.
@@ -73,7 +76,7 @@ TEST_F(VRDeviceManagerTest, GetDevicesBasicTest) {
   // The WebVRDevice index should match the device id.
   EXPECT_EQ(webvr_devices[0]->index, device1->id());
 
-  scoped_ptr<FakeVRDevice> device2(new FakeVRDevice(provider_));
+  std::unique_ptr<FakeVRDevice> device2(new FakeVRDevice(provider_));
   provider_->AddDevice(device2.get());
   webvr_devices = device_manager_->GetVRDevices();
   // Should have successfully returned two devices.
diff --git a/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc b/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc
index f778339..fd66cf7 100644
--- a/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc
+++ b/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc
@@ -259,7 +259,7 @@ bool WebGraphicsContext3DCommandBufferImpl::CreateContext(bool onscreen) {
       gles2_helper_.get(), gles2_share_group.get(), transfer_buffer_.get(),
       bind_generates_resources, lose_context_when_out_of_memory_,
       support_client_side_arrays, command_buffer_.get()));
-  setGLInterface(real_gl_.get());
+  SetGLInterface(real_gl_.get());
 
   if (!real_gl_->Initialize(
       mem_limits_.start_transfer_buffer_size,
@@ -276,7 +276,7 @@ bool WebGraphicsContext3DCommandBufferImpl::CreateContext(bool onscreen) {
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableGpuClientTracing)) {
     trace_gl_.reset(new gpu::gles2::GLES2TraceImplementation(GetGLInterface()));
-    setGLInterface(trace_gl_.get());
+    SetGLInterface(trace_gl_.get());
   }
   return true;
 }
@@ -306,7 +306,7 @@ void WebGraphicsContext3DCommandBufferImpl::Destroy() {
     // issued on this context might not be visible to other contexts in the
     // share group.
     gl->Flush();
-    setGLInterface(NULL);
+    SetGLInterface(nullptr);
   }
 
   trace_gl_.reset();
@@ -316,7 +316,7 @@ void WebGraphicsContext3DCommandBufferImpl::Destroy() {
   real_gl_.reset();
   command_buffer_.reset();
 
-  host_ = NULL;
+  host_ = nullptr;
 }
 
 gpu::ContextSupport*
diff --git a/content/common/vr_service.mojom b/content/common/vr_service.mojom
index 2d81ec7..c1c83b7 100644
--- a/content/common/vr_service.mojom
+++ b/content/common/vr_service.mojom
@@ -4,26 +4,6 @@
 
 module content;
 
-struct VRVector3 {
-  float x;
-  float y;
-  float z;
-};
-
-struct VRVector4 {
-  float x;
-  float y;
-  float z;
-  float w;
-};
-
-struct VRRect {
-  int32 x;
-  int32 y;
-  int32 width;
-  int32 height;
-};
-
 // A field of view, given by 4 degrees describing the view from a center point.
 struct VRFieldOfView {
   float upDegrees;
@@ -32,42 +12,58 @@ struct VRFieldOfView {
   float rightDegrees;
 };
 
-// A sensor's position, orientation, velocity, and acceleration state at the
+// A device's position, orientation, velocity, and acceleration state at the
 // given timestamp.
-struct VRSensorState {
+struct VRPose {
   double timestamp;
-  uint32 frameIndex;
-  VRVector4? orientation;
-  VRVector3? position;
-  VRVector3? angularVelocity;
-  VRVector3? linearVelocity;
-  VRVector3? angularAcceleration;
-  VRVector3? linearAcceleration;
+  array<float, 4>? orientation;
+  array<float, 3>? position;
+  array<float, 3>? angularVelocity;
+  array<float, 3>? linearVelocity;
+  array<float, 3>? angularAcceleration;
+  array<float, 3>? linearAcceleration;
+};
+
+struct VRDeviceCapabilities {
+  bool hasOrientation;
+  bool hasPosition;
+  bool hasExternalDisplay;
+  bool canPresent;
 };
 
 // Information about the optical properties for an eye in an HMD.
 struct VREyeParameters {
-  VRFieldOfView minimumFieldOfView;
-  VRFieldOfView maximumFieldOfView;
-  VRFieldOfView recommendedFieldOfView;
-  VRVector3 eyeTranslation;
-  VRRect renderRect;
+  VRFieldOfView fieldOfView;
+  array<float, 3> offset;
+  uint32 renderWidth;
+  uint32 renderHeight;
 };
 
-// Information pertaining to Head Mounted Displays.
-struct VRHMDInfo {
-  VREyeParameters leftEye;
-  VREyeParameters rightEye;
+struct VRStageParameters {
+  array<float, 16> standingTransform;
+  float sizeX;
+  float sizeZ;
 };
 
 struct VRDeviceInfo {
+  enum CompositorType {
+    NONE,
+    CARDBOARD,
+    OCULUS,
+    OPENVR
+  };
+
    uint32 index;
    string deviceName;
-   VRHMDInfo? hmdInfo;
+   CompositorType deviceCompositorType;
+   VRDeviceCapabilities capabilities;
+   VRStageParameters? stageParameters;
+   VREyeParameters leftEye;
+   VREyeParameters rightEye;
 };
 
 interface VRService {
   GetDevices() => (array<VRDeviceInfo> devices);
-  GetSensorState(uint32 index) => (VRSensorState state);
-  ResetSensor(uint32 index);
-};
+  GetPose(uint32 index) => (VRPose pose);
+  ResetPose(uint32 index);
+};
\ No newline at end of file
diff --git a/content/content_browser.gypi b/content/content_browser.gypi
index 8e715f5..8d83487 100644
--- a/content/content_browser.gypi
+++ b/content/content_browser.gypi
@@ -1873,7 +1873,17 @@
     '<@(private_browser_sources)',
   ],
   'conditions': [
-    ['OS != "win"', {
+    ['OS == "win"', {
+      'dependencies': [
+        '../third_party/libovr/libovr.gyp:libovr',
+      ],
+      'sources': [
+        'browser/vr/oculus/oculus_vr_device.cc',
+        'browser/vr/oculus/oculus_vr_device.h',
+        'browser/vr/oculus/oculus_vr_device_provider.cc',
+        'browser/vr/oculus/oculus_vr_device_provider.h',
+      ]
+    }, { # os != "win"
       'sources': [
         'browser/file_descriptor_info_impl.cc',
         'browser/file_descriptor_info_impl.h',
@@ -2200,5 +2210,49 @@
         'browser/vr/android/cardboard/cardboard_vr_device_provider.h',
       ],
     }],
+    ['enable_webvr==1 and OS=="win"', {
+      'dependencies': [
+        '../third_party/libovr/libovr.gyp:libovr',
+      ],
+      'sources': [
+        'browser/vr/oculus/oculus_vr_device.cc',
+        'browser/vr/oculus/oculus_vr_device.h',
+        'browser/vr/oculus/oculus_vr_device_provider.cc',
+        'browser/vr/oculus/oculus_vr_device_provider.h',
+        'browser/vr/oculus/oculus_vr_gamepad_data_fetcher.cc',
+        'browser/vr/oculus/oculus_vr_gamepad_data_fetcher.h',
+      ]
+    }],
+    ['enable_webvr==1 and OS=="win"', {
+      'dependencies': [
+        '../third_party/openvr/openvr.gyp:openvr',
+      ],
+      'sources': [
+        'browser/vr/openvr/open_vr_device.cc',
+        'browser/vr/openvr/open_vr_device.h',
+        'browser/vr/openvr/open_vr_device_provider.cc',
+        'browser/vr/openvr/open_vr_device_provider.h',
+        'browser/vr/openvr/open_vr_gamepad_data_fetcher.cc',
+        'browser/vr/openvr/open_vr_gamepad_data_fetcher.h',
+      ],
+      'msvs_settings': {
+        'VCLinkerTool': {
+          'AdditionalDependencies': [
+            'openvr_api.lib',
+          ],
+          'AdditionalLibraryDirectories': [
+            '../third_party/openvr/openvr/lib/win32',
+          ],
+        },
+      },
+    }],
+    ['enable_webvr==1', {
+      'sources': [
+        'browser/vr/simulated/simulated_vr_device.cc',
+        'browser/vr/simulated/simulated_vr_device.h',
+        'browser/vr/simulated/simulated_vr_device_provider.cc',
+        'browser/vr/simulated/simulated_vr_device_provider.h',
+      ]
+    }],
   ],
 }
diff --git a/content/renderer/gpu/render_widget_compositor.cc b/content/renderer/gpu/render_widget_compositor.cc
index 2d97eca..3064005 100644
--- a/content/renderer/gpu/render_widget_compositor.cc
+++ b/content/renderer/gpu/render_widget_compositor.cc
@@ -234,7 +234,12 @@ void RenderWidgetCompositor::Initialize(float device_scale_factor) {
   // to keep content always crisp when possible.
   settings.layer_transforms_should_scale_layer_contents = true;
 
+#if !defined(OS_ANDROID)
+  if (cmd->HasSwitch(switches::kDisableGpuVsync) ||
+      cmd->HasSwitch("enable-webvr")) {
+#else 
   if (cmd->HasSwitch(switches::kDisableGpuVsync)) {
+#endif
     std::string display_vsync_string =
         cmd->GetSwitchValueASCII(switches::kDisableGpuVsync);
     if (display_vsync_string == "gpu") {
diff --git a/content/renderer/vr/vr_dispatcher.cc b/content/renderer/vr/vr_dispatcher.cc
index 0739176..8acedba 100644
--- a/content/renderer/vr/vr_dispatcher.cc
+++ b/content/renderer/vr/vr_dispatcher.cc
@@ -31,23 +31,24 @@ void VRDispatcher::getDevices(blink::WebVRGetDevicesCallback* callback) {
                                            base::Unretained(this), request_id));
 }
 
-void VRDispatcher::getSensorState(unsigned int index,
-                                  blink::WebHMDSensorState& state) {
-  GetVRServicePtr()->GetSensorState(
+void VRDispatcher::getPose(unsigned int index,
+                                  blink::WebVRPose& pose) {
+  GetVRServicePtr()->GetPose(
       index,
-      base::Bind(&VRDispatcher::OnGetSensorState, base::Unretained(&state)));
+      base::Bind(&VRDispatcher::OnGetPose, base::Unretained(&pose)));
 
   // This call needs to return results synchronously in order to be useful and
   // provide the lowest latency results possible.
   GetVRServicePtr().WaitForIncomingResponse();
 }
 
-void VRDispatcher::resetSensor(unsigned int index) {
-  GetVRServicePtr()->ResetSensor(index);
+void VRDispatcher::resetPose(unsigned int index) {
+  GetVRServicePtr()->ResetPose(index);
 }
 
-void VRDispatcher::OnGetDevices(int request_id,
-                                const mojo::Array<VRDeviceInfoPtr>& devices) {
+void VRDispatcher::OnGetDevices(
+    int request_id,
+    const mojo::Array<VRDeviceInfoPtr>& devices) {
   blink::WebVector<blink::WebVRDevice> web_devices(devices.size());
 
   blink::WebVRGetDevicesCallback* callback =
@@ -63,9 +64,9 @@ void VRDispatcher::OnGetDevices(int request_id,
   pending_requests_.Remove(request_id);
 }
 
-void VRDispatcher::OnGetSensorState(blink::WebHMDSensorState* state,
-                                    const VRSensorStatePtr& mojo_state) {
-  *state = mojo_state.To<blink::WebHMDSensorState>();
+void VRDispatcher::OnGetPose(blink::WebVRPose* pose,
+                             const VRPosePtr& mojo_pose) {
+  *pose = mojo_pose.To<blink::WebVRPose>();
 }
 
 }  // namespace content
diff --git a/content/renderer/vr/vr_dispatcher.h b/content/renderer/vr/vr_dispatcher.h
index b027d05..7372cf9 100644
--- a/content/renderer/vr/vr_dispatcher.h
+++ b/content/renderer/vr/vr_dispatcher.h
@@ -26,10 +26,10 @@ class VRDispatcher : NON_EXPORTED_BASE(public blink::WebVRClient) {
   // blink::WebVRClient implementation.
   void getDevices(blink::WebVRGetDevicesCallback* callback) override;
 
-  void getSensorState(unsigned int index,
-                      blink::WebHMDSensorState& state) override;
+  void getPose(unsigned int index,
+                      blink::WebVRPose& pose) override;
 
-  void resetSensor(unsigned int index) override;
+  void resetPose(unsigned int index) override;
 
  private:
   // Helper method that returns an initialized PermissionServicePtr.
@@ -38,8 +38,8 @@ class VRDispatcher : NON_EXPORTED_BASE(public blink::WebVRClient) {
   // Callback handlers
   void OnGetDevices(int request_id,
                     const mojo::Array<VRDeviceInfoPtr>& devices);
-  static void OnGetSensorState(blink::WebHMDSensorState* state,
-                               const VRSensorStatePtr& mojo_state);
+  static void OnGetPose(blink::WebVRPose* pose,
+                        const VRPosePtr& mojo_pose);
 
   // Tracks requests sent to browser to match replies with callbacks.
   // Owns callback objects.
diff --git a/content/renderer/vr/vr_type_converters.cc b/content/renderer/vr/vr_type_converters.cc
index ba220a4..2cb1f20 100644
--- a/content/renderer/vr/vr_type_converters.cc
+++ b/content/renderer/vr/vr_type_converters.cc
@@ -8,46 +8,41 @@
 
 #include <algorithm>
 
-using content::VRVector3Ptr;
-using content::VRVector4Ptr;
-using content::VRRectPtr;
 using content::VRFieldOfViewPtr;
 using content::VREyeParametersPtr;
-using content::VRHMDInfoPtr;
+using content::VRDeviceCapabilitiesPtr;
 using content::VRDeviceInfoPtr;
-using content::VRSensorStatePtr;
+using content::VRPosePtr;
+using content::VRStageParametersPtr;
 
 namespace mojo {
 
 // static
-blink::WebVRVector3 TypeConverter<blink::WebVRVector3, VRVector3Ptr>::Convert(
-    const VRVector3Ptr& input) {
+blink::WebVRVector3 TypeConverter<blink::WebVRVector3,
+                                  mojo::Array<float>>::Convert(
+    const mojo::Array<float>& input) {
   blink::WebVRVector3 output;
-  output.x = input->x;
-  output.y = input->y;
-  output.z = input->z;
+  output.isNull = input.is_null();
+  if (!output.isNull) {
+    output.x = input[0];
+    output.y = input[1];
+    output.z = input[2];
+  }
   return output;
 }
 
 // static
-blink::WebVRVector4 TypeConverter<blink::WebVRVector4, VRVector4Ptr>::Convert(
-    const VRVector4Ptr& input) {
+blink::WebVRVector4 TypeConverter<blink::WebVRVector4,
+                                  mojo::Array<float>>::Convert(
+    const mojo::Array<float>& input) {
   blink::WebVRVector4 output;
-  output.x = input->x;
-  output.y = input->y;
-  output.z = input->z;
-  output.w = input->w;
-  return output;
-}
-
-// static
-blink::WebVRRect TypeConverter<blink::WebVRRect, VRRectPtr>::Convert(
-    const VRRectPtr& input) {
-  blink::WebVRRect output;
-  output.x = input->x;
-  output.y = input->y;
-  output.width = input->width;
-  output.height = input->height;
+  output.isNull = input.is_null();
+  if (!output.isNull) {
+    output.x = input[0];
+    output.y = input[1];
+    output.z = input[2];
+    output.w = input[3];
+  }
   return output;
 }
 
@@ -68,23 +63,24 @@ blink::WebVREyeParameters
 TypeConverter<blink::WebVREyeParameters, VREyeParametersPtr>::Convert(
     const VREyeParametersPtr& input) {
   blink::WebVREyeParameters output;
-  output.minimumFieldOfView =
-      input->minimumFieldOfView.To<blink::WebVRFieldOfView>();
-  output.maximumFieldOfView =
-      input->maximumFieldOfView.To<blink::WebVRFieldOfView>();
-  output.recommendedFieldOfView =
-      input->recommendedFieldOfView.To<blink::WebVRFieldOfView>();
-  output.eyeTranslation = input->eyeTranslation.To<blink::WebVRVector3>();
-  output.renderRect = input->renderRect.To<blink::WebVRRect>();
+  output.fieldOfView = input->fieldOfView.To<blink::WebVRFieldOfView>();
+  output.offset = input->offset.To<blink::WebVRVector3>();
+  output.renderWidth = input->renderWidth;
+  output.renderHeight = input->renderHeight;
   return output;
 }
 
 // static
-blink::WebVRHMDInfo TypeConverter<blink::WebVRHMDInfo, VRHMDInfoPtr>::Convert(
-    const VRHMDInfoPtr& input) {
-  blink::WebVRHMDInfo output;
-  output.leftEye = input->leftEye.To<blink::WebVREyeParameters>();
-  output.rightEye = input->rightEye.To<blink::WebVREyeParameters>();
+blink::WebVRDisplayCapabilities
+TypeConverter<blink::WebVRDisplayCapabilities, VRDeviceCapabilitiesPtr>::Convert(
+    const VRDeviceCapabilitiesPtr& input) {
+  blink::WebVRDisplayCapabilities output;
+
+  output.hasOrientation = input->hasOrientation;
+  output.hasPosition = input->hasPosition;
+  output.hasExternalDisplay = input->hasExternalDisplay;
+  output.canPresent = input->canPresent;
+
   return output;
 }
 
@@ -95,54 +91,69 @@ blink::WebVRDevice TypeConverter<blink::WebVRDevice, VRDeviceInfoPtr>::Convert(
   memset(&output, 0, sizeof(blink::WebVRDevice));
 
   output.index = input->index;
-  output.flags = blink::WebVRDeviceTypePosition;
   output.deviceName = blink::WebString::fromUTF8(input->deviceName.data(),
                                                  input->deviceName.size());
 
-  if (!input->hmdInfo.is_null()) {
-    output.flags |= blink::WebVRDeviceTypeHMD;
-    output.hmdInfo = input->hmdInfo.To<blink::WebVRHMDInfo>();
-  }
+  output.deviceCompositorType =
+    static_cast<blink::WebVRCompositorType>(input->deviceCompositorType);
+
+  output.capabilities =
+      input->capabilities.To<blink::WebVRDisplayCapabilities>();
+
+  output.stageParameters =
+      input->stageParameters.To<blink::WebVRStageParameters>();
+
+  output.leftEye = input->leftEye.To<blink::WebVREyeParameters>();
+  output.rightEye = input->rightEye.To<blink::WebVREyeParameters>();
 
   return output;
 }
 
 // static
-blink::WebHMDSensorState
-TypeConverter<blink::WebHMDSensorState, VRSensorStatePtr>::Convert(
-    const VRSensorStatePtr& input) {
-  blink::WebHMDSensorState output;
+blink::WebVRPose
+TypeConverter<blink::WebVRPose, VRPosePtr>::Convert(
+    const VRPosePtr& input) {
+  blink::WebVRPose output;
   output.timestamp = input->timestamp;
-  output.frameIndex = input->frameIndex;
-  output.flags = 0;
+  output.orientation = input->orientation.To<blink::WebVRVector4>();
+  output.position = input->position.To<blink::WebVRVector3>();
+  output.angularVelocity = input->angularVelocity.To<blink::WebVRVector3>();
+  output.linearVelocity = input->linearVelocity.To<blink::WebVRVector3>();
+  output.angularAcceleration =
+      input->angularAcceleration.To<blink::WebVRVector3>();
+  output.linearAcceleration =
+      input->linearAcceleration.To<blink::WebVRVector3>();
 
-  if (!input->orientation.is_null()) {
-    output.flags |= blink::WebVRSensorStateOrientation;
-    output.orientation = input->orientation.To<blink::WebVRVector4>();
-  }
-  if (!input->position.is_null()) {
-    output.flags |= blink::WebVRSensorStatePosition;
-    output.position = input->position.To<blink::WebVRVector3>();
-  }
-  if (!input->angularVelocity.is_null()) {
-    output.flags |= blink::WebVRSensorStateAngularVelocity;
-    output.angularVelocity = input->angularVelocity.To<blink::WebVRVector3>();
-  }
-  if (!input->linearVelocity.is_null()) {
-    output.flags |= blink::WebVRSensorStateLinearVelocity;
-    output.linearVelocity = input->linearVelocity.To<blink::WebVRVector3>();
-  }
-  if (!input->angularAcceleration.is_null()) {
-    output.flags |= blink::WebVRSensorStateAngularAcceleration;
-    output.angularAcceleration =
-        input->angularAcceleration.To<blink::WebVRVector3>();
-  }
-  if (!input->linearAcceleration.is_null()) {
-    output.flags |= blink::WebVRSensorStateLinearAcceleration;
-    output.linearAcceleration =
-        input->linearAcceleration.To<blink::WebVRVector3>();
-  }
+  return output;
+}
 
+// static
+blink::WebVRStageParameters
+TypeConverter<blink::WebVRStageParameters, VRStageParametersPtr>::Convert(
+    const VRStageParametersPtr& input) {
+  blink::WebVRStageParameters output;
+  output.isNull = input.is_null();
+  if (!output.isNull) {
+    output.standingTransform[0] = input->standingTransform[0];
+    output.standingTransform[1] = input->standingTransform[1];
+    output.standingTransform[2] = input->standingTransform[2];
+    output.standingTransform[3] = input->standingTransform[3];
+    output.standingTransform[4] = input->standingTransform[4];
+    output.standingTransform[5] = input->standingTransform[5];
+    output.standingTransform[6] = input->standingTransform[6];
+    output.standingTransform[7] = input->standingTransform[7];
+    output.standingTransform[8] = input->standingTransform[8];
+    output.standingTransform[9] = input->standingTransform[9];
+    output.standingTransform[10] = input->standingTransform[10];
+    output.standingTransform[11] = input->standingTransform[11];
+    output.standingTransform[12] = input->standingTransform[12];
+    output.standingTransform[13] = input->standingTransform[13];
+    output.standingTransform[14] = input->standingTransform[14];
+    output.standingTransform[15] = input->standingTransform[15];
+
+    output.sizeX = input->sizeX;
+    output.sizeZ = input->sizeZ;
+  }
   return output;
 }
 
diff --git a/content/renderer/vr/vr_type_converters.h b/content/renderer/vr/vr_type_converters.h
index 8902cd5..96916f6 100644
--- a/content/renderer/vr/vr_type_converters.h
+++ b/content/renderer/vr/vr_type_converters.h
@@ -15,46 +15,53 @@ namespace mojo {
 // and vice versa.
 
 template <>
-struct TypeConverter<blink::WebVRVector3, content::VRVector3Ptr> {
-  static blink::WebVRVector3 Convert(const content::VRVector3Ptr& input);
+struct TypeConverter<blink::WebVRVector3, mojo::Array<float>> {
+  static blink::WebVRVector3 Convert(const mojo::Array<float>& input);
 };
 
 template <>
-struct TypeConverter<blink::WebVRVector4, content::VRVector4Ptr> {
-  static blink::WebVRVector4 Convert(const content::VRVector4Ptr& input);
+struct TypeConverter<blink::WebVRVector4, mojo::Array<float>> {
+  static blink::WebVRVector4 Convert(const mojo::Array<float>& input);
 };
 
 template <>
-struct TypeConverter<blink::WebVRRect, content::VRRectPtr> {
-  static blink::WebVRRect Convert(const content::VRRectPtr& input);
-};
-
-template <>
-struct TypeConverter<blink::WebVRFieldOfView, content::VRFieldOfViewPtr> {
+struct TypeConverter<blink::WebVRFieldOfView,
+                     content::VRFieldOfViewPtr> {
   static blink::WebVRFieldOfView Convert(
       const content::VRFieldOfViewPtr& input);
 };
 
 template <>
-struct TypeConverter<blink::WebVREyeParameters, content::VREyeParametersPtr> {
+struct TypeConverter<blink::WebVREyeParameters,
+                     content::VREyeParametersPtr> {
   static blink::WebVREyeParameters Convert(
       const content::VREyeParametersPtr& input);
 };
 
 template <>
-struct TypeConverter<blink::WebVRHMDInfo, content::VRHMDInfoPtr> {
-  static blink::WebVRHMDInfo Convert(const content::VRHMDInfoPtr& input);
+struct TypeConverter<blink::WebVRDisplayCapabilities,
+                     content::VRDeviceCapabilitiesPtr> {
+  static blink::WebVRDisplayCapabilities Convert(
+      const content::VRDeviceCapabilitiesPtr& input);
 };
 
 template <>
 struct TypeConverter<blink::WebVRDevice, content::VRDeviceInfoPtr> {
-  static blink::WebVRDevice Convert(const content::VRDeviceInfoPtr& input);
+  static blink::WebVRDevice Convert(
+      const content::VRDeviceInfoPtr& input);
+};
+
+template <>
+struct TypeConverter<blink::WebVRPose, content::VRPosePtr> {
+  static blink::WebVRPose Convert(
+      const content::VRPosePtr& input);
 };
 
 template <>
-struct TypeConverter<blink::WebHMDSensorState, content::VRSensorStatePtr> {
-  static blink::WebHMDSensorState Convert(
-      const content::VRSensorStatePtr& input);
+struct TypeConverter<blink::WebVRStageParameters,
+                     content::VRStageParametersPtr> {
+  static blink::WebVRStageParameters Convert(
+      const content::VRStageParametersPtr& input);
 };
 
 }  // namespace mojo
diff --git a/content/renderer/webgraphicscontext3d_provider_impl.cc b/content/renderer/webgraphicscontext3d_provider_impl.cc
index 855bd3d..1fcdb63 100644
--- a/content/renderer/webgraphicscontext3d_provider_impl.cc
+++ b/content/renderer/webgraphicscontext3d_provider_impl.cc
@@ -16,9 +16,15 @@ WebGraphicsContext3DProviderImpl::WebGraphicsContext3DProviderImpl(
 WebGraphicsContext3DProviderImpl::~WebGraphicsContext3DProviderImpl() {}
 
 blink::WebGraphicsContext3D* WebGraphicsContext3DProviderImpl::context3d() {
+  DCHECK_EQ(!!provider_->WebContext3D(), !!provider_->ContextGL());
   return provider_->WebContext3D();
 }
 
+gpu::gles2::GLES2Interface* WebGraphicsContext3DProviderImpl::contextGL() {
+  DCHECK_EQ(!!provider_->WebContext3D(), !!provider_->ContextGL());
+  return provider_->ContextGL();
+}
+
 GrContext* WebGraphicsContext3DProviderImpl::grContext() {
   return provider_->GrContext();
 }
diff --git a/content/renderer/webgraphicscontext3d_provider_impl.h b/content/renderer/webgraphicscontext3d_provider_impl.h
index 769dd56..de155bd 100644
--- a/content/renderer/webgraphicscontext3d_provider_impl.h
+++ b/content/renderer/webgraphicscontext3d_provider_impl.h
@@ -14,6 +14,12 @@ namespace cc_blink {
 class ContextProviderWebContext;
 }
 
+namespace gpu {
+namespace gles2 {
+class GLES2Interface;
+}
+}
+
 namespace content {
 
 class CONTENT_EXPORT WebGraphicsContext3DProviderImpl
@@ -25,6 +31,7 @@ class CONTENT_EXPORT WebGraphicsContext3DProviderImpl
 
   // WebGraphicsContext3DProvider implementation.
   blink::WebGraphicsContext3D* context3d() override;
+  gpu::gles2::GLES2Interface* contextGL() override;
   GrContext* grContext() override;
 
  private:
diff --git a/gpu/blink/webgraphicscontext3d_impl.cc b/gpu/blink/webgraphicscontext3d_impl.cc
index 64a9f96..d260e94 100644
--- a/gpu/blink/webgraphicscontext3d_impl.cc
+++ b/gpu/blink/webgraphicscontext3d_impl.cc
@@ -1216,14 +1216,14 @@ void WebGraphicsContext3DImpl::waitSync(WGC3Dsync sync,
   gl_->WaitSync(reinterpret_cast<GLsync>(sync), flags, timeout);
 }
 
-bool WebGraphicsContext3DImpl::isContextLost() {
-  return getGraphicsResetStatusARB() != GL_NO_ERROR;
-}
-
 blink::WGC3Denum WebGraphicsContext3DImpl::getGraphicsResetStatusARB() {
   return gl_->GetGraphicsResetStatusKHR();
 }
 
+::gpu::gles2::GLES2Interface* WebGraphicsContext3DImpl::getGLES2Interface() {
+  return gl_;
+}
+
 ::gpu::gles2::GLES2ImplementationErrorMessageCallback*
     WebGraphicsContext3DImpl::getErrorMessageCallback() {
   if (!client_error_message_callback_) {
diff --git a/gpu/blink/webgraphicscontext3d_impl.h b/gpu/blink/webgraphicscontext3d_impl.h
index 91881ba..d0ca894 100644
--- a/gpu/blink/webgraphicscontext3d_impl.h
+++ b/gpu/blink/webgraphicscontext3d_impl.h
@@ -937,8 +937,10 @@ class GPU_BLINK_EXPORT WebGraphicsContext3DImpl
                 blink::WGC3Dbitfield flags,
                 blink::WGC3Duint64 timeout) override;
 
-  bool isContextLost() override;
   blink::WGC3Denum getGraphicsResetStatusARB() override;
+  
+  // WebGraphicsContext3D implementation.
+  ::gpu::gles2::GLES2Interface* getGLES2Interface() override;
 
   ::gpu::gles2::GLES2Interface* GetGLInterface() {
     return gl_;
@@ -959,9 +961,7 @@ class GPU_BLINK_EXPORT WebGraphicsContext3DImpl
       getErrorMessageCallback();
   virtual void OnErrorMessage(const std::string& message, int id);
 
-  void setGLInterface(::gpu::gles2::GLES2Interface* gl) {
-    gl_ = gl;
-  }
+  void SetGLInterface(::gpu::gles2::GLES2Interface* gl) { gl_ = gl; }
 
   bool initialized_;
   bool initialize_failed_;
diff --git a/gpu/blink/webgraphicscontext3d_in_process_command_buffer_impl.cc b/gpu/blink/webgraphicscontext3d_in_process_command_buffer_impl.cc
index cc18157..5daf178 100644
--- a/gpu/blink/webgraphicscontext3d_in_process_command_buffer_impl.cc
+++ b/gpu/blink/webgraphicscontext3d_in_process_command_buffer_impl.cc
@@ -136,7 +136,7 @@ bool WebGraphicsContext3DInProcessCommandBufferImpl::MaybeInitializeGL() {
   }
 
   real_gl_ = context_->GetImplementation();
-  setGLInterface(real_gl_);
+  SetGLInterface(real_gl_);
 
   real_gl_->TraceBeginCHROMIUM("WebGraphicsContext3D",
                                "InProcessContext");
@@ -149,7 +149,9 @@ bool
 WebGraphicsContext3DInProcessCommandBufferImpl::InitializeOnCurrentThread() {
   if (!MaybeInitializeGL())
     return false;
-  return context_ && !isContextLost();
+  return context_ &&
+         context_->GetImplementation()->GetGraphicsResetStatusKHR() ==
+             GL_NO_ERROR;
 }
 
 void WebGraphicsContext3DInProcessCommandBufferImpl::SetLock(base::Lock* lock) {
diff --git a/gpu/command_buffer/build_gles2_cmd_buffer.py b/gpu/command_buffer/build_gles2_cmd_buffer.py
index 81d796a..087f283 100755
--- a/gpu/command_buffer/build_gles2_cmd_buffer.py
+++ b/gpu/command_buffer/build_gles2_cmd_buffer.py
@@ -4605,6 +4605,41 @@ _FUNCTION_INFO = {
     'extension': 'CHROMIUM_path_rendering',
     'extension_flag': 'chromium_path_rendering',
   },
+  'CreateVRCompositorCHROMIUM': {
+    'decoder_func': 'DoCreateVRCompositorCHROMIUM',
+    'unit_test': False,
+    'client_test': False,
+    'chromium': True,
+    'extension': True,
+  },
+  'SubmitVRCompositorFrameCHROMIUM': {
+    'decoder_func': 'DoSubmitVRCompositorFrameCHROMIUM',
+    'unit_test': False,
+    'client_test': False,
+    'chromium': True,
+    'extension': True,
+  },
+  'VRCompositorTextureBoundsCHROMIUM': {
+    'decoder_func': 'DoVRCompositorTextureBoundsCHROMIUM',
+    'unit_test': False,
+    'client_test': False,
+    'chromium': True,
+    'extension': True,
+  },
+  'ResetVRCompositorPoseCHROMIUM': {
+    'decoder_func': 'DoResetVRCompositorPoseCHROMIUM',
+    'unit_test': False,
+    'client_test': False,
+    'chromium': True,
+    'extension': True,
+  },
+  'DeleteVRCompositorCHROMIUM': {
+    'decoder_func': 'DoDeleteVRCompositorCHROMIUM',
+    'unit_test': False,
+    'client_test': False,
+    'chromium': True,
+    'extension': True,
+  },
 }
 
 
diff --git a/gpu/command_buffer/client/gles2_implementation.cc b/gpu/command_buffer/client/gles2_implementation.cc
index aeaa565..d7c8d93 100644
--- a/gpu/command_buffer/client/gles2_implementation.cc
+++ b/gpu/command_buffer/client/gles2_implementation.cc
@@ -6574,6 +6574,14 @@ void GLES2Implementation::InvalidateCachedExtensions() {
   cached_extensions_.clear();
 }
 
+GLuint GLES2Implementation::CreateVRCompositorCHROMIUM(GLenum compositorType) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glCreateVRCompositorCHROMIUM()");
+  helper_->CreateVRCompositorCHROMIUM(compositorType);
+  CheckGLError();
+  return 1;
+}
+
 // Include the auto-generated part of this file. We split this because it means
 // we can easily edit the non-auto generated parts right here in this file
 // instead of having to edit some template or the code generator.
diff --git a/gpu/command_buffer/cmd_buffer_functions.txt b/gpu/command_buffer/cmd_buffer_functions.txt
index 119f3f2..43d4f5a 100644
--- a/gpu/command_buffer/cmd_buffer_functions.txt
+++ b/gpu/command_buffer/cmd_buffer_functions.txt
@@ -362,3 +362,10 @@ GL_APICALL GLint        GL_APIENTRY glGetFragDataIndexEXT (GLidProgram program,
 
 // Extension CHROMIUM_stream_texture_matrix
 GL_APICALL void         GL_APIENTRY glUniformMatrix4fvStreamTextureMatrixCHROMIUM (GLintUniformLocation location, GLbooleanFalseOnly transpose, const GLfloat* default_value);
+
+// Extension CHROMIUM_vr_compositor.
+GL_APICALL GLuint       GL_APIENTRY glCreateVRCompositorCHROMIUM (GLenum compositorType);
+GL_APICALL void         GL_APIENTRY glSubmitVRCompositorFrameCHROMIUM (GLuint compositor, GLuint frameTexture, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+GL_APICALL void         GL_APIENTRY glVRCompositorTextureBoundsCHROMIUM (GLuint compositor, GLuint eye, GLfloat x, GLfloat y, GLfloat width, GLfloat height);
+GL_APICALL void         GL_APIENTRY glResetVRCompositorPoseCHROMIUM (GLuint compositor );
+GL_APICALL void         GL_APIENTRY glDeleteVRCompositorCHROMIUM (GLuint compositor);
diff --git a/gpu/command_buffer/service/gles2_cmd_decoder.cc b/gpu/command_buffer/service/gles2_cmd_decoder.cc
index faba24b..0b59abd 100644
--- a/gpu/command_buffer/service/gles2_cmd_decoder.cc
+++ b/gpu/command_buffer/service/gles2_cmd_decoder.cc
@@ -81,6 +81,10 @@
 #include <OpenGL/CGLIOSurface.h>
 #endif
 
+#include "gpu/command_buffer/service/vr/vr_compositor.h"
+#include "gpu/command_buffer/service/vr/oculus/oculus_vr_compositor.h"
+#include "gpu/command_buffer/service/vr/openvr/open_vr_compositor.h"
+
 namespace gpu {
 namespace gles2 {
 
@@ -705,6 +709,7 @@ class GLES2DecoderImpl : public GLES2Decoder, public ErrorStateClient {
   friend class ScopedFrameBufferBinder;
   friend class ScopedResolvedFrameBufferBinder;
   friend class BackFramebuffer;
+  friend class VRSwapCallback;
 
   // Initialize or re-initialize the shader translator.
   bool InitializeShaderTranslator();
@@ -1022,6 +1027,18 @@ class GLES2DecoderImpl : public GLES2Decoder, public ErrorStateClient {
 
   void DoMatrixLoadfCHROMIUM(GLenum matrix_mode, const GLfloat* matrix);
   void DoMatrixLoadIdentityCHROMIUM(GLenum matrix_mode);
+  
+  // VR Compositor
+  VRCompositor* vr_compositor_ = nullptr;
+  bool vr_needs_flush_ = false;
+  GLuint DoCreateVRCompositorCHROMIUM(GLenum compositorType);
+  void DoSubmitVRCompositorFrameCHROMIUM(GLuint compositor, GLuint texture,
+      GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+  void DoVRCompositorTextureBoundsCHROMIUM(GLuint compositor, GLuint eye,
+      GLfloat x, GLfloat y, GLfloat width, GLfloat height);
+  void DoResetVRCompositorPoseCHROMIUM(GLuint compositor);
+  void DoDeleteVRCompositorCHROMIUM(GLuint compositor);
+  void FlushVRFrame();
 
   // Creates a Program for the given program.
   Program* CreateProgram(GLuint client_id, GLuint service_id) {
@@ -2111,10 +2128,62 @@ class GLES2DecoderImpl : public GLES2Decoder, public ErrorStateClient {
   GLfloat line_width_range_[2];
 
   SamplerState default_sampler_state_;
+  
+  GLint swap_interval_ = 1;
 
   DISALLOW_COPY_AND_ASSIGN(GLES2DecoderImpl);
 };
 
+//----------
+// VR stuff
+//----------
+
+class VRSwapCallback {
+public:
+    VRSwapCallback(GLES2DecoderImpl* decoder) :
+        decoder_(decoder)
+    {};
+    ~VRSwapCallback() {};
+
+    GLES2DecoderImpl* decoder() { return decoder_; }
+
+    void onSwap() {
+      decoder_->MakeCurrent();
+      decoder_->FlushVRFrame();
+    }
+
+private:
+  GLES2DecoderImpl* decoder_;
+};
+
+static std::vector<VRSwapCallback*> vr_swap_callbacks;
+void AddVRSwapListener(GLES2DecoderImpl* decoder) {
+  for (size_t i = 0; i < vr_swap_callbacks.size(); ++i) {
+    if (vr_swap_callbacks[i]->decoder() == decoder)
+      return;
+  }
+
+  vr_swap_callbacks.push_back(new VRSwapCallback(decoder));
+}
+
+void OnVRSwap(GLES2DecoderImpl* decoder) {
+  if (!vr_swap_callbacks.size())
+    return;
+
+  VRSwapCallback* callback;
+  while (vr_swap_callbacks.size()) {
+    callback = vr_swap_callbacks.back();
+    callback->onSwap();
+    vr_swap_callbacks.pop_back();
+    delete callback;
+  }
+  decoder->MakeCurrent();
+}
+
+//-----------
+// /VR stuff
+//-----------
+
 const GLES2DecoderImpl::CommandInfo GLES2DecoderImpl::command_info[] = {
 #define GLES2_CMD_OP(name)                                   \
   {                                                          \
@@ -4003,6 +4072,11 @@ void GLES2DecoderImpl::Destroy(bool have_context) {
     return;
 
   DCHECK(!have_context || context_->IsCurrent(NULL));
+  
+  if (vr_compositor_) {
+    delete vr_compositor_;
+    vr_compositor_ = nullptr;
+  }
 
   // Unbind everything.
   state_.vertex_attrib_manager = NULL;
@@ -12294,6 +12368,12 @@ error::Error GLES2DecoderImpl::HandleShaderBinary(uint32_t immediate_data_size,
 
 void GLES2DecoderImpl::DoSwapBuffers() {
   bool is_offscreen = !!offscreen_target_frame_buffer_.get();
+  
+  bool reset_swap = false;
+  if (vr_swap_callbacks.size() && swap_interval_ != 0) {
+    reset_swap = true;
+    context_->SetSwapInterval(0);
+  }
 
   int this_frame_number = frame_number_++;
   // TRACE_EVENT for gpu tests:
@@ -12409,6 +12489,13 @@ void GLES2DecoderImpl::DoSwapBuffers() {
   } else {
     FinishSwapBuffers(surface_->SwapBuffers());
   }
+  
+  OnVRSwap(this);
+  //FlushVRFrame();
+
+  if (reset_swap) {
+    context_->SetSwapInterval(swap_interval_);
+  }
 
   // This may be a slow command.  Exit command processing to allow for
   // context preemption and GPU watchdog checks.
@@ -12446,7 +12533,10 @@ void GLES2DecoderImpl::DoCommitOverlayPlanes() {
 }
 
 void GLES2DecoderImpl::DoSwapInterval(int interval) {
-  context_->SetSwapInterval(interval);
+  if (swap_interval_ != interval) {
+    swap_interval_ = interval;
+    context_->SetSwapInterval(interval);
+  }
 }
 
 error::Error GLES2DecoderImpl::HandleEnableFeatureCHROMIUM(
@@ -14639,6 +14729,91 @@ void GLES2DecoderImpl::DoMatrixLoadIdentityCHROMIUM(GLenum matrix_mode) {
   glMatrixLoadIdentityEXT(matrix_mode);
 }
 
+GLuint GLES2DecoderImpl::DoCreateVRCompositorCHROMIUM(GLenum compositorType) {
+  // ANGLE not supported yet. :(
+  if (feature_info_->gl_version_info().is_angle)
+    return 0;
+
+  if (!vr_compositor_) {
+    if (compositorType == 2) { // Oculus
+      vr_compositor_ = new OculusVRCompositor();
+      RestoreBufferBindings();
+    } else if (compositorType == 3) { // OpenVR
+      vr_compositor_ = new OpenVRCompositor();
+    }
+    vr_needs_flush_ = false;
+  }
+
+  return 1;
+}
+
+void GLES2DecoderImpl::DoSubmitVRCompositorFrameCHROMIUM(
+    GLuint compositor, GLuint client_texture_id,
+    GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
+  TRACE_EVENT0("gpu", "GLES2DecoderImpl::DoSubmitVRCompositorFrameCHROMIUM");
+  // ANGLE not supported yet. :(
+  if (feature_info_->gl_version_info().is_angle)
+    return;
+
+  TextureRef* texture_ref = GetTexture(client_texture_id);
+  if (vr_compositor_ && texture_ref) {
+    if (vr_compositor_->needsStateRestore()) {
+      ClearAllAttributes();
+    }
+
+    vr_compositor_->SubmitFrame(texture_ref->service_id(), x, y, z, w);
+
+    if (vr_compositor_->needsStateRestore()) {
+      RestoreAllAttributes();
+      RestoreTextureUnitBindings(0);
+      RestoreActiveTexture();
+      RestoreProgramBindings();
+      RestoreBufferBindings();
+      RestoreFramebufferBindings();
+      RestoreGlobalState();
+    }
+
+    // TODO: This needs to be a lot more thread safe
+    AddVRSwapListener(this);
+    vr_needs_flush_ = true;
+  }
+}
+
+void GLES2DecoderImpl::FlushVRFrame() {
+  if (!vr_compositor_ || !vr_needs_flush_)
+    return;
+
+  vr_compositor_->OnSwapFrame();
+
+  vr_needs_flush_ = false;
+}
+
+void GLES2DecoderImpl::DoVRCompositorTextureBoundsCHROMIUM(GLuint compositor,
+    GLuint eye, GLfloat x, GLfloat y, GLfloat width, GLfloat height) {
+   if (!vr_compositor_)
+    return;
+
+  vr_compositor_->TextureBounds(eye, x, y, width, height);
+}
+
+void GLES2DecoderImpl::DoResetVRCompositorPoseCHROMIUM(GLuint compositor) {
+  if (!vr_compositor_)
+    return;
+
+  vr_compositor_->ResetPose();
+}
+
+void GLES2DecoderImpl::DoDeleteVRCompositorCHROMIUM(GLuint compositor) {
+  LOG(INFO) << "DoDeleteVRCompositorCHROMIUM";
+
+  vr_needs_flush_ = false;
+
+  if (!vr_compositor_) {
+    delete vr_compositor_;
+    vr_compositor_ = nullptr;
+  }
+}
+
 error::Error GLES2DecoderImpl::HandleUniformBlockBinding(
     uint32_t immediate_data_size, const void* cmd_data) {
   if (!unsafe_es3_apis_enabled())
diff --git a/gpu/command_buffer/service/vr/oculus/oculus_vr_compositor.cc b/gpu/command_buffer/service/vr/oculus/oculus_vr_compositor.cc
new file mode 100644
index 0000000..27b246a
--- /dev/null
+++ b/gpu/command_buffer/service/vr/oculus/oculus_vr_compositor.cc
@@ -0,0 +1,277 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gpu/command_buffer/service/vr/oculus/oculus_vr_compositor.h"
+
+#include "base/logging.h"
+#include "third_party/libovr/LibOVR/Include/OVR_CAPI_GL.h"
+#include "ui/gl/gl_bindings.h"
+
+#define SHADER(src)                     \
+  "#ifdef GL_ES\n"                      \
+  "precision mediump float;\n"          \
+  "#define TexCoordPrecision mediump\n" \
+  "#else\n"                             \
+  "#define TexCoordPrecision\n"         \
+  "#endif\n" #src
+
+namespace gpu {
+
+#define OCULUS_INIT_DEBUG 1
+
+const char* vertex_shader_source = SHADER(
+  attribute vec2 a_position;
+  varying TexCoordPrecision vec2 v_uv;
+  void main(void) {
+    gl_Position = vec4(a_position, 0.0, 1.0);
+    v_uv = a_position * vec2(0.5, 0.5) + vec2(0.5, 0.5);
+  });
+
+const char* fragment_shader_source = SHADER(
+  uniform sampler2D u_sampler;
+  varying TexCoordPrecision vec2 v_uv;
+  void main(void) {
+    gl_FragColor = texture2D(u_sampler, v_uv);
+  });
+
+void CompileShader(GLuint shader, const char* shader_source) {
+  glShaderSource(shader, 1, &shader_source, 0);
+  glCompileShader(shader);
+
+  GLint compile_status;
+  glGetShaderiv(shader, GL_COMPILE_STATUS, &compile_status);
+  if (GL_TRUE != compile_status)
+    LOG(ERROR) << "OculusVRCompositor CompileShader: shader compilation failure.";
+}
+
+OculusVRCompositor::OculusVRCompositor()
+    : VRCompositor()
+    , initialized_(false)
+    , session_(nullptr)
+    , fail_count_(0) {
+  Initialize();
+}
+
+OculusVRCompositor::~OculusVRCompositor() {
+  LOG(ERROR) << "Destroying OculusVRCompositor";
+  if (initialized_) {
+    glDeleteFramebuffersEXT(1, &framebuffer_);
+    framebuffer_ = 0;
+
+    ovr_DestroyTextureSwapChain(session_, swap_chain_);
+    ovr_Destroy(session_);
+  }
+}
+
+void OculusVRCompositor::SubmitFrame(GLuint frame_texture,
+    GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
+  if (!initialized_ || fail_count_ >= 3)
+    return;
+
+  // Increment to use next texture, just before writing
+  int curIndex;
+  GLuint chainTexId;
+  ovr_GetTextureSwapChainCurrentIndex(session_, swap_chain_, &curIndex);
+  ovr_GetTextureSwapChainBufferGL(session_, swap_chain_, curIndex, &chainTexId);
+
+  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffer_);
+  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0,
+      GL_TEXTURE_2D, chainTexId, 0);
+
+  glViewport(0, 0, width_, height_);
+
+  glClearColor(0.0f, 0.0f, 1.0f, 1.0f);
+  glClear(GL_COLOR_BUFFER_BIT);
+
+  glUseProgram(program_);
+
+  glEnableVertexAttribArray(0);
+  glBindBuffer(GL_ARRAY_BUFFER, buffer_);
+  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 8, 0);
+
+  glActiveTexture(GL_TEXTURE0);
+  glBindTexture(GL_TEXTURE_2D, frame_texture);
+  glUniform1i(sampler_location_, 0);
+
+  glDisable(GL_DEPTH_TEST);
+  glDisable(GL_STENCIL_TEST);
+  glDisable(GL_CULL_FACE);
+  glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+  glDepthMask(GL_FALSE);
+  glDisable(GL_BLEND);
+  glDisable(GL_SCISSOR_TEST);
+
+  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
+  glBindTexture(GL_TEXTURE_2D, 0);
+  glFramebufferTexture2DEXT(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, 0, 0);
+  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+  ovr_CommitTextureSwapChain(session_, swap_chain_);
+
+  ovrPosef head_pose;
+  head_pose.Position.x = 0.0;
+  head_pose.Position.y = 0.0;
+  head_pose.Position.z = 0.0;
+
+  head_pose.Orientation.x = x;
+  head_pose.Orientation.y = y;
+  head_pose.Orientation.z = z;
+  head_pose.Orientation.w = w;
+
+  layer.Header.Type  = ovrLayerType_EyeFov;
+  layer.Header.Flags = ovrLayerFlag_TextureOriginAtBottomLeft; // Because OpenGL.
+  layer.SensorSampleTime = 0;
+
+  layer.ColorTexture[ovrEye_Left] = swap_chain_;
+  layer.Viewport[ovrEye_Left] = left_viewport_;
+  layer.Fov[ovrEye_Left] = left_fov_;
+  layer.RenderPose[ovrEye_Left] = head_pose;
+
+  layer.ColorTexture[ovrEye_Right] = swap_chain_;
+  layer.Viewport[ovrEye_Right] = right_viewport_;
+  layer.Fov[ovrEye_Right] = right_fov_;
+  layer.RenderPose[ovrEye_Right] = head_pose;
+}
+
+void OculusVRCompositor::OnSwapFrame() {
+  ovrLayerHeader* layers = &layer.Header;
+  if (OVR_FAILURE(ovr_SubmitFrame(session_, 0, nullptr, &layers, 1))) {
+    LOG(ERROR) << "Failed to submit frame to Oculus HMD";
+    fail_count_++;
+    return;
+  }
+}
+
+void OculusVRCompositor::TextureBounds(GLuint eye, GLfloat x, GLfloat y,
+    GLfloat width, GLfloat height) {
+  if (eye == 0) { // Left Eye
+    left_viewport_.Pos.x = x * width_;
+    left_viewport_.Pos.y = y * height_;
+    left_viewport_.Size.w = width * width_;
+    left_viewport_.Size.h = height * height_;
+  } else if (eye == 1) { // Right eye
+    right_viewport_.Pos.x = x * width_;
+    right_viewport_.Pos.y = y * height_;
+    right_viewport_.Size.w = width * width_;
+    right_viewport_.Size.h = height * height_;
+  }
+}
+
+void OculusVRCompositor::ResetPose() {
+  ovr_RecenterTrackingOrigin(session_);
+}
+
+void OculusVRCompositor::CreateProgram() {
+  program_ = glCreateProgram();
+  GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
+  CompileShader(vertex_shader, vertex_shader_source);
+  glAttachShader(program_, vertex_shader);
+
+  GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
+  CompileShader(fragment_shader, fragment_shader_source);
+  glAttachShader(program_, fragment_shader);
+
+  glBindAttribLocation(program_, 0, "a_position");
+  glLinkProgram(program_);
+
+  GLint linked;
+  glGetProgramiv(program_, GL_LINK_STATUS, &linked);
+  if (!linked)
+    LOG(ERROR) << "OculusVRCompositor::CreateProgram: program link failure.";
+
+  sampler_location_ = glGetUniformLocation(program_, "u_sampler");
+}
+
+void OculusVRCompositorLog(uintptr_t userData, int level, const char* message) {
+  LOG(INFO) << "Oculus GPU Log, Lvl " << level << ": " << message;
+}
+
+void OculusVRCompositor::Initialize() {
+  if (!initialized_) {
+    LOG(INFO) << "Initializing Oculus Compositor";
+
+    ovrInitParams params;
+    params.ConnectionTimeoutMS = 0;
+
+#if OCULUS_INIT_DEBUG
+    params.Flags = ovrInit_Debug;
+    params.LogCallback = OculusVRCompositorLog;
+#else
+    params.Flags = 0;
+    params.LogCallback = nullptr;
+#endif
+
+    if (OVR_FAILURE(ovr_Initialize(&params))) {
+      LOG(ERROR) << "Failed to initialize Oculus SDK";
+      return;
+    }
+
+    ovrGraphicsLuid luid;
+    if (OVR_FAILURE(ovr_Create(&session_, &luid))) {
+      LOG(ERROR) << "Failed to create Oculus HMD";
+      return;
+    }
+
+    ovrHmdDesc hmd_desc = ovr_GetHmdDesc(session_);
+
+    left_fov_ = hmd_desc.DefaultEyeFov[ovrEye_Left];
+    right_fov_ = hmd_desc.DefaultEyeFov[ovrEye_Right];
+
+    ovrSizei left_size = ovr_GetFovTextureSize(session_, ovrEye_Left, left_fov_, 1);
+    ovrSizei right_size = ovr_GetFovTextureSize(session_, ovrEye_Right, right_fov_, 1);
+
+    width_ = left_size.w + right_size.w;
+    height_ = left_size.h;
+
+    left_viewport_.Pos.x = 0;
+    left_viewport_.Pos.y = 0;
+    left_viewport_.Size = left_size;
+
+    right_viewport_.Pos.x = left_size.w;
+    right_viewport_.Pos.y = 0;
+    right_viewport_.Size = right_size;
+
+    ovrTextureSwapChainDesc desc = {};
+    desc.Type = ovrTexture_2D;
+    desc.ArraySize = 1;
+    desc.Width = width_;
+    desc.Height = height_;
+    desc.MipLevels = 1;
+    desc.Format = OVR_FORMAT_R8G8B8A8_UNORM_SRGB;
+    desc.SampleCount = 1;
+    desc.StaticImage = ovrFalse;
+    ovrResult result = ovr_CreateTextureSwapChainGL(session_, &desc, &swap_chain_);
+
+    ovr_GetTextureSwapChainLength(session_, swap_chain_, &swap_chain_length_);
+
+    if(OVR_SUCCESS(result)) {
+      for (int i = 0; i < swap_chain_length_; ++i) {
+        GLuint chainTexId;
+        ovr_GetTextureSwapChainBufferGL(session_, swap_chain_, i, &chainTexId);
+        glBindTexture(GL_TEXTURE_2D, chainTexId);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      }
+    }
+
+    glGenBuffersARB(1, &buffer_);
+    glBindBuffer(GL_ARRAY_BUFFER, buffer_);
+    const GLfloat kQuadVertices[] = {-1.0f, -1.0f,
+                                      1.0f, -1.0f,
+                                      1.0f,  1.0f,
+                                     -1.0f,  1.0f};
+    glBufferData(GL_ARRAY_BUFFER, sizeof(kQuadVertices), kQuadVertices, GL_STATIC_DRAW);
+
+    glGenFramebuffersEXT(1, &framebuffer_);
+
+    CreateProgram();
+
+    initialized_ = true;
+  }
+}
+
+}  // namespace gpu
diff --git a/gpu/command_buffer/service/vr/oculus/oculus_vr_compositor.h b/gpu/command_buffer/service/vr/oculus/oculus_vr_compositor.h
new file mode 100644
index 0000000..672633c
--- /dev/null
+++ b/gpu/command_buffer/service/vr/oculus/oculus_vr_compositor.h
@@ -0,0 +1,57 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef GPU_COMMAND_BUFFER_SERVICE_VR_OCULUS_VR_COMPOSITOR_H_
+#define GPU_COMMAND_BUFFER_SERVICE_VR_OCULUS_VR_COMPOSITOR_H_
+
+#include "gpu/command_buffer/service/vr/vr_compositor.h"
+#include "third_party/libovr/LibOVR/Include/OVR_CAPI.h"
+
+namespace gpu {
+
+class OculusVRCompositor : public VRCompositor {
+ public:
+  OculusVRCompositor();
+  ~OculusVRCompositor() override;
+
+  bool needsStateRestore() override { return true; }
+
+  void SubmitFrame(GLuint frame_texture,
+      GLfloat x, GLfloat y, GLfloat z, GLfloat w) override;
+
+  void OnSwapFrame() override;
+
+  void TextureBounds(GLuint eye, GLfloat x, GLfloat y,
+    GLfloat width, GLfloat height) override;
+
+  void ResetPose() override;
+
+ private:
+  void Initialize();
+
+  void CreateProgram();
+
+  bool initialized_;
+  ovrSession session_;
+  ovrTextureSwapChain swap_chain_;
+  int swap_chain_length_;
+  ovrRecti left_viewport_;
+  ovrRecti right_viewport_;
+  ovrFovPort left_fov_;
+  ovrFovPort right_fov_;
+  GLuint width_;
+  GLuint height_;
+  unsigned int fail_count_;
+
+  GLuint buffer_;
+  GLuint framebuffer_;
+  GLuint program_;
+  GLuint sampler_location_;
+
+  ovrLayerEyeFov layer;
+};
+
+}  // namespace gpu
+
+#endif  // GPU_COMMAND_BUFFER_SERVICE_VR_OCULUS_VR_COMPOSITOR_H_
diff --git a/gpu/command_buffer/service/vr/openvr/open_vr_compositor.cc b/gpu/command_buffer/service/vr/openvr/open_vr_compositor.cc
new file mode 100644
index 0000000..3fbc2ea
--- /dev/null
+++ b/gpu/command_buffer/service/vr/openvr/open_vr_compositor.cc
@@ -0,0 +1,104 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gpu/command_buffer/service/vr/openvr/open_vr_compositor.h"
+
+#include "base/logging.h"
+#include "ui/gl/gl_bindings.h"
+
+namespace gpu {
+
+OpenVRCompositor::OpenVRCompositor()
+    : VRCompositor()
+    , initialized_(false)
+    , vr_system_(nullptr)
+    , compositor_(nullptr) {
+  Initialize();
+}
+
+OpenVRCompositor::~OpenVRCompositor() {
+  if (compositor_) {
+    compositor_->ClearLastSubmittedFrame();
+    vr::VR_Shutdown();
+  }
+}
+
+void OpenVRCompositor::SubmitFrame(GLuint frame_texture,
+    GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
+  if (!initialized_)
+    return;
+
+  vr::Texture_t vr_texture;
+  vr_texture.handle = reinterpret_cast<void*>(frame_texture);
+  vr_texture.eType = vr::API_OpenGL;
+  vr_texture.eColorSpace = vr::ColorSpace_Linear;
+
+  compositor_->Submit(vr::Eye_Left, &vr_texture, &left_bounds_);
+  compositor_->Submit(vr::Eye_Right, &vr_texture, &right_bounds_);
+
+  compositor_->PostPresentHandoff();
+}
+
+void OpenVRCompositor::OnSwapFrame() {
+  if (!initialized_)
+    return;
+
+  vr::TrackedDevicePose_t poses[vr::k_unMaxTrackedDeviceCount];
+  compositor_->WaitGetPoses(poses, vr::k_unMaxTrackedDeviceCount, NULL, 0);
+}
+
+void OpenVRCompositor::TextureBounds(GLuint eye, GLfloat x, GLfloat y,
+    GLfloat width, GLfloat height) {
+  if (eye == 0) { // Left Eye
+    left_bounds_.uMin = x;
+    left_bounds_.vMin = y;
+    left_bounds_.uMax = x + width;
+    left_bounds_.vMax = y + height;
+  } else if (eye == 1) { // Right eye
+    right_bounds_.uMin = x;
+    right_bounds_.vMin = y;
+    right_bounds_.uMax = x + width;
+    right_bounds_.vMax = y + height;
+  }
+}
+
+void OpenVRCompositor::ResetPose() {
+  // Nothing to do for OpenVR. It syncs pose resets across processes.
+}
+
+void OpenVRCompositor::Initialize() {
+  if (!initialized_) {
+    vr::EVRInitError error = vr::VRInitError_None;
+    vr_system_ = vr::VR_Init(&error, vr::VRApplication_Scene);
+
+    if (error != vr::VRInitError_None) {
+      LOG(ERROR) << "Error creating OpenVR System: " << vr::VR_GetVRInitErrorAsEnglishDescription(error);
+      vr_system_ = nullptr;
+      return;
+    }
+
+    compositor_ = static_cast<vr::IVRCompositor*>(
+        vr::VR_GetGenericInterface(vr::IVRCompositor_Version, &error));
+
+    if (error != vr::VRInitError_None) {
+      LOG(ERROR) << "Error creating OpenVR Compositor: " << vr::VR_GetVRInitErrorAsEnglishDescription(error);
+      compositor_ = nullptr;
+      return;
+    }
+
+    left_bounds_.uMin = 0.0f;
+    left_bounds_.vMin = 0.0f;
+    left_bounds_.uMax = 0.5f;
+    left_bounds_.vMax = 1.0f;
+
+    right_bounds_.uMin = 0.5f;
+    right_bounds_.vMin = 0.0f;
+    right_bounds_.uMax = 1.0f;
+    right_bounds_.vMax = 1.0f;
+
+    initialized_ = true;
+  }
+}
+
+}  // namespace gpu
diff --git a/gpu/command_buffer/service/vr/openvr/open_vr_compositor.h b/gpu/command_buffer/service/vr/openvr/open_vr_compositor.h
new file mode 100644
index 0000000..ac45433
--- /dev/null
+++ b/gpu/command_buffer/service/vr/openvr/open_vr_compositor.h
@@ -0,0 +1,42 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef GPU_COMMAND_BUFFER_SERVICE_VR_OPEN_VR_COMPOSITOR_H_
+#define GPU_COMMAND_BUFFER_SERVICE_VR_OPEN_VR_COMPOSITOR_H_
+
+#include "gpu/command_buffer/service/vr/vr_compositor.h"
+#include "third_party/openvr/openvr/headers/openvr.h"
+#include "ui/gl/gl_bindings.h"
+
+namespace gpu {
+
+class OpenVRCompositor : public VRCompositor {
+ public:
+  OpenVRCompositor();
+  ~OpenVRCompositor() override;
+
+  void SubmitFrame(GLuint frame_texture,
+      GLfloat x, GLfloat y, GLfloat z, GLfloat w) override;
+
+  void OnSwapFrame() override;
+
+  void TextureBounds(GLuint eye, GLfloat x, GLfloat y,
+    GLfloat width, GLfloat height) override;
+
+  void ResetPose() override;
+
+ private:
+  void Initialize();
+  void WaitGetPoses();
+
+  bool initialized_;
+  vr::IVRSystem* vr_system_;
+  vr::IVRCompositor* compositor_;
+  vr::VRTextureBounds_t left_bounds_;
+  vr::VRTextureBounds_t right_bounds_;
+};
+
+}  // namespace gpu
+
+#endif  // GPU_COMMAND_BUFFER_SERVICE_VR_OPEN_VR_COMPOSITOR_H_
diff --git a/gpu/command_buffer/service/vr/vr_compositor.h b/gpu/command_buffer/service/vr/vr_compositor.h
new file mode 100644
index 0000000..8666ec3
--- /dev/null
+++ b/gpu/command_buffer/service/vr/vr_compositor.h
@@ -0,0 +1,32 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef GPU_COMMAND_BUFFER_SERVICE_VR_VR_COMPOSITOR_H_
+#define GPU_COMMAND_BUFFER_SERVICE_VR_VR_COMPOSITOR_H_
+
+#include "ui/gl/gl_bindings.h"
+
+namespace gpu {
+
+class VRCompositor {
+ public:
+  VRCompositor() { }
+  virtual ~VRCompositor() { }
+
+  virtual bool needsStateRestore() { return false; }
+
+  virtual void SubmitFrame(GLuint frame_texture,
+      GLfloat x, GLfloat y, GLfloat z, GLfloat w) = 0;
+
+  virtual void OnSwapFrame() {};
+
+  virtual void TextureBounds(GLuint eye, GLfloat x, GLfloat y,
+    GLfloat width, GLfloat height) = 0;
+
+  virtual void ResetPose() = 0;
+};
+
+}  // namespace gpu
+
+#endif  // GPU_COMMAND_BUFFER_SERVICE_VR_VR_COMPOSITOR_H_
diff --git a/gpu/command_buffer_service.gypi b/gpu/command_buffer_service.gypi
index fc9f33f..048a1cb 100644
--- a/gpu/command_buffer_service.gypi
+++ b/gpu/command_buffer_service.gypi
@@ -143,5 +143,30 @@
         ],
       },
     }],
+    ['enable_webvr==1 and OS=="win"', {
+      'sources': [
+        'command_buffer/service/vr/openvr/open_vr_compositor.cc',
+        'command_buffer/service/vr/openvr/open_vr_compositor.h',
+      ],
+      'msvs_settings': {
+        'VCLinkerTool': {
+          'AdditionalDependencies': [
+            'openvr_api.lib',
+          ],
+          'AdditionalLibraryDirectories': [
+            '../third_party/openvr/openvr/lib/win32',
+          ],
+        },
+      },
+    }],
+    ['enable_webvr==1 and OS=="win"', {
+      'dependencies': [
+        '../third_party/libovr/libovr.gyp:libovr',
+      ],
+      'sources': [
+        'command_buffer/service/vr/oculus/oculus_vr_compositor.cc',
+        'command_buffer/service/vr/oculus/oculus_vr_compositor.h',
+      ]
+    }],
   ],
 }
diff --git a/ppapi/shared_impl/ppb_gamepad_shared.h b/ppapi/shared_impl/ppb_gamepad_shared.h
index 4628399..436f01a 100644
--- a/ppapi/shared_impl/ppb_gamepad_shared.h
+++ b/ppapi/shared_impl/ppb_gamepad_shared.h
@@ -21,9 +21,29 @@ namespace ppapi {
 
 struct WebKitGamepadButton {
   bool pressed;
+  bool touched;
   double value;
 };
 
+struct WebKitGamepadVector {
+    bool isNull;
+    float x, y, z, w;
+};
+
+class WebKitGamepadPose {
+public:
+    WebKitGamepadPose()
+        : isNull(true)
+    {
+    }
+
+    bool isNull;
+
+    // TODO: 6DOF
+    WebKitGamepadVector orientation;
+    WebKitGamepadVector position;
+};
+
 // This must match the definition of blink::Gamepad. The GamepadHost unit test
 // has some compile asserts to validate this.
 struct WebKitGamepad {
@@ -56,6 +76,8 @@ struct WebKitGamepad {
 
   // Mapping type (for example "standard")
   base::char16 mapping[kMappingLengthCap];
+  
+  WebKitGamepadPose pose;
 };
 
 // This must match the definition of blink::Gamepads. The GamepadHost unit
diff --git a/third_party/WebKit/Source/core/events/EventTypeNames.in b/third_party/WebKit/Source/core/events/EventTypeNames.in
index 3518856..59da917 100644
--- a/third_party/WebKit/Source/core/events/EventTypeNames.in
+++ b/third_party/WebKit/Source/core/events/EventTypeNames.in
@@ -243,6 +243,9 @@ versionchange
 visibilitychange
 voiceschanged
 volumechange
+vrdisplayconnected
+vrdisplaydisconnected
+vrdisplaypresentchange
 waiting
 waitingforkey
 webglcontextcreationerror
diff --git a/third_party/WebKit/Source/modules/gamepad/Gamepad.cpp b/third_party/WebKit/Source/modules/gamepad/Gamepad.cpp
index 94766f0..388e2e0 100644
--- a/third_party/WebKit/Source/modules/gamepad/Gamepad.cpp
+++ b/third_party/WebKit/Source/modules/gamepad/Gamepad.cpp
@@ -54,12 +54,27 @@ void Gamepad::setButtons(unsigned count, const WebGamepadButton* data)
     for (unsigned i = 0; i < count; ++i) {
         m_buttons[i]->setValue(data[i].value);
         m_buttons[i]->setPressed(data[i].pressed);
+        m_buttons[i]->setTouched(data[i].touched);
     }
 }
 
+void Gamepad::setPose(const WebGamepadPose& pose) {
+    if (pose.isNull) {
+        if (m_pose)
+            m_pose = nullptr;
+        return;
+    }
+
+    if (!m_pose)
+        m_pose = VRPose::create();
+
+    m_pose->setPose(pose);
+}
+
 DEFINE_TRACE(Gamepad)
 {
     visitor->trace(m_buttons);
+    visitor->trace(m_pose);
 }
 
 } // namespace blink
diff --git a/third_party/WebKit/Source/modules/gamepad/Gamepad.h b/third_party/WebKit/Source/modules/gamepad/Gamepad.h
index b9ac12c..43d580b 100644
--- a/third_party/WebKit/Source/modules/gamepad/Gamepad.h
+++ b/third_party/WebKit/Source/modules/gamepad/Gamepad.h
@@ -28,6 +28,7 @@
 
 #include "bindings/core/v8/ScriptWrappable.h"
 #include "modules/gamepad/GamepadButton.h"
+#include "modules/vr/VRPose.h"
 #include "platform/heap/Handle.h"
 #include "public/platform/WebGamepad.h"
 #include "wtf/Vector.h"
@@ -66,6 +67,9 @@ public:
 
     const GamepadButtonVector& buttons() const { return m_buttons; }
     void setButtons(unsigned count, const WebGamepadButton* data);
+    
+    VRPose* pose() const { return m_pose; }
+    void setPose(const WebGamepadPose& pose);
 
     DECLARE_TRACE();
 
@@ -79,6 +83,7 @@ private:
     String m_mapping;
     DoubleVector m_axes;
     GamepadButtonVector m_buttons;
+    Member<VRPose> m_pose;
 };
 
 } // namespace blink
diff --git a/third_party/WebKit/Source/modules/gamepad/Gamepad.idl b/third_party/WebKit/Source/modules/gamepad/Gamepad.idl
index 9459de1..d71c0b0 100644
--- a/third_party/WebKit/Source/modules/gamepad/Gamepad.idl
+++ b/third_party/WebKit/Source/modules/gamepad/Gamepad.idl
@@ -33,4 +33,6 @@
     readonly attribute DOMString mapping;
     readonly attribute double[] axes;
     readonly attribute GamepadButton[] buttons;
+    
+    readonly attribute VRPose? pose;
 };
diff --git a/third_party/WebKit/Source/modules/gamepad/GamepadButton.cpp b/third_party/WebKit/Source/modules/gamepad/GamepadButton.cpp
index 8573d70..389bac6 100644
--- a/third_party/WebKit/Source/modules/gamepad/GamepadButton.cpp
+++ b/third_party/WebKit/Source/modules/gamepad/GamepadButton.cpp
@@ -14,6 +14,7 @@ GamepadButton* GamepadButton::create()
 GamepadButton::GamepadButton()
     : m_value(0.)
     , m_pressed(false)
+    , m_touched(false)
 {
 }
 
diff --git a/third_party/WebKit/Source/modules/gamepad/GamepadButton.h b/third_party/WebKit/Source/modules/gamepad/GamepadButton.h
index 1b2ca71..cac2d43 100644
--- a/third_party/WebKit/Source/modules/gamepad/GamepadButton.h
+++ b/third_party/WebKit/Source/modules/gamepad/GamepadButton.h
@@ -21,6 +21,9 @@ public:
 
     bool pressed() const { return m_pressed; }
     void setPressed(bool val) { m_pressed = val; }
+    
+    bool touched() const { return m_touched; }
+    void setTouched(bool val) { m_touched = val; }
 
     DEFINE_INLINE_TRACE() { }
 
@@ -28,6 +31,7 @@ private:
     GamepadButton();
     double m_value;
     bool m_pressed;
+    bool m_touched;
 };
 
 typedef HeapVector<Member<GamepadButton>> GamepadButtonVector;
diff --git a/third_party/WebKit/Source/modules/gamepad/GamepadButton.idl b/third_party/WebKit/Source/modules/gamepad/GamepadButton.idl
index 1a4a8cb..5be4898 100644
--- a/third_party/WebKit/Source/modules/gamepad/GamepadButton.idl
+++ b/third_party/WebKit/Source/modules/gamepad/GamepadButton.idl
@@ -5,6 +5,7 @@
 [
     GarbageCollected,
 ] interface GamepadButton {
+    readonly attribute boolean touched;
     readonly attribute boolean pressed;
     readonly attribute double value;
 };
diff --git a/third_party/WebKit/Source/modules/gamepad/NavigatorGamepad.cpp b/third_party/WebKit/Source/modules/gamepad/NavigatorGamepad.cpp
index efad7b6..548bc64 100644
--- a/third_party/WebKit/Source/modules/gamepad/NavigatorGamepad.cpp
+++ b/third_party/WebKit/Source/modules/gamepad/NavigatorGamepad.cpp
@@ -46,6 +46,7 @@ static void sampleGamepad(unsigned index, T& gamepad, const WebGamepad& webGamep
     gamepad.setMapping(webGamepad.mapping);
     gamepad.setAxes(webGamepad.axesLength, webGamepad.axes);
     gamepad.setButtons(webGamepad.buttonsLength, webGamepad.buttons);
+    gamepad.setPose(webGamepad.pose);
 }
 
 template<typename GamepadType, typename ListType>
diff --git a/third_party/WebKit/Source/modules/modules.gypi b/third_party/WebKit/Source/modules/modules.gypi
index 5b2dd28..735b4c7 100644
--- a/third_party/WebKit/Source/modules/modules.gypi
+++ b/third_party/WebKit/Source/modules/modules.gypi
@@ -202,12 +202,12 @@
       'speech/SpeechSynthesisVoice.idl',
       'storage/Storage.idl',
       'storage/StorageEvent.idl',
-      'vr/HMDVRDevice.idl',
-      'vr/PositionSensorVRDevice.idl',
-      'vr/VRDevice.idl',
+      'vr/VRDisplay.idl',
+      'vr/VRDisplayCapabilities.idl',
       'vr/VREyeParameters.idl',
       'vr/VRFieldOfView.idl',
-      'vr/VRPositionState.idl',
+      'vr/VRPose.idl',
+      'vr/VRStageParameters.idl',
       'webaudio/AnalyserNode.idl',
       'webaudio/AudioBuffer.idl',
       'webaudio/AudioBufferCallback.idl',
@@ -391,7 +391,7 @@
       'speech/WindowSpeechSynthesis.idl',
       'storage/WindowStorage.idl',
       'vibration/NavigatorVibration.idl',
-      'vr/NavigatorVRDevice.idl',
+      'vr/NavigatorVR.idl',
       'wake_lock/ScreenWakeLock.idl',
       'webaudio/WindowWebAudio.idl',
       'webdatabase/WindowWebDatabase.idl',
@@ -513,6 +513,7 @@
       'speech/SpeechRecognitionEventInit.idl',
       'storage/StorageEventInit.idl',
       'vr/VRFieldOfViewInit.idl',
+      'vr/VRLayer.idl',
       'webgl/WebGLContextAttributes.idl',
       'webgl/WebGLContextEventInit.idl',
       'webmidi/MIDIConnectionEventInit.idl',
@@ -680,6 +681,8 @@
       '<(blink_modules_output_dir)/storage/StorageEventInit.h',
       '<(blink_modules_output_dir)/vr/VRFieldOfViewInit.cpp',
       '<(blink_modules_output_dir)/vr/VRFieldOfViewInit.h',
+      '<(blink_modules_output_dir)/vr/VRLayer.cpp',
+      '<(blink_modules_output_dir)/vr/VRLayer.h',
       '<(blink_modules_output_dir)/webgl/WebGLContextAttributes.cpp',
       '<(blink_modules_output_dir)/webgl/WebGLContextAttributes.h',
       '<(blink_modules_output_dir)/webgl/WebGLContextEventInit.cpp',
@@ -1489,27 +1492,25 @@
       'storage/StorageNamespaceController.h',
       'vibration/NavigatorVibration.cpp',
       'vibration/NavigatorVibration.h',
-      'vr/HMDVRDevice.cpp',
-      'vr/HMDVRDevice.h',
-      'vr/NavigatorVRDevice.cpp',
-      'vr/NavigatorVRDevice.h',
-      'vr/PositionSensorVRDevice.cpp',
-      'vr/PositionSensorVRDevice.h',
+      'vr/NavigatorVR.cpp',
+      'vr/NavigatorVR.h',
       'vr/VRController.cpp',
       'vr/VRController.h',
-      'vr/VRDevice.cpp',
-      'vr/VRDevice.h',
+      'vr/VRDisplay.cpp',
+      'vr/VRDisplay.h',
+      'vr/VRDisplayCapabilities.cpp',
+      'vr/VRDisplayCapabilities.h',
+      'vr/VRDisplayCollection.cpp',
+      'vr/VRDisplayCollection.h',
       'vr/VREyeParameters.cpp',
       'vr/VREyeParameters.h',
       'vr/VRFieldOfView.h',
       'vr/VRGetDevicesCallback.cpp',
       'vr/VRGetDevicesCallback.h',
-      'vr/VRHardwareUnit.cpp',
-      'vr/VRHardwareUnit.h',
-      'vr/VRHardwareUnitCollection.cpp',
-      'vr/VRHardwareUnitCollection.h',
-      'vr/VRPositionState.cpp',
-      'vr/VRPositionState.h',
+      'vr/VRPose.cpp',
+      'vr/VRPose.h',
+      'vr/VRStageParameters.cpp',
+      'vr/VRStageParameters.h',
       'wake_lock/ScreenWakeLock.cpp',
       'wake_lock/ScreenWakeLock.h',
       'webaudio/AbstractAudioContext.cpp',
diff --git a/third_party/WebKit/Source/modules/vr/HMDVRDevice.cpp b/third_party/WebKit/Source/modules/vr/HMDVRDevice.cpp
deleted file mode 100644
index 3404f7b..0000000
--- a/third_party/WebKit/Source/modules/vr/HMDVRDevice.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "modules/vr/HMDVRDevice.h"
-
-#include "modules/vr/VRController.h"
-#include "modules/vr/VRFieldOfView.h"
-
-namespace blink {
-
-namespace {
-
-VREye stringToVREye(const String& whichEye)
-{
-    if (whichEye == "left")
-        return VREyeLeft;
-    if (whichEye == "right")
-        return VREyeRight;
-    return VREyeNone;
-}
-
-} // namespace
-
-HMDVRDevice::HMDVRDevice(VRHardwareUnit* hardwareUnit, unsigned deviceId)
-    : VRDevice(hardwareUnit, deviceId)
-{
-    m_eyeParametersLeft = VREyeParameters::create();
-    m_eyeParametersRight = VREyeParameters::create();
-}
-
-void HMDVRDevice::updateFromWebVRDevice(const WebVRDevice& device)
-{
-    VRDevice::updateFromWebVRDevice(device);
-    const WebVRHMDInfo &hmdInfo = device.hmdInfo;
-
-    m_eyeParametersLeft->setFromWebVREyeParameters(hmdInfo.leftEye);
-    m_eyeParametersRight->setFromWebVREyeParameters(hmdInfo.rightEye);
-}
-
-VREyeParameters* HMDVRDevice::getEyeParameters(const String& whichEye)
-{
-    switch (stringToVREye(whichEye)) {
-    case VREyeLeft:
-        return m_eyeParametersLeft;
-    case VREyeRight:
-        return m_eyeParametersRight;
-    default:
-        return nullptr;
-    }
-}
-
-void HMDVRDevice::setFieldOfView(VRFieldOfView* leftFov, VRFieldOfView* rightFov)
-{
-    // FIXME: Currently min == max == recommended FOV, but when that changes
-    // this function will need to perform clamping and track the set value
-}
-
-DEFINE_TRACE(HMDVRDevice)
-{
-    visitor->trace(m_eyeParametersLeft);
-    visitor->trace(m_eyeParametersRight);
-
-    VRDevice::trace(visitor);
-}
-
-} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/HMDVRDevice.h b/third_party/WebKit/Source/modules/vr/HMDVRDevice.h
deleted file mode 100644
index 453ccd7..0000000
--- a/third_party/WebKit/Source/modules/vr/HMDVRDevice.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef HMDVRDevice_h
-#define HMDVRDevice_h
-
-#include "modules/vr/VRDevice.h"
-#include "modules/vr/VREyeParameters.h"
-#include "platform/heap/Handle.h"
-#include "public/platform/modules/vr/WebVR.h"
-#include "wtf/Forward.h"
-#include "wtf/text/WTFString.h"
-
-namespace blink {
-
-class VRFieldOfView;
-
-class HMDVRDevice final : public VRDevice {
-    DEFINE_WRAPPERTYPEINFO();
-public:
-    HMDVRDevice(VRHardwareUnit*, unsigned);
-
-    void updateFromWebVRDevice(const WebVRDevice&) override;
-
-    VREyeParameters* getEyeParameters(const String&);
-    void setFieldOfView(VRFieldOfView* leftFov = 0, VRFieldOfView* rightFov = 0);
-
-    DECLARE_VIRTUAL_TRACE();
-
-private:
-    Member<VREyeParameters> m_eyeParametersLeft;
-    Member<VREyeParameters> m_eyeParametersRight;
-};
-
-} // namespace blink
-
-#endif // HMDVRDevice_h
diff --git a/third_party/WebKit/Source/modules/vr/HMDVRDevice.idl b/third_party/WebKit/Source/modules/vr/HMDVRDevice.idl
deleted file mode 100644
index 2737c66..0000000
--- a/third_party/WebKit/Source/modules/vr/HMDVRDevice.idl
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-enum VREye {
-    "left",
-    "right"
-};
-
-// An HMDVRDevice represents a Head Mounted Display. The interface provides all
-// the information necessary to correctly render a stereo 3D scene for a given
-// headset.
-// http://mozvr.github.io/webvr-spec/webvr.html#hmdvrdevice
-[
-    RuntimeEnabled=WebVR,
-] interface HMDVRDevice : VRDevice {
-    VREyeParameters getEyeParameters(VREye whichEye);
-    void setFieldOfView(optional VRFieldOfView leftFov, optional VRFieldOfView rightFov);
-};
diff --git a/third_party/WebKit/Source/modules/vr/NavigatorVR.cpp b/third_party/WebKit/Source/modules/vr/NavigatorVR.cpp
new file mode 100644
index 0000000..5f1b68d
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/NavigatorVR.cpp
@@ -0,0 +1,145 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "modules/vr/NavigatorVR.h"
+
+#include "bindings/core/v8/ScriptPromiseResolver.h"
+#include "core/dom/DOMException.h"
+#include "core/dom/Document.h"
+#include "core/dom/ExceptionCode.h"
+#include "core/frame/LocalDOMWindow.h"
+#include "core/frame/LocalFrame.h"
+#include "core/frame/Navigator.h"
+#include "core/page/Page.h"
+#include "modules/EventModules.h"
+#include "modules/vr/VRDisplay.h"
+#include "modules/vr/VRDisplayCollection.h"
+#include "modules/vr/VRController.h"
+#include "modules/vr/VRGetDevicesCallback.h"
+#include "modules/vr/VRPose.h"
+
+namespace blink {
+
+NavigatorVR* NavigatorVR::from(Document& document)
+{
+    if (!document.frame() || !document.frame()->domWindow())
+        return 0;
+    Navigator& navigator = *document.frame()->domWindow()->navigator();
+    return &from(navigator);
+}
+
+NavigatorVR& NavigatorVR::from(Navigator& navigator)
+{
+    NavigatorVR* supplement = static_cast<NavigatorVR*>(HeapSupplement<Navigator>::from(navigator, supplementName()));
+    if (!supplement) {
+        supplement = new NavigatorVR(navigator.frame());
+        provideTo(navigator, supplementName(), supplement);
+    }
+    return *supplement;
+}
+
+ScriptPromise NavigatorVR::getVRDisplays(ScriptState* scriptState, Navigator& navigator)
+{
+    return NavigatorVR::from(navigator).getVRDisplays(scriptState);
+}
+
+ScriptPromise NavigatorVR::getVRDisplays(ScriptState* scriptState)
+{
+    ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
+    ScriptPromise promise = resolver->promise();
+
+    Document* document = m_frame ? m_frame->document() : 0;
+
+    if (!document || !controller()) {
+        DOMException* exception = DOMException::create(InvalidStateError, "The object is no longer associated to a document.");
+        resolver->reject(exception);
+        return promise;
+    }
+
+    controller()->getDevices(new VRGetDevicesCallback(resolver, m_displays.get()));
+
+    return promise;
+}
+
+VRController* NavigatorVR::controller()
+{
+    if (!frame())
+        return 0;
+
+    return VRController::from(*frame());
+}
+
+Document* NavigatorVR::document()
+{
+    return m_frame ? m_frame->document() : 0;
+}
+
+DEFINE_TRACE(NavigatorVR)
+{
+    visitor->trace(m_displays);
+
+    HeapSupplement<Navigator>::trace(visitor);
+    DOMWindowProperty::trace(visitor);
+}
+
+NavigatorVR::NavigatorVR(LocalFrame* frame)
+    : DOMWindowProperty(frame)
+    , DOMWindowLifecycleObserver(frame ? frame->localDOMWindow() : 0)
+    , m_hasConnectionEventListener(false)
+{
+    m_displays = new VRDisplayCollection(this);
+}
+
+NavigatorVR::~NavigatorVR()
+{
+}
+
+const char* NavigatorVR::supplementName()
+{
+    return "NavigatorVR";
+}
+
+void NavigatorVR::fireVRDisplayPresentChange()
+{
+    if (m_frame) {
+        m_frame->domWindow()->dispatchEvent(Event::create(EventTypeNames::vrdisplaypresentchange));
+    }
+}
+
+static bool isVRConnectionEvent(const AtomicString& eventType)
+{
+    return eventType == EventTypeNames::vrdisplayconnected || eventType == EventTypeNames::vrdisplaydisconnected;
+}
+
+void NavigatorVR::didAddEventListener(LocalDOMWindow*, const AtomicString& eventType)
+{
+    if (isVRConnectionEvent(eventType)) {
+        /*if (page() && page()->isPageVisible())
+            startUpdatingIfAttached();*/
+        m_hasConnectionEventListener = true;
+    }
+}
+
+void NavigatorVR::didRemoveEventListener(LocalDOMWindow* window, const AtomicString& eventType)
+{
+    if (isVRConnectionEvent(eventType)
+        && !window->hasEventListeners(EventTypeNames::vrdisplayconnected)
+        && !window->hasEventListeners(EventTypeNames::vrdisplaydisconnected)) {
+        didRemoveVRConnectionEventListeners();
+    }
+}
+
+void NavigatorVR::didRemoveAllEventListeners(LocalDOMWindow*)
+{
+    didRemoveVRConnectionEventListeners();
+}
+
+void NavigatorVR::didRemoveVRConnectionEventListeners()
+{
+    m_hasConnectionEventListener = false;
+    /*m_dispatchOneEventRunner->stop();
+    m_pendingEvents.clear();*/
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/NavigatorVR.h b/third_party/WebKit/Source/modules/vr/NavigatorVR.h
new file mode 100644
index 0000000..cdc178f
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/NavigatorVR.h
@@ -0,0 +1,62 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NavigatorVR_h
+#define NavigatorVR_h
+
+#include "bindings/core/v8/ScriptPromise.h"
+#include "core/frame/DOMWindowLifecycleObserver.h"
+#include "core/frame/DOMWindowProperty.h"
+#include "modules/ModulesExport.h"
+#include "modules/vr/VRDisplay.h"
+#include "platform/Supplementable.h"
+#include "platform/heap/Handle.h"
+#include "public/platform/WebVector.h"
+#include "wtf/Noncopyable.h"
+
+namespace blink {
+
+class Document;
+class Navigator;
+class VRController;
+class VRDisplayCollection;
+
+class MODULES_EXPORT NavigatorVR final : public GarbageCollectedFinalized<NavigatorVR>, public HeapSupplement<Navigator>, public DOMWindowProperty, public DOMWindowLifecycleObserver {
+    USING_GARBAGE_COLLECTED_MIXIN(NavigatorVR);
+    WTF_MAKE_NONCOPYABLE(NavigatorVR);
+public:
+    static NavigatorVR* from(Document&);
+    static NavigatorVR& from(Navigator&);
+    virtual ~NavigatorVR();
+
+    static ScriptPromise getVRDisplays(ScriptState*, Navigator&);
+    ScriptPromise getVRDisplays(ScriptState*);
+
+    VRController* controller();
+    Document* document();
+
+    DECLARE_VIRTUAL_TRACE();
+
+private:
+    friend class VRDisplay;
+    friend class VRGetDevicesCallback;
+
+    explicit NavigatorVR(LocalFrame*);
+
+    static const char* supplementName();
+    void fireVRDisplayPresentChange();
+    void didRemoveVRConnectionEventListeners();
+
+    // DOMWindowLifecycleObserver
+    void didAddEventListener(LocalDOMWindow*, const AtomicString&) override;
+    void didRemoveEventListener(LocalDOMWindow*, const AtomicString&) override;
+    void didRemoveAllEventListeners(LocalDOMWindow*) override;
+
+    Member<VRDisplayCollection> m_displays;
+    bool m_hasConnectionEventListener;
+};
+
+} // namespace blink
+
+#endif // NavigatorVR_h
diff --git a/third_party/WebKit/Source/modules/vr/NavigatorVR.idl b/third_party/WebKit/Source/modules/vr/NavigatorVR.idl
new file mode 100644
index 0000000..4e999ba
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/NavigatorVR.idl
@@ -0,0 +1,10 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// http://mozvr.github.io/webvr-spec/webvr.html#navigator
+[
+    RuntimeEnabled=WebVR,
+] partial interface Navigator {
+    [CallWith=ScriptState] Promise getVRDisplays();
+};
diff --git a/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.cpp b/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.cpp
deleted file mode 100644
index 9b8e02e..0000000
--- a/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "modules/vr/NavigatorVRDevice.h"
-
-#include "bindings/core/v8/ScriptPromiseResolver.h"
-#include "core/dom/DOMException.h"
-#include "core/dom/Document.h"
-#include "core/dom/ExceptionCode.h"
-#include "core/frame/LocalDOMWindow.h"
-#include "core/frame/LocalFrame.h"
-#include "core/frame/Navigator.h"
-#include "core/page/Page.h"
-#include "modules/vr/HMDVRDevice.h"
-#include "modules/vr/PositionSensorVRDevice.h"
-#include "modules/vr/VRController.h"
-#include "modules/vr/VRGetDevicesCallback.h"
-#include "modules/vr/VRHardwareUnit.h"
-#include "modules/vr/VRHardwareUnitCollection.h"
-#include "modules/vr/VRPositionState.h"
-
-namespace blink {
-
-NavigatorVRDevice* NavigatorVRDevice::from(Document& document)
-{
-    if (!document.frame() || !document.frame()->domWindow())
-        return 0;
-    Navigator& navigator = *document.frame()->domWindow()->navigator();
-    return &from(navigator);
-}
-
-NavigatorVRDevice& NavigatorVRDevice::from(Navigator& navigator)
-{
-    NavigatorVRDevice* supplement = static_cast<NavigatorVRDevice*>(HeapSupplement<Navigator>::from(navigator, supplementName()));
-    if (!supplement) {
-        supplement = new NavigatorVRDevice(navigator.frame());
-        provideTo(navigator, supplementName(), supplement);
-    }
-    return *supplement;
-}
-
-ScriptPromise NavigatorVRDevice::getVRDevices(ScriptState* scriptState, Navigator& navigator)
-{
-    return NavigatorVRDevice::from(navigator).getVRDevices(scriptState);
-}
-
-ScriptPromise NavigatorVRDevice::getVRDevices(ScriptState* scriptState)
-{
-    ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
-    ScriptPromise promise = resolver->promise();
-
-    Document* document = m_frame ? m_frame->document() : 0;
-
-    if (!document || !controller()) {
-        DOMException* exception = DOMException::create(InvalidStateError, "The object is no longer associated to a document.");
-        resolver->reject(exception);
-        return promise;
-    }
-
-    controller()->getDevices(new VRGetDevicesCallback(resolver, m_hardwareUnits.get()));
-
-    return promise;
-}
-
-VRController* NavigatorVRDevice::controller()
-{
-    if (!frame())
-        return 0;
-
-    return VRController::from(*frame());
-}
-
-DEFINE_TRACE(NavigatorVRDevice)
-{
-    visitor->trace(m_hardwareUnits);
-
-    HeapSupplement<Navigator>::trace(visitor);
-    DOMWindowProperty::trace(visitor);
-}
-
-NavigatorVRDevice::NavigatorVRDevice(LocalFrame* frame)
-    : DOMWindowProperty(frame)
-{
-    m_hardwareUnits = new VRHardwareUnitCollection(this);
-}
-
-NavigatorVRDevice::~NavigatorVRDevice()
-{
-}
-
-const char* NavigatorVRDevice::supplementName()
-{
-    return "NavigatorVRDevice";
-}
-
-} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.h b/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.h
deleted file mode 100644
index 68e12e7..0000000
--- a/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NavigatorVRDevice_h
-#define NavigatorVRDevice_h
-
-#include "bindings/core/v8/ScriptPromise.h"
-#include "core/frame/DOMWindowProperty.h"
-#include "modules/ModulesExport.h"
-#include "modules/vr/VRDevice.h"
-#include "modules/vr/VRHardwareUnit.h"
-#include "platform/Supplementable.h"
-#include "platform/heap/Handle.h"
-#include "public/platform/WebVector.h"
-#include "wtf/Noncopyable.h"
-
-namespace blink {
-
-class Document;
-class Navigator;
-class VRController;
-class VRHardwareUnitCollection;
-
-class MODULES_EXPORT NavigatorVRDevice final : public GarbageCollectedFinalized<NavigatorVRDevice>, public HeapSupplement<Navigator>, public DOMWindowProperty {
-    USING_GARBAGE_COLLECTED_MIXIN(NavigatorVRDevice);
-    WTF_MAKE_NONCOPYABLE(NavigatorVRDevice);
-public:
-    static NavigatorVRDevice* from(Document&);
-    static NavigatorVRDevice& from(Navigator&);
-    virtual ~NavigatorVRDevice();
-
-    static ScriptPromise getVRDevices(ScriptState*, Navigator&);
-    ScriptPromise getVRDevices(ScriptState*);
-
-    VRController* controller();
-
-    DECLARE_VIRTUAL_TRACE();
-
-private:
-    friend class VRHardwareUnit;
-    friend class VRGetDevicesCallback;
-
-    explicit NavigatorVRDevice(LocalFrame*);
-
-    static const char* supplementName();
-
-    Member<VRHardwareUnitCollection> m_hardwareUnits;
-};
-
-} // namespace blink
-
-#endif // NavigatorVRDevice_h
diff --git a/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.idl b/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.idl
deleted file mode 100644
index 89c4c82..0000000
--- a/third_party/WebKit/Source/modules/vr/NavigatorVRDevice.idl
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-[
-    RuntimeEnabled=WebVR,
-] partial interface Navigator {
-    [CallWith=ScriptState] Promise getVRDevices();
-};
diff --git a/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.cpp b/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.cpp
deleted file mode 100644
index fa972d5..0000000
--- a/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "modules/vr/PositionSensorVRDevice.h"
-
-#include "modules/vr/VRController.h"
-#include "public/platform/Platform.h"
-
-namespace blink {
-
-PositionSensorVRDevice::PositionSensorVRDevice(VRHardwareUnit* hardwareUnit, unsigned deviceId)
-    : VRDevice(hardwareUnit, deviceId)
-{
-}
-
-VRPositionState* PositionSensorVRDevice::getState()
-{
-    return hardwareUnit()->getSensorState();
-}
-
-VRPositionState* PositionSensorVRDevice::getImmediateState()
-{
-    return hardwareUnit()->getImmediateSensorState(false);
-}
-
-void PositionSensorVRDevice::resetSensor()
-{
-    controller()->resetSensor(index());
-}
-
-DEFINE_TRACE(PositionSensorVRDevice)
-{
-    VRDevice::trace(visitor);
-}
-
-} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.h b/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.h
deleted file mode 100644
index f97b15b..0000000
--- a/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef PositionSensorVRDevice_h
-#define PositionSensorVRDevice_h
-
-#include "bindings/core/v8/ScriptWrappable.h"
-#include "modules/vr/VRDevice.h"
-#include "modules/vr/VRPositionState.h"
-#include "platform/heap/Handle.h"
-#include "wtf/Forward.h"
-#include "wtf/text/WTFString.h"
-
-namespace blink {
-
-class PositionSensorVRDevice final : public VRDevice {
-    DEFINE_WRAPPERTYPEINFO();
-public:
-    PositionSensorVRDevice(VRHardwareUnit*, unsigned);
-
-    VRPositionState* getState();
-    VRPositionState* getImmediateState();
-    void resetSensor();
-
-    DECLARE_VIRTUAL_TRACE();
-};
-
-} // namespace blink
-
-#endif // PositionSensorVRDevice_h
diff --git a/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.idl b/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.idl
deleted file mode 100644
index ecd70d3..0000000
--- a/third_party/WebKit/Source/modules/vr/PositionSensorVRDevice.idl
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-// An PositionSensorVRDevice represents a user interface that provides an
-// orientation and position in space. This may be a Head Mounted Display or
-// any number of other six-degree-of-freedom devices that provide, for example,
-// hand tracking.
-// http://mozvr.github.io/webvr-spec/webvr.html#positionsensorvrdevice
-[
-    RuntimeEnabled=WebVR,
-] interface PositionSensorVRDevice : VRDevice {
-    VRPositionState getState();
-    VRPositionState getImmediateState();
-    void resetSensor();
-};
diff --git a/third_party/WebKit/Source/modules/vr/VRController.cpp b/third_party/WebKit/Source/modules/vr/VRController.cpp
index 543ee14..8d0f3e4 100644
--- a/third_party/WebKit/Source/modules/vr/VRController.cpp
+++ b/third_party/WebKit/Source/modules/vr/VRController.cpp
@@ -18,12 +18,12 @@ void VRController::provideTo(LocalFrame& frame, WebVRClient* client)
     ASSERT(RuntimeEnabledFeatures::webVREnabled());
 
     VRController* controller = new VRController(frame, client);
-    WillBeHeapSupplement<LocalFrame>::provideTo(frame, supplementName(), adoptPtrWillBeNoop(controller));
+    HeapSupplement<LocalFrame>::provideTo(frame, supplementName(), controller);
 }
 
 VRController* VRController::from(LocalFrame& frame)
 {
-    return static_cast<VRController*>(WillBeHeapSupplement<LocalFrame>::from(frame, supplementName()));
+    return static_cast<VRController*>(HeapSupplement<LocalFrame>::from(frame, supplementName()));
 }
 
 VRController::VRController(LocalFrame& frame, WebVRClient* client)
@@ -50,20 +50,20 @@ void VRController::getDevices(WebVRGetDevicesCallback* callback)
     m_client->getDevices(callback);
 }
 
-void VRController::getSensorState(unsigned index, WebHMDSensorState& into)
+void VRController::getPose(unsigned index, WebVRPose& into)
 {
     // When detached, the client is no longer valid.
     if (!m_client)
         return;
-    m_client->getSensorState(index, into);
+    m_client->getPose(index, into);
 }
 
-void VRController::resetSensor(unsigned index)
+void VRController::resetPose(unsigned index)
 {
     // When detached, the client is no longer valid.
     if (!m_client)
         return;
-    m_client->resetSensor(index);
+    m_client->resetPose(index);
 }
 
 void VRController::willDetachFrameHost()
@@ -73,7 +73,7 @@ void VRController::willDetachFrameHost()
 
 DEFINE_TRACE(VRController)
 {
-    WillBeHeapSupplement<LocalFrame>::trace(visitor);
+    HeapSupplement<LocalFrame>::trace(visitor);
     LocalFrameLifecycleObserver::trace(visitor);
 }
 
diff --git a/third_party/WebKit/Source/modules/vr/VRController.h b/third_party/WebKit/Source/modules/vr/VRController.h
index fed11d5..b0e8387 100644
--- a/third_party/WebKit/Source/modules/vr/VRController.h
+++ b/third_party/WebKit/Source/modules/vr/VRController.h
@@ -14,19 +14,19 @@
 namespace blink {
 
 class MODULES_EXPORT VRController final
-    : public NoBaseWillBeGarbageCollectedFinalized<VRController>
-    , public WillBeHeapSupplement<LocalFrame>
+    : public GarbageCollectedFinalized<VRController>
+    , public HeapSupplement<LocalFrame>
     , public LocalFrameLifecycleObserver {
-    WILL_BE_USING_GARBAGE_COLLECTED_MIXIN(VRController);
+    USING_GARBAGE_COLLECTED_MIXIN(VRController);
     WTF_MAKE_NONCOPYABLE(VRController);
 public:
     virtual ~VRController();
 
     void getDevices(WebVRGetDevicesCallback*);
 
-    void getSensorState(unsigned index, WebHMDSensorState& into);
+    void getPose(unsigned index, WebVRPose& into);
 
-    void resetSensor(unsigned index);
+    void resetPose(unsigned index);
 
     static void provideTo(LocalFrame&, WebVRClient*);
     static VRController* from(LocalFrame&);
diff --git a/third_party/WebKit/Source/modules/vr/VRDevice.cpp b/third_party/WebKit/Source/modules/vr/VRDevice.cpp
deleted file mode 100644
index 0c22307..0000000
--- a/third_party/WebKit/Source/modules/vr/VRDevice.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "modules/vr/VRDevice.h"
-
-namespace blink {
-
-VRDevice::~VRDevice()
-{
-}
-
-VRDevice::VRDevice(VRHardwareUnit* hardwareUnit, unsigned deviceId)
-    : m_hardwareUnit(hardwareUnit)
-    , m_deviceId(String::number(deviceId))
-{
-}
-
-void VRDevice::updateFromWebVRDevice(const WebVRDevice& device)
-{
-    m_deviceName = device.deviceName;
-}
-
-DEFINE_TRACE(VRDevice)
-{
-    visitor->trace(m_hardwareUnit);
-}
-
-} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRDevice.h b/third_party/WebKit/Source/modules/vr/VRDevice.h
deleted file mode 100644
index 78ba3ea..0000000
--- a/third_party/WebKit/Source/modules/vr/VRDevice.h
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef VRDevice_h
-#define VRDevice_h
-
-#include "bindings/core/v8/ScriptWrappable.h"
-#include "modules/vr/VRHardwareUnit.h"
-#include "platform/heap/Handle.h"
-#include "wtf/Forward.h"
-#include "wtf/text/WTFString.h"
-
-namespace blink {
-
-class VRController;
-
-class VRDevice : public GarbageCollectedFinalized<VRDevice>, public ScriptWrappable {
-    DEFINE_WRAPPERTYPEINFO();
-public:
-    virtual ~VRDevice();
-
-    unsigned index() const { return m_hardwareUnit->index(); }
-    const String& hardwareUnitId() const { return m_hardwareUnit->hardwareUnitId(); }
-    const String& deviceId() const { return m_deviceId; }
-    const String& deviceName() const { return m_deviceName; }
-
-    VRHardwareUnit* hardwareUnit() { return m_hardwareUnit; }
-    const VRHardwareUnit* hardwareUnit() const { return m_hardwareUnit; }
-
-    VRController* controller() { return m_hardwareUnit->controller(); }
-
-    virtual void updateFromWebVRDevice(const WebVRDevice&);
-
-    DECLARE_VIRTUAL_TRACE();
-
-protected:
-    VRDevice(VRHardwareUnit*, unsigned);
-
-private:
-    Member<VRHardwareUnit> m_hardwareUnit;
-    String m_deviceId;
-    String m_deviceName;
-};
-
-using VRDeviceVector = HeapVector<Member<VRDevice>>;
-
-} // namespace blink
-
-#endif // VRDevice_h
diff --git a/third_party/WebKit/Source/modules/vr/VRDevice.idl b/third_party/WebKit/Source/modules/vr/VRDevice.idl
deleted file mode 100644
index 9bb4610..0000000
--- a/third_party/WebKit/Source/modules/vr/VRDevice.idl
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-// http://mozvr.github.io/webvr-spec/webvr.html#vrdevice
-[
-    RuntimeEnabled=WebVR,
-    GarbageCollected,
-] interface VRDevice {
-    // An identifier for the distinct hardware unit that this
-    // VR Device is a part of.  All VRDevice/Sensors that come
-    // from the same hardware will have the same hardwareId.
-    readonly attribute DOMString hardwareUnitId;
-
-    // An identifier for this distinct sensor/device on a physical
-    // hardware device.  This shouldn't change across browser
-    // restrats, allowing configuration data to be saved based on it.
-    readonly attribute DOMString deviceId;
-
-    // A user-readable name identifying the device.
-    readonly attribute DOMString deviceName;
-};
diff --git a/third_party/WebKit/Source/modules/vr/VRDisplay.cpp b/third_party/WebKit/Source/modules/vr/VRDisplay.cpp
new file mode 100644
index 0000000..e508c39
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRDisplay.cpp
@@ -0,0 +1,364 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "modules/vr/VRDisplay.h"
+
+#include "core/dom/DOMException.h"
+#include "core/dom/Fullscreen.h"
+#include "core/inspector/ConsoleMessage.h"
+#include "gpu/command_buffer/client/gles2_interface.h"
+#include "modules/vr/NavigatorVR.h"
+#include "modules/vr/VRController.h"
+#include "modules/vr/VRDisplayCapabilities.h"
+#include "modules/vr/VREyeParameters.h"
+#include "modules/vr/VRLayer.h"
+#include "modules/vr/VRPose.h"
+#include "modules/vr/VRStageParameters.h"
+#include "modules/webgl/WebGLRenderingContextBase.h"
+#include "public/platform/Platform.h"
+#include "public/platform/WebGraphicsContext3D.h"
+#include "public/platform/WebGraphicsContext3DProvider.h"
+
+namespace blink {
+
+namespace {
+
+VREye stringToVREye(const String& whichEye)
+{
+    if (whichEye == "left")
+        return VREyeLeft;
+    if (whichEye == "right")
+        return VREyeRight;
+    return VREyeNone;
+}
+
+} // namepspace
+
+VRDisplay::VRDisplay(NavigatorVR* navigatorVR)
+    : m_navigatorVR(navigatorVR)
+    , m_displayId(0)
+    , m_isConnected(false)
+    , m_canUpdateFramePose(true)
+    , m_capabilities(new VRDisplayCapabilities())
+    , m_eyeParametersLeft(new VREyeParameters())
+    , m_eyeParametersRight(new VREyeParameters())
+{
+}
+
+VRDisplay::~VRDisplay()
+{
+    gpu::gles2::GLES2Interface* sharedContext = getCompositingContext();
+    if (sharedContext && m_compositorHandle) {
+        sharedContext->DeleteVRCompositorCHROMIUM(m_compositorHandle);
+    }
+}
+
+VRController* VRDisplay::controller()
+{
+    return m_navigatorVR->controller();
+}
+
+void VRDisplay::updateFromWebVRDevice(const WebVRDevice& device)
+{
+    m_displayId = device.index;
+    m_displayName = device.deviceName;
+    m_compositorType = device.deviceCompositorType;
+    m_isConnected = true;
+
+    m_capabilities->update(device.capabilities);
+    m_eyeParametersLeft->update(device.leftEye);
+    m_eyeParametersRight->update(device.rightEye);
+
+    if (!device.stageParameters.isNull) {
+        if (!m_stageParameters)
+            m_stageParameters = new VRStageParameters();
+        m_stageParameters->update(device.stageParameters);
+    } else {
+        m_stageParameters = nullptr;
+    }
+}
+
+VRPose* VRDisplay::getPose()
+{
+    if (m_canUpdateFramePose) {
+        m_framePose = getImmediatePose();
+        Platform::current()->currentThread()->addTaskObserver(this);
+        m_canUpdateFramePose = false;
+    }
+
+    return m_framePose;
+}
+
+VRPose* VRDisplay::getImmediatePose()
+{
+    WebVRPose webPose;
+    controller()->getPose(m_displayId, webPose);
+
+    VRPose* pose = VRPose::create();
+    pose->setPose(webPose);
+    return pose;
+}
+
+void VRDisplay::resetPose()
+{
+    controller()->resetPose(m_displayId);
+
+    if (m_compositorHandle) {
+        gpu::gles2::GLES2Interface* sharedContext = getCompositingContext();
+        if (sharedContext)
+            sharedContext->ResetVRCompositorPoseCHROMIUM(m_compositorHandle);
+    }
+}
+
+VREyeParameters* VRDisplay::getEyeParameters(const String& whichEye)
+{
+    switch (stringToVREye(whichEye)) {
+    case VREyeLeft:
+        return m_eyeParametersLeft;
+    case VREyeRight:
+        return m_eyeParametersRight;
+    default:
+        return nullptr;
+    }
+}
+
+int VRDisplay::requestAnimationFrame(FrameRequestCallback* callback)
+{
+    // TODO: Use HMD-specific rAF when an external display is present.
+    callback->m_useLegacyTimeBase = false;
+    if (Document* doc = m_navigatorVR->document())
+        return doc->requestAnimationFrame(callback);
+    return 0;
+}
+
+void VRDisplay::cancelAnimationFrame(int id)
+{
+    if (Document* document = m_navigatorVR->document())
+        document->cancelAnimationFrame(id);
+}
+
+gpu::gles2::GLES2Interface* VRDisplay::getCompositingContext() {
+    if (!m_contextProvider)
+        m_contextProvider = adoptPtr(Platform::current()->createSharedOffscreenGraphicsContext3DProvider());
+
+    gpu::gles2::GLES2Interface* sharedContext = nullptr;
+    if (m_contextProvider) {
+        sharedContext = m_contextProvider->contextGL();
+
+        if (!sharedContext)
+            return nullptr;
+    }
+
+    return sharedContext;
+}
+
+ScriptPromise VRDisplay::requestPresent(ScriptState* scriptState, const VRLayer& layer)
+{
+    static bool didPrintDeprecationWarning = false;
+    if (!didPrintDeprecationWarning) {
+        Document* document = m_navigatorVR->document();
+        if (document) {
+            document->addConsoleMessage(ConsoleMessage::create(RenderingMessageSource, WarningMessageLevel, "Using a deprecated form of requestPresent. Should pass in an array of VRLayers."));
+            didPrintDeprecationWarning = true;
+        }
+    }
+
+    HeapVector<VRLayer> layers;
+    layers.append(layer);
+    return requestPresent(scriptState, layers);
+}
+
+ScriptPromise VRDisplay::requestPresent(ScriptState* scriptState, const HeapVector<VRLayer>& layers)
+{
+    ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
+    ScriptPromise promise = resolver->promise();
+
+    m_context = nullptr;
+    m_isPresenting = false;
+
+    if (!m_capabilities->canPresent()) {
+        DOMException* exception = DOMException::create(InvalidStateError, "VRDisplay cannot present");
+        resolver->reject(exception);
+        return promise;
+    }
+
+    if (layers.size() == 0 || layers.size() > m_capabilities->maxLayers()) {
+        DOMException* exception = DOMException::create(InvalidStateError, "Invalid number of layers.");
+        if (m_isPresenting) { exitPresent(scriptState); }
+        resolver->reject(exception);
+        return promise;
+    }
+
+    m_layer = layers[0];
+
+    if (m_layer.source() != nullptr) {
+        // On devices without an external VR display just make the canvas
+        // fullscreen for now. It's a major hack, but it works for a POC.
+        if (!m_capabilities->hasExternalDisplay()) {
+            Fullscreen::from(m_layer.source()->document()).requestFullscreen(*(m_layer.source()), Fullscreen::UnprefixedRequest);
+            m_isPresenting = true;
+            // TODO: Listen for fullscreen exit by the UA.
+            resolver->resolve();
+
+            m_navigatorVR->fireVRDisplayPresentChange();
+        } else {
+            CanvasRenderingContext* renderingContext = m_layer.source()->renderingContext();
+
+            if (!renderingContext || !renderingContext->is3d()) {
+                DOMException* exception = DOMException::create(InvalidStateError, "Layer source must have a WebGLRenderingContext");
+                resolver->reject(exception);
+            } else {
+                m_context = toWebGLRenderingContextBase(renderingContext);
+
+                gpu::gles2::GLES2Interface* sharedContext = getCompositingContext();
+                if (!sharedContext) {
+                    DOMException* exception = DOMException::create(InvalidStateError, "Unable to acquire shared context");
+                    if (m_isPresenting) { exitPresent(scriptState); }
+                    resolver->reject(exception);
+                } else {
+                    m_compositorHandle = sharedContext->CreateVRCompositorCHROMIUM(static_cast<GLenum>(m_compositorType));
+
+                    if (!m_compositorHandle) {
+                        DOMException* exception = DOMException::create(InvalidStateError, "Unable to create VR compositor");
+                        if (m_isPresenting) { exitPresent(scriptState); }
+                        resolver->reject(exception);
+                    } else {
+
+                        if (m_layer.hasLeftBounds()) {
+                            sharedContext->VRCompositorTextureBoundsCHROMIUM(m_compositorHandle, 0, // Left Eye
+                                m_layer.leftBounds()[0], m_layer.leftBounds()[1], m_layer.leftBounds()[2], m_layer.leftBounds()[3]);
+                        }
+
+                        if (m_layer.hasRightBounds()) {
+                            sharedContext->VRCompositorTextureBoundsCHROMIUM(m_compositorHandle, 1, // Right Eye
+                                m_layer.rightBounds()[0], m_layer.rightBounds()[1], m_layer.rightBounds()[2], m_layer.rightBounds()[3]);
+                        }
+
+                        m_isPresenting = true;
+                        // TODO: Resolve when presentation is confirmed
+                        resolver->resolve();
+
+                        m_navigatorVR->fireVRDisplayPresentChange();
+
+#if defined(WEBVR_USE_OCULUS)
+                        // FIXME: This is terrible. :(
+                        resetPose();
+#endif
+                    }
+                }
+            }
+        }
+    } else {
+        // TODO: Resolve when presentation is confirmed
+        resolver->resolve();
+    }
+
+    // TODO: Begin presenting!
+
+    return promise;
+}
+
+ScriptPromise VRDisplay::exitPresent(ScriptState* scriptState)
+{
+    ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
+    ScriptPromise promise = resolver->promise();
+
+    if (!m_isPresenting) {
+        // Can't stop presenting if we're not presenting.
+        DOMException* exception = DOMException::create(InvalidStateError, "VRDisplay is not presenting");
+        resolver->reject(exception);
+        return promise;
+    }
+
+    if (!m_capabilities->hasExternalDisplay()) {
+        Fullscreen::fullyExitFullscreen(m_layer.source()->document());
+    } else {
+        gpu::gles2::GLES2Interface* sharedContext = getCompositingContext();
+        if (sharedContext && m_compositorHandle) {
+            sharedContext->DeleteVRCompositorCHROMIUM(m_compositorHandle);
+        }
+    }
+
+    m_context = nullptr;
+    m_contextProvider = nullptr;
+    m_compositorHandle = 0;
+    m_isPresenting = false;
+
+    // TODO: Resolve when exit is confirmed
+    resolver->resolve();
+
+    m_navigatorVR->fireVRDisplayPresentChange();
+
+    return promise;
+}
+
+HeapVector<VRLayer> VRDisplay::getLayers()
+{
+    HeapVector<VRLayer> layers;
+
+    if (m_isPresenting) {
+        layers.append(m_layer);
+    }
+
+    return layers;
+}
+
+void VRDisplay::submitFrame(VRPose* pose)
+{
+    if (!pose) {
+        pose = m_framePose;
+    }
+
+    if (m_context && m_compositorHandle) {
+        gpu::gles2::GLES2Interface* sharedContext = getCompositingContext();
+        if (!sharedContext)
+            return;
+
+        // TODO: Should be able to more directly submit from here if we can
+        // figure out how to do so without blocking the compositor.
+        DrawingBuffer* drawingBuffer = m_context->drawingBuffer();
+
+        WebExternalTextureMailbox mailbox;
+        drawingBuffer->prepareMailbox(&mailbox, nullptr);
+        drawingBuffer->markContentsChanged();
+
+        if (mailbox.validSyncToken)
+            sharedContext->WaitSyncTokenCHROMIUM(mailbox.syncToken);
+        GLuint vrSourceTexture = sharedContext->CreateAndConsumeTextureCHROMIUM(mailbox.textureTarget, mailbox.name);
+
+        sharedContext->SubmitVRCompositorFrameCHROMIUM(
+            m_compositorHandle, vrSourceTexture,
+            pose->orientation()->data()[0],
+            pose->orientation()->data()[1],
+            pose->orientation()->data()[2],
+            pose->orientation()->data()[3]);
+
+        sharedContext->Flush();
+
+        drawingBuffer->mailboxReleased(mailbox, false);
+    }
+}
+
+void VRDisplay::didProcessTask()
+{
+    // Pose should be stable until control is returned to the user agent.
+    if (!m_canUpdateFramePose) {
+        Platform::current()->currentThread()->removeTaskObserver(this);
+        m_canUpdateFramePose = true;
+    }
+}
+
+DEFINE_TRACE(VRDisplay)
+{
+    visitor->trace(m_navigatorVR);
+    visitor->trace(m_capabilities);
+    visitor->trace(m_stageParameters);
+    visitor->trace(m_eyeParametersLeft);
+    visitor->trace(m_eyeParametersRight);
+    visitor->trace(m_framePose);
+    visitor->trace(m_layer);
+    visitor->trace(m_context);
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRDisplay.h b/third_party/WebKit/Source/modules/vr/VRDisplay.h
new file mode 100644
index 0000000..ac93a61
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRDisplay.h
@@ -0,0 +1,113 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef VRDisplay_h
+#define VRDisplay_h
+
+#include "bindings/core/v8/ScriptWrappable.h"
+#include "core/dom/Document.h"
+#include "core/dom/FrameRequestCallback.h"
+#include "modules/vr/VRDisplayCapabilities.h"
+#include "modules/vr/VRLayer.h"
+#include "platform/heap/Handle.h"
+#include "public/platform/WebGraphicsContext3DProvider.h"
+#include "public/platform/WebThread.h"
+#include "public/platform/modules/vr/WebVR.h"
+#include "wtf/Forward.h"
+#include "wtf/text/WTFString.h"
+
+namespace gpu {
+namespace gles2 {
+class GLES2Interface;
+}
+}
+
+namespace blink {
+
+class NavigatorVR;
+class VRController;
+class VREyeParameters;
+class VRStageParameters;
+class VRPose;
+
+class WebGLRenderingContextBase;
+
+enum VREye {
+    VREyeNone,
+    VREyeLeft,
+    VREyeRight
+};
+
+class VRDisplay final : public GarbageCollectedFinalized<VRDisplay>, public ScriptWrappable, public WebThread::TaskObserver {
+    DEFINE_WRAPPERTYPEINFO();
+public:
+    ~VRDisplay();
+
+    unsigned displayId() const { return m_displayId; }
+    const String& displayName() const { return m_displayName; }
+
+    VRDisplayCapabilities* capabilities() const { return m_capabilities; }
+    VRStageParameters* stageParameters() const { return m_stageParameters; }
+
+    bool isConnected() const { return m_isConnected; }
+    bool isPresenting() const { return m_isPresenting; }
+
+    VRPose* getPose();
+    VRPose* getImmediatePose();
+    void resetPose();
+
+    VREyeParameters* getEyeParameters(const String&);
+
+    int requestAnimationFrame(FrameRequestCallback*);
+    void cancelAnimationFrame(int id);
+
+    ScriptPromise requestPresent(ScriptState*, const HeapVector<VRLayer>& layers);
+    ScriptPromise requestPresent(ScriptState*, const VRLayer& layer);
+    ScriptPromise exitPresent(ScriptState*);
+
+    HeapVector<VRLayer> getLayers();
+
+    void submitFrame(VRPose* pose);
+
+    DECLARE_VIRTUAL_TRACE();
+
+protected:
+    friend class VRDisplayCollection;
+
+    VRDisplay(NavigatorVR*);
+
+    void updateFromWebVRDevice(const WebVRDevice&);
+
+    gpu::gles2::GLES2Interface* getCompositingContext();
+
+    VRController* controller();
+
+private:
+    // TaskObserver implementation.
+    void didProcessTask() override;
+    void willProcessTask() override { }
+
+    Member<NavigatorVR> m_navigatorVR;
+    unsigned m_displayId;
+    String m_displayName;
+    WebVRCompositorType m_compositorType;
+    bool m_isConnected;
+    bool m_isPresenting;
+    bool m_canUpdateFramePose;
+    unsigned m_compositorHandle;
+    Member<VRDisplayCapabilities> m_capabilities;
+    Member<VRStageParameters> m_stageParameters;
+    Member<VREyeParameters> m_eyeParametersLeft;
+    Member<VREyeParameters> m_eyeParametersRight;
+    Member<VRPose> m_framePose;
+    VRLayer m_layer;
+    OwnPtr<WebGraphicsContext3DProvider> m_contextProvider;
+    Member<WebGLRenderingContextBase> m_context;
+};
+
+using VRDisplayVector = HeapVector<Member<VRDisplay>>;
+
+} // namespace blink
+
+#endif // VRDisplay_h
diff --git a/third_party/WebKit/Source/modules/vr/VRDisplay.idl b/third_party/WebKit/Source/modules/vr/VRDisplay.idl
new file mode 100644
index 0000000..f31e8ac
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRDisplay.idl
@@ -0,0 +1,55 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+enum VREye {
+    "left",
+    "right"
+};
+
+// http://mozvr.github.io/webvr-spec/webvr.html#vrdisplay
+[
+    RuntimeEnabled=WebVR,
+    GarbageCollected
+] interface VRDisplay {
+    // An identifier for this device unique across VRDisplays.
+    readonly attribute unsigned long displayId;
+
+    // A user-readable name identifying the device.
+    readonly attribute DOMString displayName;
+
+    readonly attribute boolean isConnected;
+    readonly attribute boolean isPresenting;
+
+    // [Constant]?
+    readonly attribute VRDisplayCapabilities capabilities;
+
+    readonly attribute VRStageParameters stageParameters;
+
+    VRPose getPose();
+    VRPose getImmediatePose();
+    void resetPose();
+
+    VREyeParameters getEyeParameters(VREye whichEye);
+
+    long requestAnimationFrame(FrameRequestCallback callback);
+    void cancelAnimationFrame(long handle);
+
+    // Begin presenting to the VRDisplay. Must be called in response to a user gesture.
+    // Repeat calls while already presenting will update the VRLayer being displayed.
+    [CallWith=ScriptState] Promise requestPresent(sequence<VRLayer> layers);
+    [CallWith=ScriptState] Promise requestPresent(VRLayer layer); // Deprecated
+
+
+    // Stops presenting to the VRDisplay.
+    [CallWith=ScriptState] Promise exitPresent();
+
+    // Get the sources currently being presented.
+    sequence<VRLayer> getLayers();
+
+    // The VRLayer provided to the `VRDisplay` will be captured and presented
+    // in the HMD. Calling this function has the same effect on the source
+    // canvas as any other operation that uses its source image, and canvases
+    // created without preserveDrawingBuffer set to true will be cleared.
+    void submitFrame(optional VRPose pose = null);
+};
diff --git a/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.cpp b/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.cpp
new file mode 100644
index 0000000..6474f10
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.cpp
@@ -0,0 +1,31 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "modules/vr/VRDisplayCapabilities.h"
+
+namespace blink {
+
+VRDisplayCapabilities::VRDisplayCapabilities()
+    : m_hasOriention(false)
+    , m_hasPosition(false)
+    , m_hasExternalDisplay(false)
+    , m_canPresent(false)
+{
+}
+
+void VRDisplayCapabilities::update(const WebVRDisplayCapabilities& capabilities)
+{
+  m_hasOriention = capabilities.hasOrientation;
+  m_hasPosition = capabilities.hasPosition;
+  m_hasExternalDisplay = capabilities.hasExternalDisplay;
+  m_canPresent = capabilities.canPresent;
+  m_maxLayers = m_canPresent ? 1 : 0;
+}
+
+DEFINE_TRACE(VRDisplayCapabilities)
+{
+
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.h b/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.h
new file mode 100644
index 0000000..00dae5d
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.h
@@ -0,0 +1,40 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef VRDisplayCapabilities_h
+#define VRDisplayCapabilities_h
+
+#include "bindings/core/v8/ScriptWrappable.h"
+#include "platform/heap/Handle.h"
+#include "public/platform/modules/vr/WebVR.h"
+#include "wtf/Forward.h"
+
+namespace blink {
+
+class VRDisplayCapabilities final : public GarbageCollectedFinalized<VRDisplayCapabilities>, public ScriptWrappable {
+    DEFINE_WRAPPERTYPEINFO();
+public:
+    VRDisplayCapabilities();
+
+    bool hasOrientation() const { return m_hasOriention; }
+    bool hasPosition() const { return m_hasPosition; }
+    bool hasExternalDisplay() const { return m_hasExternalDisplay; }
+    bool canPresent() const { return m_canPresent; }
+    unsigned maxLayers() const { return m_maxLayers; }
+
+    void update(const WebVRDisplayCapabilities&);
+
+    DECLARE_VIRTUAL_TRACE()
+
+private:
+    bool m_hasOriention;
+    bool m_hasPosition;
+    bool m_hasExternalDisplay;
+    bool m_canPresent;
+    unsigned m_maxLayers;
+};
+
+} // namespace blink
+
+#endif // VRDisplayCapabilities_h
diff --git a/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.idl b/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.idl
new file mode 100644
index 0000000..27cf0fd
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRDisplayCapabilities.idl
@@ -0,0 +1,32 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// http://mozvr.github.io/webvr-spec/webvr.html#vrdisplaycapabilities
+[
+    RuntimeEnabled=WebVR,
+    GarbageCollected
+] interface VRDisplayCapabilities {
+  // Whether or not the VR display is capable of reporting user orientation.
+  readonly attribute boolean hasOrientation;
+
+  // Whether or not the VR display is capable of reporting user position.
+  // If false position may still be reported using simulated values like
+  // neck modeling.
+  readonly attribute boolean hasPosition;
+
+  // Whether or not the VRDisplay is separate from the device’s primary display.
+  // If presenting VR content will obscure other content on the device, this
+  // should be false. When false VR content should not be mirrored.
+  readonly attribute boolean hasExternalDisplay;
+
+  // Whether or not the VRDisplay is capable of presenting content to an HMD or
+  // similar device. Can be used to indicate “magic window” devices that are
+  // capable of 6DoF tracking but for which requestPresent is not meaningful. If
+  // false then calls to requestPresent should always fail, and getEyeParameters
+  // should return null.
+  readonly attribute boolean canPresent;
+
+  // The maximum length of the array that VRDisplay.requestPresent will accept.
+  readonly attribute unsigned long maxLayers;
+};
\ No newline at end of file
diff --git a/third_party/WebKit/Source/modules/vr/VRDisplayCollection.cpp b/third_party/WebKit/Source/modules/vr/VRDisplayCollection.cpp
new file mode 100644
index 0000000..4a8e399
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRDisplayCollection.cpp
@@ -0,0 +1,53 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "modules/vr/VRDisplayCollection.h"
+
+#include "modules/vr/NavigatorVR.h"
+
+namespace blink {
+
+VRDisplayCollection::VRDisplayCollection(NavigatorVR* navigatorVR)
+    : m_navigatorVR(navigatorVR)
+{
+}
+
+VRDisplayVector VRDisplayCollection::updateDisplays(const WebVector<WebVRDevice>& devices)
+{
+    VRDisplayVector vrDevices;
+
+    for (const auto& device : devices) {
+        VRDisplay* display = getDisplayForIndex(device.index);
+        if (!display) {
+            display = new VRDisplay(m_navigatorVR);
+            m_displays.append(display);
+        }
+
+        display->updateFromWebVRDevice(device);
+        vrDevices.append(display);
+    }
+
+    return vrDevices;
+}
+
+VRDisplay* VRDisplayCollection::getDisplayForIndex(unsigned index)
+{
+    VRDisplay* display;
+    for (size_t i = 0; i < m_displays.size(); ++i) {
+        display = m_displays[i];
+        if (display->displayId() == index) {
+            return display;
+        }
+    }
+
+    return 0;
+}
+
+DEFINE_TRACE(VRDisplayCollection)
+{
+    visitor->trace(m_navigatorVR);
+    visitor->trace(m_displays);
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRDisplayCollection.h b/third_party/WebKit/Source/modules/vr/VRDisplayCollection.h
new file mode 100644
index 0000000..925f5bd
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRDisplayCollection.h
@@ -0,0 +1,32 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef VRDisplayCollection_h
+#define VRDisplayCollection_h
+
+#include "modules/vr/VRDisplay.h"
+#include "platform/heap/Handle.h"
+#include "public/platform/WebVector.h"
+
+namespace blink {
+
+struct WebVRDevice;
+
+class VRDisplayCollection final : public GarbageCollected<VRDisplayCollection> {
+public:
+    explicit VRDisplayCollection(NavigatorVR*);
+
+    VRDisplayVector updateDisplays(const WebVector<WebVRDevice>&);
+    VRDisplay* getDisplayForIndex(unsigned index);
+
+    DECLARE_VIRTUAL_TRACE();
+
+private:
+    Member<NavigatorVR> m_navigatorVR;
+    HeapVector<Member<VRDisplay>> m_displays;
+};
+
+} // namespace blink
+
+#endif // VRDisplayCollection_h
diff --git a/third_party/WebKit/Source/modules/vr/VREyeParameters.cpp b/third_party/WebKit/Source/modules/vr/VREyeParameters.cpp
index f886177..499a80f 100644
--- a/third_party/WebKit/Source/modules/vr/VREyeParameters.cpp
+++ b/third_party/WebKit/Source/modules/vr/VREyeParameters.cpp
@@ -3,54 +3,40 @@
 // found in the LICENSE file.
 
 #include "modules/vr/VREyeParameters.h"
+#include "public/platform/modules/vr/WebVR.h"
 
 namespace blink {
 
 namespace {
 
-void setDomPoint(DOMPoint* point, const WebVRVector3& vec)
+void setVecToFloat32Array(DOMFloat32Array* out, const WebVRVector3& vec)
 {
-    point->setX(vec.x);
-    point->setY(vec.y);
-    point->setZ(vec.z);
-    point->setW(1.0);
+    out->data()[0] = vec.x;
+    out->data()[1] = vec.y;
+    out->data()[2] = vec.z;
 }
 
 } // namespace
 
 VREyeParameters::VREyeParameters()
 {
-    m_minimumFieldOfView = new VRFieldOfView();
-    m_maximumFieldOfView = new VRFieldOfView();
-    m_recommendedFieldOfView = new VRFieldOfView();
-    m_eyeTranslation = DOMPoint::create(0, 0, 0, 0);
-
-    m_currentFieldOfView = new VRFieldOfView();
-    m_renderRect = DOMRect::create(0, 0, 0, 0);
+    m_offset = DOMFloat32Array::create(3);
+    m_fieldOfView = new VRFieldOfView();
+    m_renderWidth = 0;
+    m_renderHeight = 0;
 }
 
-void VREyeParameters::setFromWebVREyeParameters(const WebVREyeParameters &state)
+void VREyeParameters::update(const WebVREyeParameters &eye_parameters)
 {
-    // FIXME: We should expose proper min/max FOV eventually but for now set the
-    // min/max equal to the recommended FOV to reduce need for synchronous
-    // queries and reduce rendering complexity.
-    m_minimumFieldOfView->setFromWebVRFieldOfView(state.recommendedFieldOfView);
-    m_maximumFieldOfView->setFromWebVRFieldOfView(state.recommendedFieldOfView);
-    m_recommendedFieldOfView->setFromWebVRFieldOfView(state.recommendedFieldOfView);
-    setDomPoint(m_eyeTranslation, state.eyeTranslation);
-
-    m_currentFieldOfView->setFromWebVRFieldOfView(state.recommendedFieldOfView);
-    m_renderRect = DOMRect::create(state.renderRect.x, state.renderRect.y, state.renderRect.width, state.renderRect.height);
+    setVecToFloat32Array(m_offset.get(), eye_parameters.offset);
+    m_fieldOfView->setFromWebVRFieldOfView(eye_parameters.fieldOfView);
+    m_renderWidth = eye_parameters.renderWidth;
+    m_renderHeight = eye_parameters.renderHeight;
 }
 
 DEFINE_TRACE(VREyeParameters)
 {
-    visitor->trace(m_minimumFieldOfView);
-    visitor->trace(m_maximumFieldOfView);
-    visitor->trace(m_recommendedFieldOfView);
-    visitor->trace(m_eyeTranslation);
-    visitor->trace(m_currentFieldOfView);
-    visitor->trace(m_renderRect);
+    visitor->trace(m_fieldOfView);
 }
 
 } // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VREyeParameters.h b/third_party/WebKit/Source/modules/vr/VREyeParameters.h
index eea6c56..f3903c2 100644
--- a/third_party/WebKit/Source/modules/vr/VREyeParameters.h
+++ b/third_party/WebKit/Source/modules/vr/VREyeParameters.h
@@ -6,44 +6,35 @@
 #define VREyeParameters_h
 
 #include "bindings/core/v8/ScriptWrappable.h"
-#include "core/dom/DOMPoint.h"
-#include "core/dom/DOMRect.h"
+#include "core/dom/DOMTypedArray.h"
 #include "modules/vr/VRFieldOfView.h"
 #include "platform/heap/Handle.h"
-#include "public/platform/modules/vr/WebVR.h"
+
 #include "wtf/Forward.h"
 
 namespace blink {
 
-class VREyeParameters final : public GarbageCollected<VREyeParameters>, public ScriptWrappable {
+struct WebVREyeParameters;
+
+class VREyeParameters final : public GarbageCollectedFinalized<VREyeParameters>, public ScriptWrappable {
     DEFINE_WRAPPERTYPEINFO();
 public:
-    static VREyeParameters* create()
-    {
-        return new VREyeParameters();
-    }
+    VREyeParameters();
 
-    VRFieldOfView* minimumFieldOfView() const { return m_minimumFieldOfView; }
-    VRFieldOfView* maximumFieldOfView() const { return m_maximumFieldOfView; }
-    VRFieldOfView* recommendedFieldOfView() const { return m_recommendedFieldOfView; }
-    DOMPoint* eyeTranslation() const { return m_eyeTranslation; }
-    VRFieldOfView* currentFieldOfView() const { return m_currentFieldOfView; }
-    DOMRect* renderRect() const { return m_renderRect; }
+    PassRefPtr<DOMFloat32Array> offset() const { return m_offset; }
+    VRFieldOfView* fieldOfView() const { return m_fieldOfView; }
+    unsigned long renderWidth() const { return m_renderWidth; }
+    unsigned long renderHeight() const { return m_renderHeight; }
 
-    void setFromWebVREyeParameters(const WebVREyeParameters&);
+    void update(const WebVREyeParameters&);
 
     DECLARE_VIRTUAL_TRACE()
 
 private:
-    VREyeParameters();
-
-    Member<VRFieldOfView> m_minimumFieldOfView;
-    Member<VRFieldOfView> m_maximumFieldOfView;
-    Member<VRFieldOfView> m_recommendedFieldOfView;
-    Member<DOMPoint> m_eyeTranslation;
-
-    Member<VRFieldOfView> m_currentFieldOfView;
-    Member<DOMRect> m_renderRect;
+    RefPtr<DOMFloat32Array> m_offset;
+    Member<VRFieldOfView> m_fieldOfView;
+    unsigned long m_renderWidth;
+    unsigned long m_renderHeight;
 };
 
 } // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VREyeParameters.idl b/third_party/WebKit/Source/modules/vr/VREyeParameters.idl
index 5a83da5..a971dd7 100644
--- a/third_party/WebKit/Source/modules/vr/VREyeParameters.idl
+++ b/third_party/WebKit/Source/modules/vr/VREyeParameters.idl
@@ -7,13 +7,9 @@
     RuntimeEnabled=WebVR,
     GarbageCollected
 ] interface VREyeParameters {
-  /* These values are expected to be static per-device/per-user */
-  readonly attribute VRFieldOfView minimumFieldOfView;
-  readonly attribute VRFieldOfView maximumFieldOfView;
-  readonly attribute VRFieldOfView recommendedFieldOfView;
-  readonly attribute DOMPoint eyeTranslation;
-
   /* These values will vary after a FOV has been set */
-  readonly attribute VRFieldOfView currentFieldOfView;
-  readonly attribute DOMRect renderRect;
+  readonly attribute Float32Array offset;
+  readonly attribute VRFieldOfView fieldOfView;
+  readonly attribute unsigned long renderWidth;
+  readonly attribute unsigned long renderHeight;
 };
\ No newline at end of file
diff --git a/third_party/WebKit/Source/modules/vr/VRFieldOfView.h b/third_party/WebKit/Source/modules/vr/VRFieldOfView.h
index b684ab0..e539f06 100644
--- a/third_party/WebKit/Source/modules/vr/VRFieldOfView.h
+++ b/third_party/WebKit/Source/modules/vr/VRFieldOfView.h
@@ -14,7 +14,7 @@
 
 namespace blink {
 
-class VRFieldOfView final : public GarbageCollected<VRFieldOfView>, public ScriptWrappable {
+class VRFieldOfView final : public GarbageCollectedFinalized<VRFieldOfView>, public ScriptWrappable {
     DEFINE_WRAPPERTYPEINFO();
 public:
     static VRFieldOfView* create(const VRFieldOfViewInit& fov)
diff --git a/third_party/WebKit/Source/modules/vr/VRFieldOfViewInit.idl b/third_party/WebKit/Source/modules/vr/VRFieldOfViewInit.idl
index 75cac9e..718f6db 100644
--- a/third_party/WebKit/Source/modules/vr/VRFieldOfViewInit.idl
+++ b/third_party/WebKit/Source/modules/vr/VRFieldOfViewInit.idl
@@ -5,7 +5,6 @@
 // http://mozvr.github.io/webvr-spec/webvr.html#vrfieldofview
 [
     RuntimeEnabled=WebVR,
-    GarbageCollected
 ] dictionary VRFieldOfViewInit {
     double upDegrees = 0.0;
     double rightDegrees = 0.0;
diff --git a/third_party/WebKit/Source/modules/vr/VRGetDevicesCallback.cpp b/third_party/WebKit/Source/modules/vr/VRGetDevicesCallback.cpp
index abfe797..83d7e92 100644
--- a/third_party/WebKit/Source/modules/vr/VRGetDevicesCallback.cpp
+++ b/third_party/WebKit/Source/modules/vr/VRGetDevicesCallback.cpp
@@ -5,13 +5,13 @@
 #include "modules/vr/VRGetDevicesCallback.h"
 
 #include "bindings/core/v8/ScriptPromiseResolver.h"
-#include "modules/vr/VRHardwareUnitCollection.h"
+#include "modules/vr/VRDisplayCollection.h"
 
 namespace blink {
 
-VRGetDevicesCallback::VRGetDevicesCallback(ScriptPromiseResolver* resolver, VRHardwareUnitCollection* hardwareUnits)
+VRGetDevicesCallback::VRGetDevicesCallback(ScriptPromiseResolver* resolver, VRDisplayCollection* displays)
     : m_resolver(resolver)
-    , m_hardwareUnits(hardwareUnits)
+    , m_displays(displays)
 {
 }
 
@@ -21,7 +21,7 @@ VRGetDevicesCallback::~VRGetDevicesCallback()
 
 void VRGetDevicesCallback::onSuccess(const WebVector<WebVRDevice>& devices)
 {
-    m_resolver->resolve(m_hardwareUnits->updateVRHardwareUnits(devices));
+    m_resolver->resolve(m_displays->updateDisplays(devices));
 }
 
 void VRGetDevicesCallback::onError()
diff --git a/third_party/WebKit/Source/modules/vr/VRGetDevicesCallback.h b/third_party/WebKit/Source/modules/vr/VRGetDevicesCallback.h
index ef0bff9..4113ab6 100644
--- a/third_party/WebKit/Source/modules/vr/VRGetDevicesCallback.h
+++ b/third_party/WebKit/Source/modules/vr/VRGetDevicesCallback.h
@@ -10,14 +10,14 @@
 
 namespace blink {
 
-class VRHardwareUnitCollection;
+class VRDisplayCollection;
 class ScriptPromiseResolver;
 class WebVRClient;
 
 class VRGetDevicesCallback final : public WebVRGetDevicesCallback {
     USING_FAST_MALLOC(VRGetDevicesCallback);
 public:
-    VRGetDevicesCallback(ScriptPromiseResolver*, VRHardwareUnitCollection*);
+    VRGetDevicesCallback(ScriptPromiseResolver*, VRDisplayCollection*);
     ~VRGetDevicesCallback() override;
 
     void onSuccess(const WebVector<WebVRDevice>&) override;
@@ -25,7 +25,7 @@ public:
 
 private:
     Persistent<ScriptPromiseResolver> m_resolver;
-    Persistent<VRHardwareUnitCollection> m_hardwareUnits;
+    Persistent<VRDisplayCollection> m_displays;
 };
 
 } // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRHardwareUnit.cpp b/third_party/WebKit/Source/modules/vr/VRHardwareUnit.cpp
deleted file mode 100644
index fda64c7..0000000
--- a/third_party/WebKit/Source/modules/vr/VRHardwareUnit.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "modules/vr/VRHardwareUnit.h"
-
-#include "modules/vr/HMDVRDevice.h"
-#include "modules/vr/NavigatorVRDevice.h"
-#include "modules/vr/PositionSensorVRDevice.h"
-#include "modules/vr/VRController.h"
-#include "modules/vr/VRDevice.h"
-#include "public/platform/Platform.h"
-
-namespace blink {
-
-VRHardwareUnit::VRHardwareUnit(NavigatorVRDevice* navigatorVRDevice)
-    : m_nextDeviceId(1)
-    , m_frameIndex(0)
-    , m_navigatorVRDevice(navigatorVRDevice)
-    , m_canUpdatePositionState(true)
-{
-    m_positionState = VRPositionState::create();
-}
-
-VRHardwareUnit::~VRHardwareUnit()
-{
-    if (!m_canUpdatePositionState)
-        Platform::current()->currentThread()->removeTaskObserver(this);
-}
-
-void VRHardwareUnit::updateFromWebVRDevice(const WebVRDevice& device)
-{
-    m_index = device.index;
-    m_hardwareUnitId = String::number(device.index);
-
-    if (device.flags & WebVRDeviceTypeHMD) {
-        if (!m_hmd)
-            m_hmd = new HMDVRDevice(this, m_nextDeviceId++);
-        m_hmd->updateFromWebVRDevice(device);
-    } else if (m_hmd) {
-        m_hmd.clear();
-    }
-
-    if (device.flags & WebVRDeviceTypePosition) {
-        if (!m_positionSensor)
-            m_positionSensor = new PositionSensorVRDevice(this, m_nextDeviceId++);
-        m_positionSensor->updateFromWebVRDevice(device);
-    } else if (m_positionSensor) {
-        m_positionSensor.clear();
-    }
-}
-
-void VRHardwareUnit::addDevicesToVector(HeapVector<Member<VRDevice>>& vrDevices)
-{
-    if (m_hmd)
-        vrDevices.append(m_hmd);
-
-    if (m_positionSensor)
-        vrDevices.append(m_positionSensor);
-}
-
-VRController* VRHardwareUnit::controller()
-{
-    return m_navigatorVRDevice->controller();
-}
-
-VRPositionState* VRHardwareUnit::getSensorState()
-{
-    if (m_canUpdatePositionState) {
-        m_positionState = getImmediateSensorState(true);
-        Platform::current()->currentThread()->addTaskObserver(this);
-        m_canUpdatePositionState = false;
-    }
-
-    return m_positionState;
-}
-
-VRPositionState* VRHardwareUnit::getImmediateSensorState(bool updateFrameIndex)
-{
-    WebHMDSensorState state;
-    controller()->getSensorState(m_index, state);
-    if (updateFrameIndex)
-        m_frameIndex = state.frameIndex;
-
-    VRPositionState* immediatePositionState = VRPositionState::create();
-    immediatePositionState->setState(state);
-    return immediatePositionState;
-}
-
-
-void VRHardwareUnit::didProcessTask()
-{
-    // State should be stable until control is returned to the user agent.
-    if (!m_canUpdatePositionState) {
-        Platform::current()->currentThread()->removeTaskObserver(this);
-        m_canUpdatePositionState = true;
-    }
-}
-
-DEFINE_TRACE(VRHardwareUnit)
-{
-    visitor->trace(m_navigatorVRDevice);
-    visitor->trace(m_positionState);
-    visitor->trace(m_hmd);
-    visitor->trace(m_positionSensor);
-}
-
-} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRHardwareUnit.h b/third_party/WebKit/Source/modules/vr/VRHardwareUnit.h
deleted file mode 100644
index 996513d..0000000
--- a/third_party/WebKit/Source/modules/vr/VRHardwareUnit.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef VRHardwareUnit_h
-#define VRHardwareUnit_h
-
-#include "modules/vr/VRFieldOfView.h"
-#include "modules/vr/VRPositionState.h"
-#include "platform/heap/Handle.h"
-#include "public/platform/WebThread.h"
-#include "wtf/text/WTFString.h"
-
-namespace blink {
-
-class VRController;
-class VRDevice;
-class HMDVRDevice;
-class NavigatorVRDevice;
-class PositionSensorVRDevice;
-
-enum VREye {
-    VREyeLeft,
-    VREyeRight,
-    VREyeNone,
-};
-
-class VRHardwareUnit : public GarbageCollectedFinalized<VRHardwareUnit>, public WebThread::TaskObserver {
-public:
-    explicit VRHardwareUnit(NavigatorVRDevice*);
-    virtual ~VRHardwareUnit();
-
-    void updateFromWebVRDevice(const WebVRDevice&);
-
-    void addDevicesToVector(HeapVector<Member<VRDevice>>&);
-
-    virtual unsigned index() const { return m_index; }
-    const String& hardwareUnitId() const { return m_hardwareUnitId; }
-
-    unsigned frameIndex() const { return m_frameIndex; }
-
-    VRController* controller();
-
-    // VRController queries
-    VRPositionState* getSensorState();
-    VRPositionState* getImmediateSensorState(bool updateFrameIndex);
-
-    HMDVRDevice* hmd() const { return m_hmd; }
-    PositionSensorVRDevice* positionSensor() const { return m_positionSensor; }
-
-    DECLARE_VIRTUAL_TRACE();
-
-private:
-    // TaskObserver implementation.
-    void didProcessTask() override;
-    void willProcessTask() override { }
-
-    unsigned m_index;
-    String m_hardwareUnitId;
-    unsigned m_nextDeviceId;
-
-    unsigned m_frameIndex;
-
-    Member<NavigatorVRDevice> m_navigatorVRDevice;
-    Member<VRPositionState> m_positionState;
-    bool m_canUpdatePositionState;
-
-    // Device types
-    Member<HMDVRDevice> m_hmd;
-    Member<PositionSensorVRDevice> m_positionSensor;
-};
-
-} // namespace blink
-
-#endif // VRHardwareUnit_h
diff --git a/third_party/WebKit/Source/modules/vr/VRHardwareUnitCollection.cpp b/third_party/WebKit/Source/modules/vr/VRHardwareUnitCollection.cpp
deleted file mode 100644
index cfcb2de..0000000
--- a/third_party/WebKit/Source/modules/vr/VRHardwareUnitCollection.cpp
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "modules/vr/VRHardwareUnitCollection.h"
-
-#include "bindings/core/v8/ScriptPromiseResolver.h"
-#include "core/dom/Document.h"
-#include "core/dom/ExceptionCode.h"
-#include "core/frame/LocalDOMWindow.h"
-#include "core/frame/LocalFrame.h"
-#include "core/frame/Navigator.h"
-#include "core/page/Page.h"
-#include "modules/vr/HMDVRDevice.h"
-#include "modules/vr/NavigatorVRDevice.h"
-#include "modules/vr/PositionSensorVRDevice.h"
-#include "modules/vr/VRController.h"
-#include "modules/vr/VRGetDevicesCallback.h"
-#include "modules/vr/VRHardwareUnit.h"
-#include "modules/vr/VRPositionState.h"
-
-namespace blink {
-
-VRHardwareUnitCollection::VRHardwareUnitCollection(NavigatorVRDevice* navigatorVRDevice)
-    : m_navigatorVRDevice(navigatorVRDevice)
-{
-}
-
-HeapVector<Member<VRDevice>> VRHardwareUnitCollection::updateVRHardwareUnits(const WebVector<WebVRDevice>& devices)
-{
-    VRDeviceVector vrDevices;
-
-    for (const auto& device : devices) {
-        VRHardwareUnit* hardwareUnit = getHardwareUnitForIndex(device.index);
-        if (!hardwareUnit) {
-            hardwareUnit = new VRHardwareUnit(m_navigatorVRDevice);
-            m_hardwareUnits.append(hardwareUnit);
-        }
-
-        hardwareUnit->updateFromWebVRDevice(device);
-        hardwareUnit->addDevicesToVector(vrDevices);
-    }
-
-    return vrDevices;
-}
-
-VRHardwareUnit* VRHardwareUnitCollection::getHardwareUnitForIndex(unsigned index)
-{
-    VRHardwareUnit* hardwareUnit;
-    for (size_t i = 0; i < m_hardwareUnits.size(); ++i) {
-        hardwareUnit = m_hardwareUnits[i];
-        if (hardwareUnit->index() == index) {
-            return hardwareUnit;
-        }
-    }
-
-    return 0;
-}
-
-DEFINE_TRACE(VRHardwareUnitCollection)
-{
-    visitor->trace(m_navigatorVRDevice);
-    visitor->trace(m_hardwareUnits);
-}
-
-} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRHardwareUnitCollection.h b/third_party/WebKit/Source/modules/vr/VRHardwareUnitCollection.h
deleted file mode 100644
index cbdf63f..0000000
--- a/third_party/WebKit/Source/modules/vr/VRHardwareUnitCollection.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef VRHardwareUnitCollection_h
-#define VRHardwareUnitCollection_h
-
-#include "modules/vr/VRDevice.h"
-#include "modules/vr/VRHardwareUnit.h"
-#include "platform/heap/Handle.h"
-#include "public/platform/WebVector.h"
-
-namespace blink {
-
-struct WebVRDevice;
-
-class VRHardwareUnitCollection final : public GarbageCollected<VRHardwareUnitCollection> {
-public:
-    explicit VRHardwareUnitCollection(NavigatorVRDevice*);
-
-    VRDeviceVector updateVRHardwareUnits(const WebVector<WebVRDevice>&);
-    VRHardwareUnit* getHardwareUnitForIndex(unsigned index);
-
-    DECLARE_VIRTUAL_TRACE();
-
-private:
-    Member<NavigatorVRDevice> m_navigatorVRDevice;
-    HeapVector<Member<VRHardwareUnit>> m_hardwareUnits;
-};
-
-} // namespace blink
-
-#endif // VRHardwareUnitCollection_h
diff --git a/third_party/WebKit/Source/modules/vr/VRLayer.idl b/third_party/WebKit/Source/modules/vr/VRLayer.idl
new file mode 100644
index 0000000..c31d345
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRLayer.idl
@@ -0,0 +1,22 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+typedef HTMLCanvasElement VRSource;
+
+// http://mozvr.github.io/webvr-spec/webvr.html#vrlayer
+[
+    RuntimeEnabled=WebVR
+] dictionary VRLayer {
+  // The canvas to be presented to the VRDisplay
+  VRSource? source = null;
+
+  // The left and right bounds contain 4 git statvalues defining the texture bounds
+  // within the canvas to present to the eye in UV space.
+  // [0] left offset of the bounds (0.0 - 1.0)
+  // [1] top offset of the bounds (0.0 - 1.0)
+  // [2] width of the bounds (0.0 - 1.0)
+  // [3] height of the bounds (0.0 - 1.0)
+  sequence<float>? leftBounds; //= [0.0, 0.0, 0.5, 1.0];
+  sequence<float>? rightBounds; //= [0.5, 0.0, 0.5, 1.0];
+};
diff --git a/third_party/WebKit/Source/modules/vr/VRPose.cpp b/third_party/WebKit/Source/modules/vr/VRPose.cpp
new file mode 100644
index 0000000..f0282cd
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRPose.cpp
@@ -0,0 +1,83 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "modules/vr/VRPose.h"
+
+namespace blink {
+
+namespace {
+
+PassRefPtr<DOMFloat32Array> vecToFloat32Array(const WebVRVector4& vec)
+{
+    if (!vec.isNull) {
+        RefPtr<DOMFloat32Array> out = DOMFloat32Array::create(4);
+        out->data()[0] = vec.x;
+        out->data()[1] = vec.y;
+        out->data()[2] = vec.z;
+        out->data()[3] = vec.w;
+        return out;
+    }
+    return nullptr;
+}
+
+PassRefPtr<DOMFloat32Array> vecToFloat32Array(const WebVRVector3& vec)
+{
+    if (!vec.isNull) {
+        RefPtr<DOMFloat32Array> out = DOMFloat32Array::create(3);
+        out->data()[0] = vec.x;
+        out->data()[1] = vec.y;
+        out->data()[2] = vec.z;
+        return out;
+    }
+    return nullptr;
+}
+
+PassRefPtr<DOMFloat32Array> vecToFloat32Array(const WebGamepadVector& vec, int elements)
+{
+    if (!vec.isNull) {
+        RefPtr<DOMFloat32Array> out = DOMFloat32Array::create(elements);
+        out->data()[0] = vec.x;
+        out->data()[1] = vec.y;
+        out->data()[2] = vec.z;
+        if (elements >= 4)
+            out->data()[3] = vec.w;
+        return out;
+    }
+    return nullptr;
+}
+
+} // namespace
+
+VRPose::VRPose()
+    : m_timeStamp(0.0)
+{
+}
+
+void VRPose::setPose(const WebVRPose &state)
+{
+    m_timeStamp = state.timestamp;
+    m_orientation = vecToFloat32Array(state.orientation);
+    m_position = vecToFloat32Array(state.position);
+    m_angularVelocity = vecToFloat32Array(state.angularVelocity);
+    m_linearVelocity = vecToFloat32Array(state.linearVelocity);
+    m_angularAcceleration = vecToFloat32Array(state.angularAcceleration);
+    m_linearAcceleration = vecToFloat32Array(state.linearAcceleration);
+}
+
+void VRPose::setPose(const WebGamepadPose &state)
+{
+    m_timeStamp = 0;
+    m_orientation = vecToFloat32Array(state.orientation, 4);
+    m_position = vecToFloat32Array(state.position, 3);
+    m_angularVelocity = nullptr;
+    m_linearVelocity = nullptr;
+    m_angularAcceleration = nullptr;
+    m_linearAcceleration = nullptr;
+}
+
+DEFINE_TRACE(VRPose)
+{
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRPose.h b/third_party/WebKit/Source/modules/vr/VRPose.h
new file mode 100644
index 0000000..b3c5337
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRPose.h
@@ -0,0 +1,53 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef VRPose_h
+#define VRPose_h
+
+#include "bindings/core/v8/ScriptWrappable.h"
+#include "core/dom/DOMTypedArray.h"
+#include "platform/heap/Handle.h"
+#include "public/platform/WebGamepad.h"
+#include "public/platform/modules/vr/WebVR.h"
+#include "wtf/Forward.h"
+#include "wtf/text/WTFString.h"
+
+namespace blink {
+
+class VRPose final : public GarbageCollectedFinalized<VRPose>, public ScriptWrappable {
+    DEFINE_WRAPPERTYPEINFO();
+public:
+    static VRPose* create()
+    {
+        return new VRPose();
+    }
+
+    double timeStamp() const { return m_timeStamp; }
+    PassRefPtr<DOMFloat32Array> orientation() const { return m_orientation; }
+    PassRefPtr<DOMFloat32Array> position() const { return m_position; }
+    PassRefPtr<DOMFloat32Array> angularVelocity() const { return m_angularVelocity; }
+    PassRefPtr<DOMFloat32Array> linearVelocity() const { return m_linearVelocity; }
+    PassRefPtr<DOMFloat32Array> angularAcceleration() const { return m_angularAcceleration; }
+    PassRefPtr<DOMFloat32Array> linearAcceleration() const { return m_linearAcceleration; }
+
+    void setPose(const WebVRPose&);
+    void setPose(const WebGamepadPose&);
+
+    DECLARE_VIRTUAL_TRACE();
+
+private:
+    VRPose();
+
+    double m_timeStamp;
+    RefPtr<DOMFloat32Array> m_orientation;
+    RefPtr<DOMFloat32Array> m_position;
+    RefPtr<DOMFloat32Array> m_angularVelocity;
+    RefPtr<DOMFloat32Array> m_linearVelocity;
+    RefPtr<DOMFloat32Array> m_angularAcceleration;
+    RefPtr<DOMFloat32Array> m_linearAcceleration;
+};
+
+} // namespace blink
+
+#endif // VRPose_h
diff --git a/third_party/WebKit/Source/modules/vr/VRPose.idl b/third_party/WebKit/Source/modules/vr/VRPose.idl
new file mode 100644
index 0000000..7c17367
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRPose.idl
@@ -0,0 +1,17 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// http://mozvr.github.io/webvr-spec/webvr.html#vrpose
+[
+    RuntimeEnabled=WebVR,
+    GarbageCollected,
+] interface VRPose {
+    readonly attribute double timeStamp;
+    readonly attribute Float32Array? position;
+    readonly attribute Float32Array? linearVelocity;
+    readonly attribute Float32Array? linearAcceleration;
+    readonly attribute Float32Array? orientation;
+    readonly attribute Float32Array? angularVelocity;
+    readonly attribute Float32Array? angularAcceleration;
+};
diff --git a/third_party/WebKit/Source/modules/vr/VRPositionState.cpp b/third_party/WebKit/Source/modules/vr/VRPositionState.cpp
deleted file mode 100644
index 0d748cb..0000000
--- a/third_party/WebKit/Source/modules/vr/VRPositionState.cpp
+++ /dev/null
@@ -1,52 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "modules/vr/VRPositionState.h"
-
-namespace blink {
-
-namespace {
-
-DOMPoint* vecToDomPoint(const WebVRVector4& vec, bool valid)
-{
-    if (valid)
-        return DOMPoint::create(vec.x, vec.y, vec.z, vec.w);
-    return nullptr;
-}
-DOMPoint* vecToDomPoint(const WebVRVector3& vec, bool valid)
-{
-    if (valid)
-        return DOMPoint::create(vec.x, vec.y, vec.z, 1.0);
-    return nullptr;
-}
-
-} // namespace
-
-VRPositionState::VRPositionState()
-    : m_timeStamp(0.0)
-{
-}
-
-void VRPositionState::setState(const WebHMDSensorState &state)
-{
-    m_timeStamp = state.timestamp;
-    m_orientation = vecToDomPoint(state.orientation, state.flags & WebVRSensorStateOrientation);
-    m_position = vecToDomPoint(state.position, state.flags & WebVRSensorStatePosition);
-    m_angularVelocity = vecToDomPoint(state.angularVelocity, state.flags & WebVRSensorStateAngularVelocity);
-    m_linearVelocity = vecToDomPoint(state.linearVelocity, state.flags & WebVRSensorStateLinearVelocity);
-    m_angularAcceleration = vecToDomPoint(state.angularAcceleration, state.flags & WebVRSensorStateAngularAcceleration);
-    m_linearAcceleration =  vecToDomPoint(state.linearAcceleration, state.flags & WebVRSensorStateLinearAcceleration);
-}
-
-DEFINE_TRACE(VRPositionState)
-{
-    visitor->trace(m_orientation);
-    visitor->trace(m_position);
-    visitor->trace(m_angularVelocity);
-    visitor->trace(m_linearVelocity);
-    visitor->trace(m_angularAcceleration);
-    visitor->trace(m_linearAcceleration);
-}
-
-} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRPositionState.h b/third_party/WebKit/Source/modules/vr/VRPositionState.h
deleted file mode 100644
index 787f97e..0000000
--- a/third_party/WebKit/Source/modules/vr/VRPositionState.h
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef VRPositionState_h
-#define VRPositionState_h
-
-#include "bindings/core/v8/ScriptWrappable.h"
-#include "core/dom/DOMPoint.h"
-#include "platform/heap/Handle.h"
-#include "public/platform/modules/vr/WebVR.h"
-#include "wtf/Forward.h"
-#include "wtf/text/WTFString.h"
-
-namespace blink {
-
-class VRPositionState final : public GarbageCollected<VRPositionState>, public ScriptWrappable {
-    DEFINE_WRAPPERTYPEINFO();
-public:
-    static VRPositionState* create()
-    {
-        return new VRPositionState();
-    }
-
-    double timeStamp() const { return m_timeStamp; }
-    DOMPoint* orientation() const { return m_orientation; }
-    DOMPoint* position() const { return m_position; }
-    DOMPoint* angularVelocity() const { return m_angularVelocity; }
-    DOMPoint* linearVelocity() const { return m_linearVelocity; }
-    DOMPoint* angularAcceleration() const { return m_angularAcceleration; }
-    DOMPoint* linearAcceleration() const { return m_linearAcceleration; }
-
-    void setState(const WebHMDSensorState&);
-
-    DECLARE_VIRTUAL_TRACE();
-
-private:
-    VRPositionState();
-
-    double m_timeStamp;
-    Member<DOMPoint> m_orientation;
-    Member<DOMPoint> m_position;
-    Member<DOMPoint> m_angularVelocity;
-    Member<DOMPoint> m_linearVelocity;
-    Member<DOMPoint> m_angularAcceleration;
-    Member<DOMPoint> m_linearAcceleration;
-};
-
-} // namespace blink
-
-#endif // VRPositionState_h
diff --git a/third_party/WebKit/Source/modules/vr/VRPositionState.idl b/third_party/WebKit/Source/modules/vr/VRPositionState.idl
deleted file mode 100644
index 4a22a02..0000000
--- a/third_party/WebKit/Source/modules/vr/VRPositionState.idl
+++ /dev/null
@@ -1,17 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-// http://mozvr.github.io/webvr-spec/webvr.html#vrpositionstate
-[
-    RuntimeEnabled=WebVR,
-    GarbageCollected,
-] interface VRPositionState {
-    readonly attribute double timeStamp;
-    readonly attribute DOMPoint? position;
-    readonly attribute DOMPoint? linearVelocity;
-    readonly attribute DOMPoint? linearAcceleration;
-    readonly attribute DOMPoint? orientation;
-    readonly attribute DOMPoint? angularVelocity;
-    readonly attribute DOMPoint? angularAcceleration;
-};
diff --git a/third_party/WebKit/Source/modules/vr/VRStageParameters.cpp b/third_party/WebKit/Source/modules/vr/VRStageParameters.cpp
new file mode 100644
index 0000000..ac13941
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRStageParameters.cpp
@@ -0,0 +1,32 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "modules/vr/VRStageParameters.h"
+
+namespace blink {
+
+VRStageParameters::VRStageParameters()
+    : m_sizeX(0.0f)
+    , m_sizeZ(0.0f)
+{
+    // Set the sitting to standing transform to identity matrix
+    m_standingTransform = DOMFloat32Array::create(16);
+    m_standingTransform->data()[0] = 1.0f;
+    m_standingTransform->data()[5] = 1.0f;
+    m_standingTransform->data()[10] = 1.0f;
+    m_standingTransform->data()[15] = 1.0f;
+}
+
+void VRStageParameters::update(const WebVRStageParameters& stage)
+{
+  m_standingTransform = DOMFloat32Array::create(stage.standingTransform, 16);
+  m_sizeX = stage.sizeX;
+  m_sizeZ = stage.sizeZ;
+}
+
+DEFINE_TRACE(VRStageParameters)
+{
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/modules/vr/VRStageParameters.h b/third_party/WebKit/Source/modules/vr/VRStageParameters.h
new file mode 100644
index 0000000..809e681
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRStageParameters.h
@@ -0,0 +1,38 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef VRStageParameters_h
+#define VRStageParameters_h
+
+#include "bindings/core/v8/ScriptWrappable.h"
+#include "core/dom/DOMTypedArray.h"
+#include "platform/heap/Handle.h"
+#include "public/platform/modules/vr/WebVR.h"
+#include "wtf/Forward.h"
+
+namespace blink {
+
+class VRStageParameters final : public GarbageCollected<VRStageParameters>, public ScriptWrappable {
+    DEFINE_WRAPPERTYPEINFO();
+public:
+    VRStageParameters();
+
+    PassRefPtr<DOMFloat32Array> sittingToStandingTransform() const { return m_standingTransform; }
+
+    float sizeX() const { return m_sizeX; }
+    float sizeZ() const { return m_sizeZ; }
+
+    void update(const WebVRStageParameters&);
+
+    DECLARE_VIRTUAL_TRACE()
+
+private:
+    RefPtr<DOMFloat32Array> m_standingTransform;
+    float m_sizeX;
+    float m_sizeZ;
+};
+
+} // namespace blink
+
+#endif // VRStageParameters_h
diff --git a/third_party/WebKit/Source/modules/vr/VRStageParameters.idl b/third_party/WebKit/Source/modules/vr/VRStageParameters.idl
new file mode 100644
index 0000000..cd4fcba
--- /dev/null
+++ b/third_party/WebKit/Source/modules/vr/VRStageParameters.idl
@@ -0,0 +1,26 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// http://mozvr.github.io/webvr-spec/webvr.html#vrstageparameters
+[
+    RuntimeEnabled=WebVR,
+    GarbageCollected
+] interface VRStageParameters {
+  // A 16 element array containing the components of a 4x4 transform
+  // matrix.  This matrix transforms the sitting space position
+  // returned by get{Immediate}Pose() to a standing space position.
+  readonly attribute Float32Array sittingToStandingTransform;
+
+  // Dimensions of the play area bounds. The bounds are defined
+  // as an axis aligned rectangle on the floor.
+  // The center of the rectangle is at (0,0,0) in standing space
+  // coordinates.
+  // These bounds are defined for safety purposes.
+  // Content should not require the user to move beyond these
+  // bounds; however, it is possible for the user to ignore
+  // the bounds resulting in position values outside of
+  // this rectangle.
+  readonly attribute float sizeX;
+  readonly attribute float sizeZ;
+};
\ No newline at end of file
diff --git a/third_party/WebKit/Source/modules/webgl/WebGL2RenderingContext.cpp b/third_party/WebKit/Source/modules/webgl/WebGL2RenderingContext.cpp
index 4f009b1..7a72d81 100644
--- a/third_party/WebKit/Source/modules/webgl/WebGL2RenderingContext.cpp
+++ b/third_party/WebKit/Source/modules/webgl/WebGL2RenderingContext.cpp
@@ -39,7 +39,7 @@ PassOwnPtrWillBeRawPtr<CanvasRenderingContext> WebGL2RenderingContext::Factory::
     OwnPtr<WebGraphicsContext3D> context(createWebGraphicsContext3D(canvas, attributes, 2));
     if (!context)
         return nullptr;
-    OwnPtr<Extensions3DUtil> extensionsUtil = Extensions3DUtil::create(context.get());
+    OwnPtr<Extensions3DUtil> extensionsUtil = Extensions3DUtil::create(context.get(), context->getGLES2Interface());
     if (!extensionsUtil)
         return nullptr;
     if (extensionsUtil->supportsExtension("GL_EXT_debug_marker")) {
diff --git a/third_party/WebKit/Source/modules/webgl/WebGLRenderingContext.cpp b/third_party/WebKit/Source/modules/webgl/WebGLRenderingContext.cpp
index b657410..decad79 100644
--- a/third_party/WebKit/Source/modules/webgl/WebGLRenderingContext.cpp
+++ b/third_party/WebKit/Source/modules/webgl/WebGLRenderingContext.cpp
@@ -69,7 +69,7 @@ PassOwnPtrWillBeRawPtr<CanvasRenderingContext> WebGLRenderingContext::Factory::c
     OwnPtr<WebGraphicsContext3D> context(createWebGraphicsContext3D(canvas, attributes, 1));
     if (!context)
         return nullptr;
-    OwnPtr<Extensions3DUtil> extensionsUtil = Extensions3DUtil::create(context.get());
+    OwnPtr<Extensions3DUtil> extensionsUtil = Extensions3DUtil::create(context.get(), context->getGLES2Interface());
     if (!extensionsUtil)
         return nullptr;
     if (extensionsUtil->supportsExtension("GL_EXT_debug_marker")) {
diff --git a/third_party/WebKit/Source/modules/webgl/WebGLRenderingContextBase.cpp b/third_party/WebKit/Source/modules/webgl/WebGLRenderingContextBase.cpp
index abb24db..4dea89f 100644
--- a/third_party/WebKit/Source/modules/webgl/WebGLRenderingContextBase.cpp
+++ b/third_party/WebKit/Source/modules/webgl/WebGLRenderingContextBase.cpp
@@ -45,6 +45,7 @@
 #include "core/layout/LayoutBox.h"
 #include "core/loader/FrameLoader.h"
 #include "core/loader/FrameLoaderClient.h"
+#include "gpu/command_buffer/client/gles2_interface.h"
 #include "modules/webgl/ANGLEInstancedArrays.h"
 #include "modules/webgl/CHROMIUMSubscribeUniform.h"
 #include "modules/webgl/CHROMIUMValuebuffer.h"
@@ -5053,9 +5054,11 @@ void WebGLRenderingContextBase::setFilterQuality(SkFilterQuality filterQuality)
 Extensions3DUtil* WebGLRenderingContextBase::extensionsUtil()
 {
     if (!m_extensionsUtil) {
-        m_extensionsUtil = Extensions3DUtil::create(webContext());
+        WebGraphicsContext3D* context = webContext();
+        gpu::gles2::GLES2Interface* gl = context->getGLES2Interface();
+        m_extensionsUtil = Extensions3DUtil::create(context, gl);
         // The only reason the ExtensionsUtil should be invalid is if the webContext is lost.
-        ASSERT(m_extensionsUtil->isValid() || webContext()->isContextLost());
+        ASSERT(m_extensionsUtil->isValid() || gl->GetGraphicsResetStatusKHR() != GL_NO_ERROR);
     }
     return m_extensionsUtil.get();
 }
diff --git a/third_party/WebKit/Source/modules/webgl/WebGLRenderingContextBase.h b/third_party/WebKit/Source/modules/webgl/WebGLRenderingContextBase.h
index 8c09cb3..28178e0 100644
--- a/third_party/WebKit/Source/modules/webgl/WebGLRenderingContextBase.h
+++ b/third_party/WebKit/Source/modules/webgl/WebGLRenderingContextBase.h
@@ -421,6 +421,8 @@ public:
 
     void setFilterQuality(SkFilterQuality) override;
     bool isWebGL2OrHigher() { return version() >= 2; }
+    
+    DrawingBuffer* drawingBuffer() const;
 
 protected:
     friend class EXTDisjointTimerQuery;
@@ -489,7 +491,6 @@ protected:
     // Structure for rendering to a DrawingBuffer, instead of directly
     // to the back-buffer of m_context.
     RefPtr<DrawingBuffer> m_drawingBuffer;
-    DrawingBuffer* drawingBuffer() const;
 
     RefPtr<WebGLContextGroup> m_contextGroup;
 
diff --git a/third_party/WebKit/Source/platform/blink_platform.gyp b/third_party/WebKit/Source/platform/blink_platform.gyp
index ed3c26e..1ba678e 100644
--- a/third_party/WebKit/Source/platform/blink_platform.gyp
+++ b/third_party/WebKit/Source/platform/blink_platform.gyp
@@ -133,6 +133,7 @@
       '<(DEPTH)/cc/cc.gyp:cc',
       '<(DEPTH)/device/battery/battery.gyp:device_battery_mojo_bindings',
       '<(DEPTH)/gpu/gpu.gyp:gles2_c_lib',
+      '<(DEPTH)/gpu/gpu.gyp:gles2_implementation',
       '<(DEPTH)/mojo/mojo_base.gyp:mojo_environment_chromium',
       '<(DEPTH)/mojo/mojo_edk.gyp:mojo_system_impl',
       '<(DEPTH)/skia/skia.gyp:skia',
diff --git a/third_party/WebKit/Source/platform/graphics/Canvas2DLayerBridge.cpp b/third_party/WebKit/Source/platform/graphics/Canvas2DLayerBridge.cpp
index 7f3fc75..ec9c06b 100644
--- a/third_party/WebKit/Source/platform/graphics/Canvas2DLayerBridge.cpp
+++ b/third_party/WebKit/Source/platform/graphics/Canvas2DLayerBridge.cpp
@@ -25,6 +25,7 @@
 
 #include "platform/graphics/Canvas2DLayerBridge.h"
 
+#include "gpu/command_buffer/client/gles2_interface.h"
 #include "platform/Histogram.h"
 #include "platform/RuntimeEnabledFeatures.h"
 #include "platform/TraceEvent.h"
@@ -172,7 +173,7 @@ bool Canvas2DLayerBridge::shouldAccelerate(AccelerationHint hint) const
     else
         accelerate = hint == PreferAcceleration || hint == PreferAccelerationAfterVisibilityChange;
 
-    if (accelerate && (!m_contextProvider || m_contextProvider->context3d()->isContextLost()))
+    if (accelerate && (!m_contextProvider || m_contextProvider->contextGL()->GetGraphicsResetStatusKHR() != GL_NO_ERROR))
         accelerate = false;
     return accelerate;
 }
@@ -534,7 +535,7 @@ bool Canvas2DLayerBridge::checkSurfaceValid()
         return true;
     if (!m_surface)
         return false;
-    if (m_contextProvider->context3d()->isContextLost()) {
+    if (m_contextProvider->contextGL()->GetGraphicsResetStatusKHR() != GL_NO_ERROR) {
         m_surface.clear();
         for (auto mailboxInfo = m_mailboxes.begin(); mailboxInfo != m_mailboxes.end(); ++mailboxInfo) {
             if (mailboxInfo->m_image)
@@ -554,13 +555,13 @@ bool Canvas2DLayerBridge::restoreSurface()
         return false;
     ASSERT(isAccelerated() && !m_surface);
 
-    WebGraphicsContext3D* sharedContext = 0;
+    gpu::gles2::GLES2Interface* sharedGL = nullptr;
     m_layer->clearTexture();
     m_contextProvider = adoptPtr(Platform::current()->createSharedOffscreenGraphicsContext3DProvider());
     if (m_contextProvider)
-        sharedContext = m_contextProvider->context3d();
+        sharedGL = m_contextProvider->contextGL();
 
-    if (sharedContext && !sharedContext->isContextLost()) {
+    if (sharedGL && sharedGL->GetGraphicsResetStatusKHR() == GL_NO_ERROR) {
         GrContext* grCtx = m_contextProvider->grContext();
         bool surfaceIsAccelerated;
         RefPtr<SkSurface> surface(createSkSurface(grCtx, m_size, m_msaaSampleCount, m_opacityMode, &surfaceIsAccelerated));
@@ -687,7 +688,7 @@ bool Canvas2DLayerBridge::prepareMailbox(WebExternalTextureMailbox* outMailbox,
 void Canvas2DLayerBridge::mailboxReleased(const WebExternalTextureMailbox& mailbox, bool lostResource)
 {
     ASSERT(isAccelerated() || isHibernating());
-    bool contextLost = !isHibernating() && (!m_surface || m_contextProvider->context3d()->isContextLost());
+    bool contextLost = !isHibernating() && (!m_surface || m_contextProvider->contextGL()->GetGraphicsResetStatusKHR() != GL_NO_ERROR);
     ASSERT(m_mailboxes.last().m_parentLayerBridge.get() == this);
 
     // Mailboxes are typically released in FIFO order, so we iterate
diff --git a/third_party/WebKit/Source/platform/graphics/gpu/DrawingBuffer.cpp b/third_party/WebKit/Source/platform/graphics/gpu/DrawingBuffer.cpp
index 857c082..a3f544b 100644
--- a/third_party/WebKit/Source/platform/graphics/gpu/DrawingBuffer.cpp
+++ b/third_party/WebKit/Source/platform/graphics/gpu/DrawingBuffer.cpp
@@ -30,6 +30,7 @@
 
 #include "platform/graphics/gpu/DrawingBuffer.h"
 
+#include "gpu/command_buffer/client/gles2_interface.h"
 #include "platform/RuntimeEnabledFeatures.h"
 #include "platform/TraceEvent.h"
 #include "platform/graphics/GraphicsLayer.h"
@@ -97,7 +98,8 @@ PassRefPtr<DrawingBuffer> DrawingBuffer::create(PassOwnPtr<WebGraphicsContext3D>
         return nullptr;
     }
 
-    OwnPtr<Extensions3DUtil> extensionsUtil = Extensions3DUtil::create(context.get());
+    gpu::gles2::GLES2Interface* gl = context->getGLES2Interface();
+    OwnPtr<Extensions3DUtil> extensionsUtil = Extensions3DUtil::create(context.get(), gl);
     if (!extensionsUtil->isValid()) {
         // This might be the first time we notice that the WebGraphicsContext3D is lost.
         return nullptr;
@@ -118,7 +120,7 @@ PassRefPtr<DrawingBuffer> DrawingBuffer::create(PassOwnPtr<WebGraphicsContext3D>
     if (discardFramebufferSupported)
         extensionsUtil->ensureExtensionEnabled("GL_EXT_discard_framebuffer");
 
-    RefPtr<DrawingBuffer> drawingBuffer = adoptRef(new DrawingBuffer(std::move(context), extensionsUtil.release(), multisampleSupported, discardFramebufferSupported, preserve, requestedAttributes));
+    RefPtr<DrawingBuffer> drawingBuffer = adoptRef(new DrawingBuffer(std::move(context), gl, extensionsUtil.release(), multisampleSupported, discardFramebufferSupported, preserve, requestedAttributes));
     if (!drawingBuffer->initialize(size)) {
         drawingBuffer->beginDestruction();
         return PassRefPtr<DrawingBuffer>();
@@ -131,12 +133,7 @@ void DrawingBuffer::forceNextDrawingBufferCreationToFail()
     shouldFailDrawingBufferCreationForTesting = true;
 }
 
-DrawingBuffer::DrawingBuffer(PassOwnPtr<WebGraphicsContext3D> context,
-    PassOwnPtr<Extensions3DUtil> extensionsUtil,
-    bool multisampleExtensionSupported,
-    bool discardFramebufferSupported,
-    PreserveDrawingBuffer preserve,
-    WebGraphicsContext3D::Attributes requestedAttributes)
+DrawingBuffer::DrawingBuffer(PassOwnPtr<WebGraphicsContext3D> context, gpu::gles2::GLES2Interface* gl, PassOwnPtr<Extensions3DUtil> extensionsUtil, bool multisampleExtensionSupported, bool discardFramebufferSupported, PreserveDrawingBuffer preserve, WebGraphicsContext3D::Attributes requestedAttributes)
     : m_preserveDrawingBuffer(preserve)
     , m_scissorEnabled(false)
     , m_texture2DBinding(0)
@@ -144,6 +141,7 @@ DrawingBuffer::DrawingBuffer(PassOwnPtr<WebGraphicsContext3D> context,
     , m_readFramebufferBinding(0)
     , m_activeTextureUnit(GL_TEXTURE0)
     , m_context(std::move(context))
+    , m_gl(gl)
     , m_extensionsUtil(std::move(extensionsUtil))
     , m_size(-1, -1)
     , m_requestedAttributes(requestedAttributes)
@@ -320,7 +318,7 @@ bool DrawingBuffer::prepareMailbox(WebExternalTextureMailbox* outMailbox, WebExt
 
 void DrawingBuffer::mailboxReleased(const WebExternalTextureMailbox& mailbox, bool lostResource)
 {
-    if (m_destructionInProgress || m_context->isContextLost() || lostResource || m_isHidden) {
+    if (m_destructionInProgress || m_gl->GetGraphicsResetStatusKHR() != GL_NO_ERROR || lostResource || m_isHidden) {
         mailboxReleasedWithoutRecycling(mailbox);
         return;
     }
@@ -444,7 +442,7 @@ void DrawingBuffer::deleteMailbox(const WebExternalTextureMailbox& mailbox)
 
 bool DrawingBuffer::initialize(const IntSize& size)
 {
-    if (m_context->isContextLost()) {
+    if (m_gl->GetGraphicsResetStatusKHR() != GL_NO_ERROR) {
         // Need to try to restore the context again later.
         return false;
     }
@@ -490,7 +488,7 @@ bool DrawingBuffer::initialize(const IntSize& size)
     }
     m_actualAttributes.antialias = multisample();
 
-    if (m_context->isContextLost()) {
+    if (m_gl->GetGraphicsResetStatusKHR() != GL_NO_ERROR) {
         // It's possible that the drawing buffer allocation provokes a context loss, so check again just in case. http://crbug.com/512302
         return false;
     }
diff --git a/third_party/WebKit/Source/platform/graphics/gpu/DrawingBuffer.h b/third_party/WebKit/Source/platform/graphics/gpu/DrawingBuffer.h
index 327b27e..73f9121 100644
--- a/third_party/WebKit/Source/platform/graphics/gpu/DrawingBuffer.h
+++ b/third_party/WebKit/Source/platform/graphics/gpu/DrawingBuffer.h
@@ -46,11 +46,15 @@
 #include "wtf/OwnPtr.h"
 #include "wtf/PassOwnPtr.h"
 
-namespace WTF {
+namespace gpu {
+namespace gles2 {
+class GLES2Interface;
+}
+}
 
+namespace WTF {
 class ArrayBufferContents;
-
-} // namespace WTF
+}
 
 namespace blink {
 
@@ -175,6 +179,7 @@ public:
 protected: // For unittests
     DrawingBuffer(
         PassOwnPtr<WebGraphicsContext3D>,
+        gpu::gles2::GLES2Interface*,
         PassOwnPtr<Extensions3DUtil>,
         bool multisampleExtensionSupported,
         bool discardFramebufferSupported,
@@ -299,6 +304,7 @@ private:
     GLenum m_activeTextureUnit;
 
     OwnPtr<WebGraphicsContext3D> m_context;
+    gpu::gles2::GLES2Interface* m_gl; // Lifetime is tied to the m_context.
     OwnPtr<Extensions3DUtil> m_extensionsUtil;
     IntSize m_size;
     WebGraphicsContext3D::Attributes m_requestedAttributes;
diff --git a/third_party/WebKit/Source/platform/graphics/gpu/Extensions3DUtil.cpp b/third_party/WebKit/Source/platform/graphics/gpu/Extensions3DUtil.cpp
index 47af193..4941e8d 100644
--- a/third_party/WebKit/Source/platform/graphics/gpu/Extensions3DUtil.cpp
+++ b/third_party/WebKit/Source/platform/graphics/gpu/Extensions3DUtil.cpp
@@ -4,6 +4,7 @@
 
 #include "platform/graphics/gpu/Extensions3DUtil.h"
 
+#include "gpu/command_buffer/client/gles2_interface.h"
 #include "public/platform/WebGraphicsContext3D.h"
 #include "wtf/text/CString.h"
 #include "wtf/text/StringHash.h"
@@ -22,15 +23,16 @@ void splitStringHelper(const String& str, HashSet<String>& set)
 
 } // anonymous namespace
 
-PassOwnPtr<Extensions3DUtil> Extensions3DUtil::create(WebGraphicsContext3D* context)
+PassOwnPtr<Extensions3DUtil> Extensions3DUtil::create(WebGraphicsContext3D* context, gpu::gles2::GLES2Interface* gl)
 {
-    OwnPtr<Extensions3DUtil> out = adoptPtr(new Extensions3DUtil(context));
+    OwnPtr<Extensions3DUtil> out = adoptPtr(new Extensions3DUtil(context, gl));
     out->initializeExtensions();
     return out.release();
 }
 
-Extensions3DUtil::Extensions3DUtil(WebGraphicsContext3D* context)
+Extensions3DUtil::Extensions3DUtil(WebGraphicsContext3D* context, gpu::gles2::GLES2Interface* gl)
     : m_context(context)
+    , m_gl(gl)
     , m_isValid(true)
 {
 }
@@ -41,7 +43,7 @@ Extensions3DUtil::~Extensions3DUtil()
 
 void Extensions3DUtil::initializeExtensions()
 {
-    if (m_context->isContextLost()) {
+    if (m_gl->GetGraphicsResetStatusKHR() != GL_NO_ERROR) {
         // If the context is lost don't initialize the extension strings.
         // This will cause supportsExtension, ensureExtensionEnabled, and isExtensionEnabled to always return false.
         m_isValid = false;
diff --git a/third_party/WebKit/Source/platform/graphics/gpu/Extensions3DUtil.h b/third_party/WebKit/Source/platform/graphics/gpu/Extensions3DUtil.h
index ee6298c..0e36c32 100644
--- a/third_party/WebKit/Source/platform/graphics/gpu/Extensions3DUtil.h
+++ b/third_party/WebKit/Source/platform/graphics/gpu/Extensions3DUtil.h
@@ -15,6 +15,12 @@
 #include "wtf/text/StringHash.h"
 #include "wtf/text/WTFString.h"
 
+namespace gpu {
+namespace gles2 {
+class GLES2Interface;
+}
+}
+
 namespace blink {
 
 class WebGraphicsContext3D;
@@ -23,8 +29,8 @@ class PLATFORM_EXPORT Extensions3DUtil final {
     USING_FAST_MALLOC(Extensions3DUtil);
     WTF_MAKE_NONCOPYABLE(Extensions3DUtil);
 public:
-    // Creates a new Extensions3DUtil. If the passed WebGraphicsContext3D has been spontaneously lost, returns null.
-    static PassOwnPtr<Extensions3DUtil> create(WebGraphicsContext3D*);
+    // Creates a new Extensions3DUtil. If the passed GLES2Interface has been spontaneously lost, returns null.
+    static PassOwnPtr<Extensions3DUtil> create(WebGraphicsContext3D*, gpu::gles2::GLES2Interface*);
     ~Extensions3DUtil();
 
     bool isValid() { return m_isValid; }
@@ -36,10 +42,11 @@ public:
     static bool canUseCopyTextureCHROMIUM(GLenum destTarget, GLenum destFormat, GLenum destType, GLint level);
 
 private:
-    Extensions3DUtil(WebGraphicsContext3D*);
+    Extensions3DUtil(WebGraphicsContext3D*, gpu::gles2::GLES2Interface*);
     void initializeExtensions();
 
     WebGraphicsContext3D* m_context;
+    gpu::gles2::GLES2Interface* m_gl;
     HashSet<String> m_enabledExtensions;
     HashSet<String> m_requestableExtensions;
     bool m_isValid;
diff --git a/third_party/WebKit/Source/platform/graphics/gpu/SharedContextRateLimiter.cpp b/third_party/WebKit/Source/platform/graphics/gpu/SharedContextRateLimiter.cpp
index 45067a6..0fc1996 100644
--- a/third_party/WebKit/Source/platform/graphics/gpu/SharedContextRateLimiter.cpp
+++ b/third_party/WebKit/Source/platform/graphics/gpu/SharedContextRateLimiter.cpp
@@ -4,6 +4,7 @@
 
 #include "platform/graphics/gpu/SharedContextRateLimiter.h"
 
+#include "gpu/command_buffer/client/gles2_interface.h"
 #include "platform/graphics/gpu/Extensions3DUtil.h"
 #include "public/platform/Platform.h"
 #include "public/platform/WebGraphicsContext3D.h"
@@ -28,9 +29,9 @@ SharedContextRateLimiter::SharedContextRateLimiter(unsigned maxPendingTicks)
     if (!m_contextProvider)
         return;
 
-    WebGraphicsContext3D* context = m_contextProvider->context3d();
-    if (context && !context->isContextLost()) {
-        OwnPtr<Extensions3DUtil> extensionsUtil = Extensions3DUtil::create(context);
+    gpu::gles2::GLES2Interface* gl = m_contextProvider->contextGL();
+    if (gl && gl->GetGraphicsResetStatusKHR() == GL_NO_ERROR) {
+        OwnPtr<Extensions3DUtil> extensionsUtil = Extensions3DUtil::create(m_contextProvider->context3d(), gl);
         // TODO(junov): when the GLES 3.0 command buffer is ready, we could use fenceSync instead
         m_canUseSyncQueries = extensionsUtil->supportsExtension("GL_CHROMIUM_sync_query");
     }
@@ -41,11 +42,12 @@ void SharedContextRateLimiter::tick()
     if (!m_contextProvider)
         return;
 
-    WebGraphicsContext3D* context = m_contextProvider->context3d();
+    gpu::gles2::GLES2Interface* gl = m_contextProvider->contextGL();
 
-    if (!context || context->isContextLost())
+    if (!gl || gl->GetGraphicsResetStatusKHR() != GL_NO_ERROR)
         return;
 
+    WebGraphicsContext3D* context = m_contextProvider->context3d();
     m_queries.append(m_canUseSyncQueries ? context->createQueryEXT() : 0);
     if (m_canUseSyncQueries) {
         context->beginQueryEXT(GL_COMMANDS_COMPLETED_CHROMIUM, m_queries.last());
@@ -69,8 +71,9 @@ void SharedContextRateLimiter::reset()
     if (!m_contextProvider)
         return;
 
-    WebGraphicsContext3D* context = m_contextProvider->context3d();
-    if (context && !context->isContextLost()) {
+    gpu::gles2::GLES2Interface* gl = m_contextProvider->contextGL();
+    if (gl && gl->GetGraphicsResetStatusKHR() == GL_NO_ERROR) {
+        WebGraphicsContext3D* context = m_contextProvider->context3d();
         while (m_queries.size() > 0) {
             context->deleteQueryEXT(m_queries.first());
             m_queries.removeFirst();
diff --git a/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp b/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
index b57ebf5..3695213 100644
--- a/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
+++ b/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
@@ -62,7 +62,7 @@
 #include "modules/mediasession/MediaSession.h"
 #include "modules/serviceworkers/NavigatorServiceWorker.h"
 #include "modules/storage/DOMWindowStorageController.h"
-#include "modules/vr/NavigatorVRDevice.h"
+#include "modules/vr/NavigatorVR.h"
 #include "platform/Histogram.h"
 #include "platform/MIMETypeRegistry.h"
 #include "platform/RuntimeEnabledFeatures.h"
@@ -166,7 +166,7 @@ void FrameLoaderClientImpl::dispatchDidClearWindowObjectInMainWorld()
             NavigatorServiceWorker::from(*document);
             DOMWindowStorageController::from(*document);
             if (RuntimeEnabledFeatures::webVREnabled())
-                NavigatorVRDevice::from(*document);
+                NavigatorVR::from(*document);
         }
     }
     // FIXME: when extensions go out of process, this whole concept stops working.
diff --git a/third_party/WebKit/public/platform/WebGamepad.h b/third_party/WebKit/public/platform/WebGamepad.h
index af1c3e7..ae2b843 100644
--- a/third_party/WebKit/public/platform/WebGamepad.h
+++ b/third_party/WebKit/public/platform/WebGamepad.h
@@ -38,16 +38,39 @@ class WebGamepadButton {
 public:
     WebGamepadButton()
         : pressed(false)
+        , touched(false)
         , value(0.)
     {
     }
-    WebGamepadButton(bool pressed, double value)
+    WebGamepadButton(bool pressed, bool touched, double value)
         : pressed(pressed)
+        , touched(touched)
         , value(value)
     {
     }
     bool pressed;
+    bool touched;
     double value;
+
+};
+
+struct WebGamepadVector {
+    bool isNull;
+    float x, y, z, w;
+};
+
+class WebGamepadPose {
+public:
+    WebGamepadPose()
+        : isNull(true)
+    {
+    }
+
+    bool isNull;
+
+    // TODO: 6DOF
+    WebGamepadVector orientation;
+    WebGamepadVector position;
 };
 
 // This structure is intentionally POD and fixed size so that it can be shared
@@ -94,11 +117,11 @@ public:
 
     // Mapping type (for example "standard")
     WebUChar mapping[mappingLengthCap];
+    
+    WebGamepadPose pose;
 };
 
-#if BLINK_IMPLEMENTATION
-static_assert(sizeof(WebGamepad) == 721, "WebGamepad has wrong size");
-#endif
+static_assert(sizeof(WebGamepad) == 788, "WebGamepad has wrong size");
 
 #pragma pack(pop)
 
diff --git a/third_party/WebKit/public/platform/WebGamepads.h b/third_party/WebKit/public/platform/WebGamepads.h
index 2aa8621..0eaf081 100644
--- a/third_party/WebKit/public/platform/WebGamepads.h
+++ b/third_party/WebKit/public/platform/WebGamepads.h
@@ -51,9 +51,7 @@ public:
     WebGamepad items[itemsLengthCap];
 };
 
-#if BLINK_IMPLEMENTATION
-static_assert(sizeof(WebGamepads) == 2888, "WebGamepads has wrong size");
-#endif
+static_assert(sizeof(WebGamepads) == 3156, "WebGamepads has wrong size");
 
 #pragma pack(pop)
 
diff --git a/third_party/WebKit/public/platform/WebGraphicsContext3D.h b/third_party/WebKit/public/platform/WebGraphicsContext3D.h
index cd8a5d4..76d3d50 100644
--- a/third_party/WebKit/public/platform/WebGraphicsContext3D.h
+++ b/third_party/WebKit/public/platform/WebGraphicsContext3D.h
@@ -35,6 +35,12 @@
 #include "WebNonCopyable.h"
 #include "WebString.h"
 
+namespace gpu {
+namespace gles2 {
+class GLES2Interface;
+}
+}
+
 struct GrGLInterface;
 
 namespace blink {
@@ -169,8 +175,6 @@ public:
     // getError in the order they were added.
     virtual void synthesizeGLError(WGC3Denum) = 0;
 
-    virtual bool isContextLost() = 0;
-
     // GL_CHROMIUM_map_sub
     virtual void* mapBufferSubDataCHROMIUM(WGC3Denum target, WGC3Dintptr offset, WGC3Dsizeiptr size, WGC3Denum access) = 0;
     virtual void unmapBufferSubDataCHROMIUM(const void*) = 0;
@@ -550,6 +554,9 @@ public:
     virtual void vertexAttribI4uiv(WGC3Duint index, const WGC3Duint *v) { }
     virtual void vertexAttribIPointer(WGC3Duint index, WGC3Dint size, WGC3Denum type, WGC3Dsizei stride, WGC3Dintptr pointer) { }
     virtual void waitSync(WGC3Dsync sync, WGC3Dbitfield flags, WGC3Duint64 timeout) { }
+    
+    // Prefer getting a GLES2Interface off WebGraphicsContext3DProvider if possible, and avoid using WebGraphicsContext3D at all.
+    virtual gpu::gles2::GLES2Interface* getGLES2Interface() = 0;
 };
 
 } // namespace blink
diff --git a/third_party/WebKit/public/platform/WebGraphicsContext3DProvider.h b/third_party/WebKit/public/platform/WebGraphicsContext3DProvider.h
index c71432d..709c1d2 100644
--- a/third_party/WebKit/public/platform/WebGraphicsContext3DProvider.h
+++ b/third_party/WebKit/public/platform/WebGraphicsContext3DProvider.h
@@ -35,6 +35,12 @@
 
 class GrContext;
 
+namespace gpu {
+namespace gles2 {
+class GLES2Interface;
+}
+}
+
 namespace blink {
 
 class WebGraphicsContext3D;
@@ -44,6 +50,7 @@ public:
     virtual ~WebGraphicsContext3DProvider() { }
 
     virtual WebGraphicsContext3D* context3d() = 0;
+    virtual gpu::gles2::GLES2Interface* contextGL() = 0;
     virtual GrContext* grContext() = 0;
 };
 
diff --git a/third_party/WebKit/public/platform/modules/vr/WebVR.h b/third_party/WebKit/public/platform/modules/vr/WebVR.h
index 404fd4b..52de865 100644
--- a/third_party/WebKit/public/platform/modules/vr/WebVR.h
+++ b/third_party/WebKit/public/platform/modules/vr/WebVR.h
@@ -15,17 +15,15 @@
 namespace blink {
 
 struct WebVRVector3 {
+    bool isNull;
     float x, y, z;
 };
 
 struct WebVRVector4 {
+    bool isNull;
     float x, y, z, w;
 };
 
-struct WebVRRect {
-    int x, y, width, height;
-};
-
 // A field of view, given by 4 degrees describing the view from a center point.
 struct WebVRFieldOfView {
     float upDegrees;
@@ -34,26 +32,10 @@ struct WebVRFieldOfView {
     float rightDegrees;
 };
 
-// Bit flags to indicate which fields of an WebHMDSensorState are valid.
-enum WebVRSensorStateFlags {
-    WebVRSensorStateOrientation = 1 << 1,
-    WebVRSensorStatePosition = 1 << 2,
-    WebVRSensorStateAngularVelocity = 1 << 3,
-    WebVRSensorStateLinearVelocity = 1 << 4,
-    WebVRSensorStateAngularAcceleration = 1 << 5,
-    WebVRSensorStateLinearAcceleration = 1 << 6,
-    WebVRSensorStateComplete = (1 << 7) - 1 // All previous states combined.
-};
-
-// A bitfield of WebVRSensorStateFlags.
-typedef int WebVRSensorStateMask;
-
 // A sensor's position, orientation, velocity, and acceleration state at the
 // given timestamp.
-struct WebHMDSensorState {
+struct WebVRPose {
     double timestamp;
-    unsigned frameIndex;
-    WebVRSensorStateMask flags;
     WebVRVector4 orientation;
     WebVRVector3 position;
     WebVRVector3 angularVelocity;
@@ -64,28 +46,38 @@ struct WebHMDSensorState {
 
 // Information about the optical properties for an eye in an HMD.
 struct WebVREyeParameters {
-    WebVRFieldOfView minimumFieldOfView;
-    WebVRFieldOfView maximumFieldOfView;
-    WebVRFieldOfView recommendedFieldOfView;
-    WebVRVector3 eyeTranslation;
-    WebVRRect renderRect;
+    WebVRFieldOfView fieldOfView;
+    WebVRVector3 offset;
+    unsigned renderWidth;
+    unsigned renderHeight;
 };
 
-// Information pertaining to Head Mounted Displays.
-struct WebVRHMDInfo {
-    WebVREyeParameters leftEye;
-    WebVREyeParameters rightEye;
+// Capabilities of the VR device.
+struct WebVRDisplayCapabilities {
+    bool hasOrientation;
+    bool hasPosition;
+    bool hasExternalDisplay;
+    bool canPresent;
 };
 
-// Bit flags to indicate what type of data a WebVRDevice describes.
-enum WebVRDeviceTypeFlags {
-    WebVRDeviceTypePosition = 1 << 1,
-    WebVRDeviceTypeHMD = 1 << 2
+// Information about the standing space environment, if present
+struct WebVRStageParameters {
+    bool isNull;
+    float standingTransform[16];
+    float sizeX;
+    float sizeZ;
 };
 
 // A bitfield of WebVRDeviceTypeFlags.
 typedef int WebVRDeviceTypeMask;
 
+enum class WebVRCompositorType {
+    NONE,
+    CARDBOARD,
+    OCULUS,
+    OPENVR
+};
+
 // Describes a single VR hardware unit. May describe multiple capabilities,
 // such as position sensors or head mounted display metrics.
 struct WebVRDevice {
@@ -93,10 +85,15 @@ struct WebVRDevice {
     unsigned index;
     // Friendly device name.
     WebString deviceName;
+    // Type of compositor to create for this device.
+    WebVRCompositorType deviceCompositorType;
     // Identifies the capabilities of this hardware unit.
-    WebVRDeviceTypeMask flags;
-    // Will only contain valid data if (flags & HasHMDDevice).
-    WebVRHMDInfo hmdInfo;
+    WebVRDisplayCapabilities capabilities;
+    // Eye parameters.
+    WebVREyeParameters leftEye;
+    WebVREyeParameters rightEye;
+
+    WebVRStageParameters stageParameters;
 };
 
 }
diff --git a/third_party/WebKit/public/platform/modules/vr/WebVRClient.h b/third_party/WebKit/public/platform/modules/vr/WebVRClient.h
index 6de79d9..207ff59 100644
--- a/third_party/WebKit/public/platform/modules/vr/WebVRClient.h
+++ b/third_party/WebKit/public/platform/modules/vr/WebVRClient.h
@@ -21,9 +21,9 @@ public:
 
     virtual void getDevices(WebVRGetDevicesCallback*) = 0;
 
-    virtual void getSensorState(unsigned index, blink::WebHMDSensorState& into) = 0;
+    virtual void getPose(unsigned index, blink::WebVRPose& into) = 0;
 
-    virtual void resetSensor(unsigned index) = 0;
+    virtual void resetPose(unsigned index) = 0;
 };
 
 } // namespace blink
diff --git a/ui/base/win/shell.cc b/ui/base/win/shell.cc
index 8dacd14..b6e5851 100644
--- a/ui/base/win/shell.cc
+++ b/ui/base/win/shell.cc
@@ -20,6 +20,7 @@
 #include "base/win/win_util.h"
 #include "base/win/windows_version.h"
 #include "ui/base/ui_base_switches.h"
+#include "ui/gl/gl_switches.h"
 
 namespace ui {
 namespace win {
@@ -200,6 +201,10 @@ void ClearWindowPropertyStore(HWND hwnd) {
 }
 
 bool IsAeroGlassEnabled() {
+#if defined(ENABLE_WEBVR)
+  // FIXME: Temp fix for WebVR, prevent black from with --use-gl=desktop
+  return false;
+#else
   // For testing in Win8 (where it is not possible to disable composition) the
   // user can specify this command line switch to mimic the behavior.  In this
   // mode, cross-HWND transparency is not supported and various types of
@@ -215,6 +220,7 @@ bool IsAeroGlassEnabled() {
   // If composition is not enabled, we behave like on XP.
   BOOL enabled = FALSE;
   return SUCCEEDED(DwmIsCompositionEnabled(&enabled)) && enabled;
+#endif
 }
 
 }  // namespace win
diff --git a/ui/compositor/compositor.cc b/ui/compositor/compositor.cc
index e359f66..0ba3f68 100644
--- a/ui/compositor/compositor.cc
+++ b/ui/compositor/compositor.cc
@@ -103,7 +103,12 @@ Compositor::Compositor(ui::ContextFactory* context_factory,
       context_factory_->DoesCreateTestContexts() ? kTestRefreshRate
                                                  : kDefaultRefreshRate;
   settings.main_frame_before_activation_enabled = false;
+#if !defined(OS_ANDROID)
+  if (command_line->HasSwitch(switches::kDisableGpuVsync) ||
+      command_line->HasSwitch("enable-webvr")) {
+#else
   if (command_line->HasSwitch(switches::kDisableGpuVsync)) {
+#endif
     std::string display_vsync_string =
         command_line->GetSwitchValueASCII(switches::kDisableGpuVsync);
     if (display_vsync_string == "gpu") {
diff --git a/ui/gl/gl_surface_wgl.cc b/ui/gl/gl_surface_wgl.cc
index 8890e5c..b000482 100644
--- a/ui/gl/gl_surface_wgl.cc
+++ b/ui/gl/gl_surface_wgl.cc
@@ -291,6 +291,12 @@ void* NativeViewGLSurfaceWGL::GetHandle() {
   return device_context_;
 }
 
+bool NativeViewGLSurfaceWGL::Resize(const gfx::Size& size,
+                                    float scale_factor,
+                                    bool has_alpha) {
+  return true;
+}
+
 PbufferGLSurfaceWGL::PbufferGLSurfaceWGL(const gfx::Size& size)
     : size_(size),
       device_context_(NULL),
diff --git a/ui/gl/gl_surface_wgl.h b/ui/gl/gl_surface_wgl.h
index 7466bcb..9b5e3ae 100644
--- a/ui/gl/gl_surface_wgl.h
+++ b/ui/gl/gl_surface_wgl.h
@@ -42,6 +42,10 @@ class NativeViewGLSurfaceWGL : public GLSurfaceWGL {
   gfx::SwapResult SwapBuffers() override;
   gfx::Size GetSize() override;
   void* GetHandle() override;
+  
+  bool Resize(const gfx::Size& size,
+              float scale_factor,
+              bool has_alpha) override;
 
  private:
   ~NativeViewGLSurfaceWGL() override;
-- 
2.7.4.windows.1

