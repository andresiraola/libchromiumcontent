diff --git a/content/browser/gamepad/gamepad_data_fetcher.cc b/content/browser/gamepad/gamepad_data_fetcher.cc
index 8917224..1bfbb5c 100644
--- a/content/browser/gamepad/gamepad_data_fetcher.cc
+++ b/content/browser/gamepad/gamepad_data_fetcher.cc
@@ -4,82 +4,16 @@
 
 #include "content/browser/gamepad/gamepad_data_fetcher.h"
 
-#include <stddef.h>
-#include <string.h>
-
-#include "base/logging.h"
-#include "build/build_config.h"
-
-namespace {
-
-#if !defined(OS_ANDROID)
-const float kMinAxisResetValue = 0.1f;
-#endif
-
-}  // namespace
-
 namespace content {
 
-using blink::WebGamepad;
-using blink::WebGamepads;
-
-#if !defined(OS_ANDROID)
-void GamepadDataFetcher::MapAndSanitizeGamepadData(
-    PadState* pad_state, WebGamepad* pad) {
-  DCHECK(pad_state);
-  DCHECK(pad);
-
-  if (!pad_state->data.connected) {
-    memset(pad, 0, sizeof(WebGamepad));
-    return;
-  }
-
-  // Copy the current state to the output buffer, using the mapping
-  // function, if there is one available.
-  if (pad_state->mapper)
-    pad_state->mapper(pad_state->data, pad);
-  else
-    *pad = pad_state->data;
-
-  // About sanitization: Gamepads may report input event if the user is not
-  // interacting with it, due to hardware problems or environmental ones (pad
-  // has something heavy leaning against an axis.) This may cause user gestures
-  // to be detected erroniously, exposing gamepad information when the user had
-  // no intention of doing so. To avoid this we require that each button or axis
-  // report being at rest (zero) at least once before exposing its value to the
-  // Gamepad API. This state is tracked by the axis_mask and button_mask
-  // bitfields. If the bit for an axis or button is 0 it means the axis has
-  // never reported being at rest, and the value will be forced to zero.
+GamepadDataFetcher::GamepadDataFetcher() : provider_(nullptr) {
+}
 
-  // We can skip axis sanitation if all available axes have been masked.
-  uint32_t full_axis_mask = (1 << pad->axesLength) - 1;
-  if (pad_state->axis_mask != full_axis_mask) {
-    for (size_t axis = 0; axis < pad->axesLength; ++axis) {
-      if (!(pad_state->axis_mask & 1 << axis)) {
-        if (fabs(pad->axes[axis]) < kMinAxisResetValue) {
-          pad_state->axis_mask |= 1 << axis;
-        } else {
-          pad->axes[axis] = 0.0f;
-        }
-      }
-    }
-  }
+void GamepadDataFetcher::InitializeProvider(GamepadProvider* provider) {
+  DCHECK(provider);
 
-  // We can skip button sanitation if all available buttons have been masked.
-  uint32_t full_button_mask = (1 << pad->buttonsLength) - 1;
-  if (pad_state->button_mask != full_button_mask) {
-    for (size_t button = 0; button < pad->buttonsLength; ++button) {
-      if (!(pad_state->button_mask & 1 << button)) {
-        if (!pad->buttons[button].pressed) {
-          pad_state->button_mask |= 1 << button;
-        } else {
-          pad->buttons[button].pressed = false;
-          pad->buttons[button].value = 0.0f;
-        }
-      }
-    }
-  }
+  provider_ = provider;
+  OnAddedToProvider();
 }
-#endif
 
 }  // namespace content
diff --git a/content/browser/gamepad/gamepad_data_fetcher.h b/content/browser/gamepad/gamepad_data_fetcher.h
index a395fd9..394849a 100644
--- a/content/browser/gamepad/gamepad_data_fetcher.h
+++ b/content/browser/gamepad/gamepad_data_fetcher.h
@@ -5,55 +5,36 @@
 #ifndef CONTENT_BROWSER_GAMEPAD_GAMEPAD_DATA_FETCHER_H_
 #define CONTENT_BROWSER_GAMEPAD_GAMEPAD_DATA_FETCHER_H_
 
-#include <stdint.h>
-
-#include "build/build_config.h"
-#include "content/browser/gamepad/gamepad_standard_mappings.h"
-#include "third_party/WebKit/public/platform/WebGamepads.h"
+#include "content/browser/gamepad/gamepad_provider.h"
+#include "content/common/content_export.h"
 
 namespace content {
 
-// Abstract interface for imlementing platform- (and test-) specific behaviro
+// Abstract interface for imlementing platform- (and test-) specific behavior
 // for getting the gamepad data.
-class GamepadDataFetcher {
+class CONTENT_EXPORT GamepadDataFetcher {
  public:
+  GamepadDataFetcher();
   virtual ~GamepadDataFetcher() {}
-  virtual void GetGamepadData(blink::WebGamepads* pads,
-                              bool devices_changed_hint) = 0;
-  virtual void PauseHint(bool paused) {}
-
-#if !defined(OS_ANDROID)
-  struct PadState {
-    // Gamepad data, unmapped.
-    blink::WebGamepad data;
 
-    // Functions to map from device data to standard layout, if available. May
-    // be null if no mapping is available.
-    GamepadStandardMappingFunction mapper;
+  virtual void GetGamepadData(bool devices_changed_hint) = 0;
+  virtual void PauseHint(bool paused) {}
 
-    // Sanitization masks
-    // axis_mask and button_mask are bitfields that represent the reset state of
-    // each input. If a button or axis has ever reported 0 in the past the
-    // corresponding bit will be set to 1.
+  GamepadProvider* provider() { return provider_; }
 
-    // If we ever increase the max axis count this will need to be updated.
-    static_assert(blink::WebGamepad::axesLengthCap <=
-        std::numeric_limits<uint32_t>::digits,
-        "axis_mask is not large enough");
-    uint32_t axis_mask;
+ protected:
+  friend GamepadProvider;
 
-    // If we ever increase the max button count this will need to be updated.
-    static_assert(blink::WebGamepad::buttonsLengthCap <=
-        std::numeric_limits<uint32_t>::digits,
-        "button_mask is not large enough");
-    uint32_t button_mask;
-  };
+  // To be called by the GamepadProvider on the polling thread;
+  void InitializeProvider(GamepadProvider* provider);
 
-  void MapAndSanitizeGamepadData(PadState* pad_state, blink::WebGamepad* pad);
+  // This call will happen on the gamepad polling thread. Any initialization
+  // that needs to happen on that thread should be done here, not in the
+  // constructor.
+  virtual void OnAddedToProvider() {};
 
- protected:
-  PadState pad_state_[blink::WebGamepads::itemsLengthCap];
-#endif
+ private:
+  GamepadProvider* provider_;
 };
 
 }  // namespace content
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher.cc b/content/browser/gamepad/gamepad_platform_data_fetcher.cc
deleted file mode 100644
index d889526..0000000
--- a/content/browser/gamepad/gamepad_platform_data_fetcher.cc
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher.cc
@@ -1,19 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "content/browser/gamepad/gamepad_platform_data_fetcher.h"
-
-#include "third_party/WebKit/public/platform/WebGamepads.h"
-
-namespace content {
-
-GamepadDataFetcherEmpty::GamepadDataFetcherEmpty() {
-}
-
-void GamepadDataFetcherEmpty::GetGamepadData(blink::WebGamepads* pads,
-                                             bool devices_changed_hint) {
-  pads->length = 0;
-}
-
-}  // namespace content
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher.h b/content/browser/gamepad/gamepad_platform_data_fetcher.h
index d2dc8b7..02c587b 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher.h
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher.h
@@ -12,50 +12,51 @@
 #include "base/macros.h"
 #include "build/build_config.h"
 #include "content/browser/gamepad/gamepad_data_fetcher.h"
+#include "content/browser/gamepad/gamepad_provider.h"
+
+#include <memory>
 
 #if defined(OS_ANDROID)
 #include "content/browser/gamepad/gamepad_platform_data_fetcher_android.h"
 #elif defined(OS_WIN)
 #include "content/browser/gamepad/gamepad_platform_data_fetcher_win.h"
+#include "content/browser/gamepad/raw_input_data_fetcher_win.h"
 #elif defined(OS_MACOSX)
 #include "content/browser/gamepad/gamepad_platform_data_fetcher_mac.h"
+#include "content/browser/gamepad/xbox_data_fetcher_mac.h"
 #elif defined(OS_LINUX)
 #include "content/browser/gamepad/gamepad_platform_data_fetcher_linux.h"
 #endif
 
 namespace content {
 
+void AddGamepadPlatformDataFetchers(GamepadProvider* provider) {
 #if defined(OS_ANDROID)
 
-typedef GamepadPlatformDataFetcherAndroid GamepadPlatformDataFetcher;
+  provider->AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher>(
+      new GamepadPlatformDataFetcherAndroid()));
 
 #elif defined(OS_WIN)
 
-typedef GamepadPlatformDataFetcherWin GamepadPlatformDataFetcher;
+  provider->AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher>(
+      new GamepadPlatformDataFetcherWin()));
+  provider->AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher>(
+      new RawInputDataFetcher()));
 
 #elif defined(OS_MACOSX)
 
-typedef GamepadPlatformDataFetcherMac GamepadPlatformDataFetcher;
+  provider->AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher>(
+      new GamepadPlatformDataFetcherMac()));
+  provider->AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher>(
+      new XboxDataFetcher()));
 
 #elif defined(OS_LINUX) && defined(USE_UDEV)
 
-typedef GamepadPlatformDataFetcherLinux GamepadPlatformDataFetcher;
-
-#else
-
-class GamepadDataFetcherEmpty : public GamepadDataFetcher {
- public:
-  GamepadDataFetcherEmpty();
-
-  void GetGamepadData(blink::WebGamepads* pads,
-                      bool devices_changed_hint) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(GamepadDataFetcherEmpty);
-};
-typedef GamepadDataFetcherEmpty GamepadPlatformDataFetcher;
+  provider->AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher>(
+      new GamepadPlatformDataFetcherLinux()));
 
 #endif
+}
 
 }  // namespace content
 
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_android.cc b/content/browser/gamepad/gamepad_platform_data_fetcher_android.cc
index 1e38cc7..b9b7360 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_android.cc
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_android.cc
@@ -35,25 +35,25 @@ GamepadPlatformDataFetcherAndroid::RegisterGamepadPlatformDataFetcherAndroid(
 }
 
 GamepadPlatformDataFetcherAndroid::GamepadPlatformDataFetcherAndroid() {
-  PauseHint(false);
 }
 
 GamepadPlatformDataFetcherAndroid::~GamepadPlatformDataFetcherAndroid() {
   PauseHint(true);
 }
 
+void GamepadPlatformDataFetcherAndroid::OnAddedToProvider() {
+  PauseHint(false);
+}
+
 void GamepadPlatformDataFetcherAndroid::GetGamepadData(
-    blink::WebGamepads* pads,
     bool devices_changed_hint) {
   TRACE_EVENT0("GAMEPAD", "GetGamepadData");
 
-  pads->length = 0;
-
   JNIEnv* env = AttachCurrentThread();
   if (!env)
     return;
 
-  Java_GamepadList_updateGamepadData(env, reinterpret_cast<intptr_t>(pads));
+  Java_GamepadList_updateGamepadData(env, reinterpret_cast<intptr_t>(this));
 }
 
 void GamepadPlatformDataFetcherAndroid::PauseHint(bool paused) {
@@ -66,7 +66,7 @@ void GamepadPlatformDataFetcherAndroid::PauseHint(bool paused) {
 
 static void SetGamepadData(JNIEnv* env,
                            const JavaParamRef<jobject>& obj,
-                           jlong gamepads,
+                           jlong data_fetcher,
                            jint index,
                            jboolean mapping,
                            jboolean connected,
@@ -74,47 +74,47 @@ static void SetGamepadData(JNIEnv* env,
                            jlong timestamp,
                            const JavaParamRef<jfloatArray>& jaxes,
                            const JavaParamRef<jfloatArray>& jbuttons) {
-  DCHECK(gamepads);
-  blink::WebGamepads* pads = reinterpret_cast<WebGamepads*>(gamepads);
-  DCHECK_EQ(pads->length, unsigned(index));
+  DCHECK(data_fetcher);
+  GamepadPlatformDataFetcherAndroid* fetcher =
+    reinterpret_cast<GamepadPlatformDataFetcherAndroid*>(data_fetcher);
   DCHECK_LT(index, static_cast<int>(blink::WebGamepads::itemsLengthCap));
 
-  ++pads->length;
-
-  blink::WebGamepad& pad = pads->items[index];
-
-  pad.connected = connected;
-
-  pad.timestamp = timestamp;
-
   // Do not set gamepad parameters for all the gamepad devices that are not
   // attached.
   if (!connected)
     return;
 
-  // Map the Gamepad DeviceName String to the WebGamepad Id. Ideally it should
-  // be mapped to vendor and product information but it is only available at
-  // kernel level and it can not be queried using class
-  // android.hardware.input.InputManager.
-  // TODO(SaurabhK): Store a cached WebGamePad object in
-  // GamepadPlatformDataFetcherAndroid and only update constant WebGamepad
-  // values when a device has changed.
-  base::string16 device_name;
-  base::android::ConvertJavaStringToUTF16(env, devicename, &device_name);
-  const size_t name_to_copy =
-      std::min(device_name.size(), WebGamepad::idLengthCap - 1);
-  memcpy(pad.id,
-         device_name.data(),
-         name_to_copy * sizeof(base::string16::value_type));
-  pad.id[name_to_copy] = 0;
-
-  base::string16 mapping_name = base::UTF8ToUTF16(mapping ? "standard" : "");
-  const size_t mapping_to_copy =
-      std::min(mapping_name.size(), WebGamepad::mappingLengthCap - 1);
-  memcpy(pad.mapping,
-         mapping_name.data(),
-         mapping_to_copy * sizeof(base::string16::value_type));
-  pad.mapping[mapping_to_copy] = 0;
+  PadState* state = fetcher->provider()->GetPadState(
+      GAMEPAD_SOURCE_ANDROID, index);
+
+  if (!state)
+    return;
+
+  blink::WebGamepad& pad = state->data;
+
+  // Is this the first time we've seen this device?
+  if (state->active_state == GAMEPAD_NEWLY_ACTIVE) {
+    // Map the Gamepad DeviceName String to the WebGamepad Id. Ideally it should
+    // be mapped to vendor and product information but it is only available at
+    // kernel level and it can not be queried using class
+    // android.hardware.input.InputManager.
+    base::string16 device_name;
+    base::android::ConvertJavaStringToUTF16(env, devicename, &device_name);
+    const size_t name_to_copy =
+        std::min(device_name.size(), WebGamepad::idLengthCap - 1);
+    memcpy(pad.id,
+           device_name.data(),
+           name_to_copy * sizeof(base::string16::value_type));
+    pad.id[name_to_copy] = 0;
+
+    base::string16 mapping_name = base::UTF8ToUTF16(mapping ? "standard" : "");
+    const size_t mapping_to_copy =
+        std::min(mapping_name.size(), WebGamepad::mappingLengthCap - 1);
+    memcpy(pad.mapping,
+           mapping_name.data(),
+           mapping_to_copy * sizeof(base::string16::value_type));
+    pad.mapping[mapping_to_copy] = 0;
+  }
 
   pad.timestamp = timestamp;
 
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_android.h b/content/browser/gamepad/gamepad_platform_data_fetcher_android.h
index c6ea2e3..6282577 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_android.h
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_android.h
@@ -26,13 +26,14 @@ class GamepadPlatformDataFetcherAndroid : public GamepadDataFetcher {
 
   void PauseHint(bool paused) override;
 
-  void GetGamepadData(blink::WebGamepads* pads,
-                      bool devices_changed_hint) override;
+  void GetGamepadData(bool devices_changed_hint) override;
 
   // Registers the JNI methods for GamepadsReader.
   static bool RegisterGamepadPlatformDataFetcherAndroid(JNIEnv* env);
 
  private:
+  void OnAddedToProvider() override;
+
   DISALLOW_COPY_AND_ASSIGN(GamepadPlatformDataFetcherAndroid);
 };
 
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_linux.cc b/content/browser/gamepad/gamepad_platform_data_fetcher_linux.cc
index 87ec371..daf44f1 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_linux.cc
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_linux.cc
@@ -11,8 +11,6 @@
 #include <sys/types.h>
 #include <unistd.h>
 
-#include "base/macros.h"
-#include "base/message_loop/message_loop.h"
 #include "base/posix/eintr_wrapper.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
@@ -70,29 +68,28 @@ using blink::WebGamepad;
 using blink::WebGamepads;
 
 GamepadPlatformDataFetcherLinux::GamepadPlatformDataFetcherLinux() {
-  for (size_t i = 0; i < arraysize(pad_state_); ++i) {
+  for (size_t i = 0; i < arraysize(device_fd_); ++i) {
     device_fd_[i] = -1;
-    pad_state_[i].mapper = 0;
-    pad_state_[i].axis_mask = 0;
-    pad_state_[i].button_mask = 0;
   }
+}
+
+GamepadPlatformDataFetcherLinux::~GamepadPlatformDataFetcherLinux() {
+  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i)
+    CloseFileDescriptorIfValid(device_fd_[i]);
+}
 
-  std::vector<device::UdevLinux::UdevMonitorFilter> filters;
+void GamepadPlatformDataFetcherLinux::OnAddedToProvider() {
+  std::vector<UdevLinux::UdevMonitorFilter> filters;
   filters.push_back(
       device::UdevLinux::UdevMonitorFilter(kInputSubsystem, NULL));
-  udev_.reset(new device::UdevLinux(
+  udev_.reset(new UdevLinux(
       filters, base::Bind(&GamepadPlatformDataFetcherLinux::RefreshDevice,
                           base::Unretained(this))));
 
   EnumerateDevices();
 }
 
-GamepadPlatformDataFetcherLinux::~GamepadPlatformDataFetcherLinux() {
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i)
-    CloseFileDescriptorIfValid(device_fd_[i]);
-}
-
-void GamepadPlatformDataFetcherLinux::GetGamepadData(WebGamepads* pads, bool) {
+void GamepadPlatformDataFetcherLinux::GetGamepadData(bool) {
   TRACE_EVENT0("GAMEPAD", "GetGamepadData");
 
   // Update our internal state.
@@ -101,11 +98,6 @@ void GamepadPlatformDataFetcherLinux::GetGamepadData(WebGamepads* pads, bool) {
       ReadDeviceData(i);
     }
   }
-
-  pads->length = WebGamepads::itemsLengthCap;
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-    MapAndSanitizeGamepadData(&pad_state_[i], &pads->items[i]);
-  }
 }
 
 // Used during enumeration, and monitor notifications.
@@ -114,8 +106,6 @@ void GamepadPlatformDataFetcherLinux::RefreshDevice(udev_device* dev) {
   std::string node_path;
   if (IsGamepad(dev, &index, &node_path))  {
     int& device_fd = device_fd_[index];
-    WebGamepad& pad = pad_state_[index].data;
-    GamepadStandardMappingFunction& mapper = pad_state_[index].mapper;
 
     CloseFileDescriptorIfValid(device_fd);
 
@@ -128,17 +118,26 @@ void GamepadPlatformDataFetcherLinux::RefreshDevice(udev_device* dev) {
     if (!dev) {
       // Unable to get device information, don't use this device.
       device_fd = -1;
-      pad.connected = false;
       return;
     }
 
     device_fd = HANDLE_EINTR(open(node_path.c_str(), O_RDONLY | O_NONBLOCK));
     if (device_fd < 0) {
       // Unable to open device, don't use.
-      pad.connected = false;
       return;
     }
 
+    PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_LINUX_UDEV, index);
+    if (!state) {
+      // No slot available for device, don't use.
+      CloseFileDescriptorIfValid(device_fd);
+      device_fd = -1;
+      return;
+    }
+
+    WebGamepad& pad = state->data;
+    GamepadStandardMappingFunction& mapper = state->mapper;
+
     const char* vendor_id =
         device::udev_device_get_sysattr_value(dev, "id/vendor");
     const char* product_id =
@@ -200,9 +199,6 @@ void GamepadPlatformDataFetcherLinux::RefreshDevice(udev_device* dev) {
       pad.mapping[0] = 0;
     }
 
-    pad_state_[index].axis_mask = 0;
-    pad_state_[index].button_mask = 0;
-
     pad.connected = true;
   }
 }
@@ -242,10 +238,15 @@ void GamepadPlatformDataFetcherLinux::ReadDeviceData(size_t index) {
     return;
   }
 
-  const int& fd = device_fd_[index];
-  WebGamepad& pad = pad_state_[index].data;
+  PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_LINUX_UDEV, index);
+  if (!state)
+    return;
+
+  int fd = device_fd_[index];
   DCHECK_GE(fd, 0);
 
+  WebGamepad& pad = state->data;
+
   js_event event;
   while (HANDLE_EINTR(read(fd, &event, sizeof(struct js_event))) > 0) {
     size_t item = event.number;
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_linux.h b/content/browser/gamepad/gamepad_platform_data_fetcher_linux.h
index 763f191..f604d29 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_linux.h
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_linux.h
@@ -7,11 +7,12 @@
 
 #include <stddef.h>
 
+#include <memory>
 #include <string>
 
 #include "base/compiler_specific.h"
+
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "content/browser/gamepad/gamepad_data_fetcher.h"
 
 extern "C" {
@@ -30,10 +31,11 @@ class GamepadPlatformDataFetcherLinux : public GamepadDataFetcher {
   ~GamepadPlatformDataFetcherLinux() override;
 
   // GamepadDataFetcher implementation.
-  void GetGamepadData(blink::WebGamepads* pads,
-                      bool devices_changed_hint) override;
+  void GetGamepadData(bool devices_changed_hint) override;
 
  private:
+  void OnAddedToProvider() override;
+
   void RefreshDevice(udev_device* dev);
   void EnumerateDevices();
   void ReadDeviceData(size_t index);
@@ -41,7 +43,7 @@ class GamepadPlatformDataFetcherLinux : public GamepadDataFetcher {
   // File descriptor for the /dev/input/js* devices. -1 if not in use.
   int device_fd_[blink::WebGamepads::itemsLengthCap];
 
-  scoped_ptr<device::UdevLinux> udev_;
+  std::unique_ptr<device::UdevLinux> udev_;
 
   DISALLOW_COPY_AND_ASSIGN(GamepadPlatformDataFetcherLinux);
 };
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_mac.h b/content/browser/gamepad/gamepad_platform_data_fetcher_mac.h
index ebfe57e..4546dca 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_mac.h
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_mac.h
@@ -5,19 +5,17 @@
 #ifndef CONTENT_BROWSER_GAMEPAD_GAMEPAD_PLATFORM_DATA_FETCHER_MAC_H_
 #define CONTENT_BROWSER_GAMEPAD_GAMEPAD_PLATFORM_DATA_FETCHER_MAC_H_
 
+#include <CoreFoundation/CoreFoundation.h>
+#include <IOKit/hid/IOHIDManager.h>
 #include <stddef.h>
 
+#include <memory>
+
 #include "base/compiler_specific.h"
 #include "base/mac/scoped_cftyperef.h"
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "build/build_config.h"
 #include "content/browser/gamepad/gamepad_data_fetcher.h"
-#include "content/browser/gamepad/xbox_data_fetcher_mac.h"
-#include "content/common/gamepad_hardware_buffer.h"
-
-#include <CoreFoundation/CoreFoundation.h>
-#include <IOKit/hid/IOHIDManager.h>
 
 #if defined(__OBJC__)
 @class NSArray;
@@ -27,13 +25,11 @@ class NSArray;
 
 namespace content {
 
-class GamepadPlatformDataFetcherMac : public GamepadDataFetcher,
-                                      public XboxDataFetcher::Delegate {
+class GamepadPlatformDataFetcherMac : public GamepadDataFetcher {
  public:
   GamepadPlatformDataFetcherMac();
   ~GamepadPlatformDataFetcherMac() override;
-  void GetGamepadData(blink::WebGamepads* pads,
-                      bool devices_changed_hint) override;
+  void GetGamepadData(bool devices_changed_hint) override;
   void PauseHint(bool paused) override;
 
  private:
@@ -55,44 +51,28 @@ class GamepadPlatformDataFetcherMac : public GamepadDataFetcher,
                                    void* sender,
                                    IOHIDValueRef ref);
 
+  void OnAddedToProvider() override;
+
   size_t GetEmptySlot();
   size_t GetSlotForDevice(IOHIDDeviceRef device);
-  size_t GetSlotForXboxDevice(XboxController* device);
 
   void DeviceAdd(IOHIDDeviceRef device);
-  bool AddButtonsAndAxes(NSArray* elements, size_t slot);
+  bool AddButtonsAndAxes(NSArray* elements, PadState* state, size_t slot);
   void DeviceRemove(IOHIDDeviceRef device);
   void ValueChanged(IOHIDValueRef value);
 
-  void XboxDeviceAdd(XboxController* device) override;
-  void XboxDeviceRemove(XboxController* device) override;
-  void XboxValueChanged(XboxController* device,
-                        const XboxController::Data& data) override;
-
   void RegisterForNotifications();
   void UnregisterFromNotifications();
 
-  void SanitizeGamepadData(size_t index, blink::WebGamepad* pad);
-
-  scoped_ptr<XboxDataFetcher> xbox_fetcher_;
-
   // Side-band data that's not passed to the consumer, but we need to maintain
   // to update data_.
   struct AssociatedData {
-    bool is_xbox;
-    union {
-      struct {
-        IOHIDDeviceRef device_ref;
-        IOHIDElementRef button_elements[blink::WebGamepad::buttonsLengthCap];
-        IOHIDElementRef axis_elements[blink::WebGamepad::axesLengthCap];
-        CFIndex axis_minimums[blink::WebGamepad::axesLengthCap];
-        CFIndex axis_maximums[blink::WebGamepad::axesLengthCap];
-      } hid;
-      struct {
-        XboxController* device;
-        UInt32 location_id;
-      } xbox;
-    };
+    int location_id;
+    IOHIDDeviceRef device_ref;
+    IOHIDElementRef button_elements[blink::WebGamepad::buttonsLengthCap];
+    IOHIDElementRef axis_elements[blink::WebGamepad::axesLengthCap];
+    CFIndex axis_minimums[blink::WebGamepad::axesLengthCap];
+    CFIndex axis_maximums[blink::WebGamepad::axesLengthCap];
   };
   AssociatedData associated_[blink::WebGamepads::itemsLengthCap];
 
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_mac.mm b/content/browser/gamepad/gamepad_platform_data_fetcher_mac.mm
index 4d55c55..609d29f 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_mac.mm
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_mac.mm
@@ -57,13 +57,12 @@ const uint32_t kAxisMinimumUsageNumber = 0x30;
 }  // namespace
 
 GamepadPlatformDataFetcherMac::GamepadPlatformDataFetcherMac()
-    : enabled_(true), paused_(false) {
+    : enabled_(true),
+      paused_(false) {
   memset(associated_, 0, sizeof(associated_));
+}
 
-  xbox_fetcher_.reset(new XboxDataFetcher(this));
-  if (!xbox_fetcher_->RegisterForNotifications())
-    xbox_fetcher_.reset();
-
+void GamepadPlatformDataFetcherMac::OnAddedToProvider() {
   hid_manager_ref_.reset(IOHIDManagerCreate(kCFAllocatorDefault,
                                             kIOHIDOptionsTypeNone));
   if (CFGetTypeID(hid_manager_ref_) != IOHIDManagerGetTypeID()) {
@@ -107,9 +106,6 @@ void GamepadPlatformDataFetcherMac::RegisterForNotifications() {
 
   enabled_ = IOHIDManagerOpen(hid_manager_ref_,
                               kIOHIDOptionsTypeNone) == kIOReturnSuccess;
-
-  if (xbox_fetcher_)
-    xbox_fetcher_->RegisterForNotifications();
 }
 
 void GamepadPlatformDataFetcherMac::UnregisterFromNotifications() {
@@ -118,8 +114,6 @@ void GamepadPlatformDataFetcherMac::UnregisterFromNotifications() {
       CFRunLoopGetCurrent(),
       kCFRunLoopDefaultMode);
   IOHIDManagerClose(hid_manager_ref_, kIOHIDOptionsTypeNone);
-  if (xbox_fetcher_)
-    xbox_fetcher_->UnregisterFromNotifications();
 }
 
 void GamepadPlatformDataFetcherMac::PauseHint(bool pause) {
@@ -157,10 +151,10 @@ void GamepadPlatformDataFetcherMac::ValueChangedCallback(void* context,
 }
 
 bool GamepadPlatformDataFetcherMac::AddButtonsAndAxes(NSArray* elements,
+                                                      PadState* state,
                                                       size_t slot) {
-  WebGamepad& pad = pad_state_[slot].data;
+  WebGamepad& pad = state->data;
   AssociatedData& associated = associated_[slot];
-  CHECK(!associated.is_xbox);
 
   pad.axesLength = 0;
   pad.buttonsLength = 0;
@@ -178,18 +172,18 @@ bool GamepadPlatformDataFetcherMac::AddButtonsAndAxes(NSArray* elements,
         usage_page == kButtonUsagePage) {
       uint32_t button_index = usage - 1;
       if (button_index < WebGamepad::buttonsLengthCap) {
-        associated.hid.button_elements[button_index] = element;
+        associated.button_elements[button_index] = element;
         pad.buttonsLength = std::max(pad.buttonsLength, button_index + 1);
       }
     }
     else if (IOHIDElementGetType(element) == kIOHIDElementTypeInput_Misc) {
       uint32_t axis_index = usage - kAxisMinimumUsageNumber;
       if (axis_index < WebGamepad::axesLengthCap) {
-        associated.hid.axis_minimums[axis_index] =
+        associated.axis_minimums[axis_index] =
             IOHIDElementGetLogicalMin(element);
-        associated.hid.axis_maximums[axis_index] =
+        associated.axis_maximums[axis_index] =
             IOHIDElementGetLogicalMax(element);
-        associated.hid.axis_elements[axis_index] = element;
+        associated.axis_elements[axis_index] = element;
         pad.axesLength = std::max(pad.axesLength, axis_index + 1);
       } else {
         mapped_all_axes = false;
@@ -208,15 +202,15 @@ bool GamepadPlatformDataFetcherMac::AddButtonsAndAxes(NSArray* elements,
           usage - kAxisMinimumUsageNumber >= WebGamepad::axesLengthCap &&
           usage_page <= kGameControlsUsagePage) {
         for (; next_index < WebGamepad::axesLengthCap; ++next_index) {
-          if (associated.hid.axis_elements[next_index] == NULL)
+          if (associated.axis_elements[next_index] == NULL)
             break;
         }
         if (next_index < WebGamepad::axesLengthCap) {
-          associated.hid.axis_minimums[next_index] =
+          associated.axis_minimums[next_index] =
               IOHIDElementGetLogicalMin(element);
-          associated.hid.axis_maximums[next_index] =
+          associated.axis_maximums[next_index] =
               IOHIDElementGetLogicalMax(element);
-          associated.hid.axis_elements[next_index] = element;
+          associated.axis_elements[next_index] = element;
           pad.axesLength = std::max(pad.axesLength, next_index + 1);
         }
       }
@@ -232,7 +226,7 @@ bool GamepadPlatformDataFetcherMac::AddButtonsAndAxes(NSArray* elements,
 size_t GamepadPlatformDataFetcherMac::GetEmptySlot() {
   // Find a free slot for this device.
   for (size_t slot = 0; slot < WebGamepads::itemsLengthCap; ++slot) {
-    if (!pad_state_[slot].data.connected)
+    if (associated_[slot].device_ref == nullptr)
       return slot;
   }
   return WebGamepads::itemsLengthCap;
@@ -242,34 +236,12 @@ size_t GamepadPlatformDataFetcherMac::GetSlotForDevice(IOHIDDeviceRef device) {
   for (size_t slot = 0; slot < WebGamepads::itemsLengthCap; ++slot) {
     // If we already have this device, and it's already connected, don't do
     // anything now.
-    if (pad_state_[slot].data.connected &&
-        !associated_[slot].is_xbox &&
-        associated_[slot].hid.device_ref == device)
+    if (associated_[slot].device_ref == device)
       return WebGamepads::itemsLengthCap;
   }
   return GetEmptySlot();
 }
 
-size_t GamepadPlatformDataFetcherMac::GetSlotForXboxDevice(
-    XboxController* device) {
-  for (size_t slot = 0; slot < WebGamepads::itemsLengthCap; ++slot) {
-    if (associated_[slot].is_xbox &&
-        associated_[slot].xbox.location_id == device->location_id()) {
-      if (pad_state_[slot].data.connected) {
-        // The device is already connected. No idea why we got a second "device
-        // added" call, but let's not add it twice.
-        DCHECK_EQ(associated_[slot].xbox.device, device);
-        return WebGamepads::itemsLengthCap;
-      } else {
-        // A device with the same location ID was previously connected, so put
-        // it in the same slot.
-        return slot;
-      }
-    }
-  }
-  return GetEmptySlot();
-}
-
 void GamepadPlatformDataFetcherMac::DeviceAdd(IOHIDDeviceRef device) {
   using base::mac::CFToNSCast;
   using base::mac::CFCastStrict;
@@ -277,9 +249,12 @@ void GamepadPlatformDataFetcherMac::DeviceAdd(IOHIDDeviceRef device) {
   if (!enabled_)
     return;
 
+  NSNumber* location_id = CFToNSCast(CFCastStrict<CFNumberRef>(
+      IOHIDDeviceGetProperty(device, CFSTR(kIOHIDLocationIDKey))));
+  int location_int = [location_id intValue];
+
   // Find an index for this device.
   size_t slot = GetSlotForDevice(device);
-
   // We can't handle this many connected devices.
   if (slot == WebGamepads::itemsLengthCap)
     return;
@@ -287,10 +262,16 @@ void GamepadPlatformDataFetcherMac::DeviceAdd(IOHIDDeviceRef device) {
   // Clear some state that may have been left behind by previous gamepads
   memset(&associated_[slot], 0, sizeof(AssociatedData));
 
+  PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_MAC_HID,
+                                            location_int);
+  if (!state)
+    return; // No available slot for this device
+
   NSNumber* vendor_id = CFToNSCast(CFCastStrict<CFNumberRef>(
       IOHIDDeviceGetProperty(device, CFSTR(kIOHIDVendorIDKey))));
   NSNumber* product_id = CFToNSCast(CFCastStrict<CFNumberRef>(
       IOHIDDeviceGetProperty(device, CFSTR(kIOHIDProductIDKey))));
+
   NSString* product = CFToNSCast(CFCastStrict<CFStringRef>(
       IOHIDDeviceGetProperty(device, CFSTR(kIOHIDProductKey))));
   int vendor_int = [vendor_id intValue];
@@ -299,39 +280,38 @@ void GamepadPlatformDataFetcherMac::DeviceAdd(IOHIDDeviceRef device) {
   char vendor_as_str[5], product_as_str[5];
   snprintf(vendor_as_str, sizeof(vendor_as_str), "%04x", vendor_int);
   snprintf(product_as_str, sizeof(product_as_str), "%04x", product_int);
-  pad_state_[slot].mapper =
+  state->mapper =
       GetGamepadStandardMappingFunction(vendor_as_str, product_as_str);
 
   NSString* ident = [NSString stringWithFormat:
       @"%@ (%sVendor: %04x Product: %04x)",
       product,
-      pad_state_[slot].mapper ? "STANDARD GAMEPAD " : "",
+      state->mapper ? "STANDARD GAMEPAD " : "",
       vendor_int,
       product_int];
   CopyNSStringAsUTF16LittleEndian(
       ident,
-      pad_state_[slot].data.id,
-      sizeof(pad_state_[slot].data.id));
+      state->data.id,
+      sizeof(state->data.id));
 
-  if (pad_state_[slot].mapper) {
+  if (state->mapper) {
     CopyNSStringAsUTF16LittleEndian(
       @"standard",
-      pad_state_[slot].data.mapping,
-      sizeof(pad_state_[slot].data.mapping));
+      state->data.mapping,
+      sizeof(state->data.mapping));
   } else {
-    pad_state_[slot].data.mapping[0] = 0;
+    state->data.mapping[0] = 0;
   }
 
   base::ScopedCFTypeRef<CFArrayRef> elements(
       IOHIDDeviceCopyMatchingElements(device, NULL, kIOHIDOptionsTypeNone));
 
-  if (!AddButtonsAndAxes(CFToNSCast(elements), slot))
+  if (!AddButtonsAndAxes(CFToNSCast(elements), state, slot))
     return;
 
-  associated_[slot].hid.device_ref = device;
-  pad_state_[slot].data.connected = true;
-  pad_state_[slot].axis_mask = 0;
-  pad_state_[slot].button_mask = 0;
+  associated_[slot].location_id = location_int;
+  associated_[slot].device_ref = device;
+  state->data.connected = true;
 }
 
 void GamepadPlatformDataFetcherMac::DeviceRemove(IOHIDDeviceRef device) {
@@ -341,15 +321,14 @@ void GamepadPlatformDataFetcherMac::DeviceRemove(IOHIDDeviceRef device) {
   // Find the index for this device.
   size_t slot;
   for (slot = 0; slot < WebGamepads::itemsLengthCap; ++slot) {
-    if (pad_state_[slot].data.connected &&
-        !associated_[slot].is_xbox &&
-        associated_[slot].hid.device_ref == device)
+    if (associated_[slot].device_ref == device)
       break;
   }
   DCHECK(slot < WebGamepads::itemsLengthCap);
   // Leave associated device_ref so that it will be reconnected in the same
   // location. Simply mark it as disconnected.
-  pad_state_[slot].data.connected = false;
+  associated_[slot].location_id = 0;
+  associated_[slot].device_ref = nullptr;
 }
 
 void GamepadPlatformDataFetcherMac::ValueChanged(IOHIDValueRef value) {
@@ -362,15 +341,18 @@ void GamepadPlatformDataFetcherMac::ValueChanged(IOHIDValueRef value) {
   // Find device slot.
   size_t slot;
   for (slot = 0; slot < WebGamepads::itemsLengthCap; ++slot) {
-    if (pad_state_[slot].data.connected &&
-        !associated_[slot].is_xbox &&
-        associated_[slot].hid.device_ref == device)
+    if (associated_[slot].device_ref == device)
       break;
   }
   if (slot == WebGamepads::itemsLengthCap)
     return;
 
-  WebGamepad& pad = pad_state_[slot].data;
+  PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_MAC_HID,
+                                            associated_[slot].location_id);
+  if (!state)
+    return;
+
+  WebGamepad& pad = state->data;
   AssociatedData& associated = associated_[slot];
 
   uint32_t value_length = IOHIDValueGetLength(value);
@@ -382,7 +364,7 @@ void GamepadPlatformDataFetcherMac::ValueChanged(IOHIDValueRef value) {
 
   // Find and fill in the associated button event, if any.
   for (size_t i = 0; i < pad.buttonsLength; ++i) {
-    if (associated.hid.button_elements[i] == element) {
+    if (associated.button_elements[i] == element) {
       pad.buttons[i].pressed = IOHIDValueGetIntegerValue(value);
       pad.buttons[i].value = pad.buttons[i].pressed ? 1.f : 0.f;
       pad.timestamp = std::max(pad.timestamp, IOHIDValueGetTimeStamp(value));
@@ -392,119 +374,27 @@ void GamepadPlatformDataFetcherMac::ValueChanged(IOHIDValueRef value) {
 
   // Find and fill in the associated axis event, if any.
   for (size_t i = 0; i < pad.axesLength; ++i) {
-    if (associated.hid.axis_elements[i] == element) {
+    if (associated.axis_elements[i] == element) {
       pad.axes[i] = NormalizeAxis(IOHIDValueGetIntegerValue(value),
-                                  associated.hid.axis_minimums[i],
-                                  associated.hid.axis_maximums[i]);
+                                  associated.axis_minimums[i],
+                                  associated.axis_maximums[i]);
       pad.timestamp = std::max(pad.timestamp, IOHIDValueGetTimeStamp(value));
       return;
     }
   }
 }
 
-void GamepadPlatformDataFetcherMac::XboxDeviceAdd(XboxController* device) {
+void GamepadPlatformDataFetcherMac::GetGamepadData(bool) {
   if (!enabled_)
     return;
 
-  size_t slot = GetSlotForXboxDevice(device);
-
-  // We can't handle this many connected devices.
-  if (slot == WebGamepads::itemsLengthCap)
-    return;
-
-  device->SetLEDPattern(
-      (XboxController::LEDPattern)(XboxController::LED_FLASH_TOP_LEFT + slot));
-
-  NSString* ident =
-      [NSString stringWithFormat:
-          @"%@ (STANDARD GAMEPAD Vendor: %04x Product: %04x)",
-              device->GetControllerType() == XboxController::XBOX_360_CONTROLLER
-                  ? @"Xbox 360 Controller"
-                  : @"Xbox One Controller",
-              device->GetProductId(), device->GetVendorId()];
-  CopyNSStringAsUTF16LittleEndian(
-      ident,
-      pad_state_[slot].data.id,
-      sizeof(pad_state_[slot].data.id));
-
-  CopyNSStringAsUTF16LittleEndian(
-    @"standard",
-    pad_state_[slot].data.mapping,
-    sizeof(pad_state_[slot].data.mapping));
-
-  associated_[slot].is_xbox = true;
-  associated_[slot].xbox.device = device;
-  associated_[slot].xbox.location_id = device->location_id();
-  pad_state_[slot].data.connected = true;
-  pad_state_[slot].data.axesLength = 4;
-  pad_state_[slot].data.buttonsLength = 17;
-  pad_state_[slot].data.timestamp = 0;
-  pad_state_[slot].mapper = 0;
-  pad_state_[slot].axis_mask = 0;
-  pad_state_[slot].button_mask = 0;
-}
-
-void GamepadPlatformDataFetcherMac::XboxDeviceRemove(XboxController* device) {
-  if (!enabled_)
-    return;
-
-  // Find the index for this device.
-  size_t slot;
-  for (slot = 0; slot < WebGamepads::itemsLengthCap; ++slot) {
-    if (pad_state_[slot].data.connected &&
-        associated_[slot].is_xbox &&
-        associated_[slot].xbox.device == device)
-      break;
-  }
-  DCHECK(slot < WebGamepads::itemsLengthCap);
-  // Leave associated location id so that the controller will be reconnected in
-  // the same slot if it is plugged in again. Simply mark it as disconnected.
-  pad_state_[slot].data.connected = false;
-}
-
-void GamepadPlatformDataFetcherMac::XboxValueChanged(
-    XboxController* device, const XboxController::Data& data) {
-  // Find device slot.
-  size_t slot;
-  for (slot = 0; slot < WebGamepads::itemsLengthCap; ++slot) {
-    if (pad_state_[slot].data.connected &&
-        associated_[slot].is_xbox &&
-        associated_[slot].xbox.device == device)
-      break;
-  }
-  if (slot == WebGamepads::itemsLengthCap)
-    return;
-
-  WebGamepad& pad = pad_state_[slot].data;
-
-  for (size_t i = 0; i < 6; i++) {
-    pad.buttons[i].pressed = data.buttons[i];
-    pad.buttons[i].value = data.buttons[i] ? 1.0f : 0.0f;
-  }
-  pad.buttons[6].pressed = data.triggers[0] > kDefaultButtonPressedThreshold;
-  pad.buttons[6].value = data.triggers[0];
-  pad.buttons[7].pressed = data.triggers[1] > kDefaultButtonPressedThreshold;
-  pad.buttons[7].value = data.triggers[1];
-  for (size_t i = 8; i < 17; i++) {
-    pad.buttons[i].pressed = data.buttons[i - 2];
-    pad.buttons[i].value = data.buttons[i - 2] ? 1.0f : 0.0f;
-  }
-  for (size_t i = 0; i < arraysize(data.axes); i++) {
-    pad.axes[i] = data.axes[i];
-  }
-
-  pad.timestamp = base::TimeTicks::Now().ToInternalValue();
-}
-
-void GamepadPlatformDataFetcherMac::GetGamepadData(WebGamepads* pads, bool) {
-  if (!enabled_ && !xbox_fetcher_) {
-    pads->length = 0;
-    return;
+  // Loop through and GetPadState to indicate the devices are still connected.
+  for (size_t slot = 0; slot < WebGamepads::itemsLengthCap; ++slot) {
+    if (associated_[slot].device_ref != nullptr) {
+      provider()->GetPadState(GAMEPAD_SOURCE_MAC_HID,
+                              associated_[slot].location_id);
+    }
   }
-
-  pads->length = WebGamepads::itemsLengthCap;
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i)
-    MapAndSanitizeGamepadData(&pad_state_[i], &pads->items[i]);
 }
 
 }  // namespace content
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_win.cc b/content/browser/gamepad/gamepad_platform_data_fetcher_win.cc
index 3983694..cf64799 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_win.cc
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_win.cc
@@ -53,125 +53,73 @@ const WebUChar* GamepadSubTypeName(BYTE sub_type) {
   }
 }
 
+const WebUChar* XInputDllFileName() {
+  // Xinput.h defines filename (XINPUT_DLL) on different Windows versions, but
+  // Xinput.h specifies it in build time. Approach here uses the same values
+  // and it is resolving dll filename based on Windows version it is running on.
+  if (base::win::GetVersion() >= base::win::VERSION_WIN8) {
+    // For Windows 8 and 10, XINPUT_DLL is xinput1_4.dll.
+    return FILE_PATH_LITERAL("xinput1_4.dll");
+  } else if (base::win::GetVersion() >= base::win::VERSION_WIN7) {
+    return FILE_PATH_LITERAL("xinput9_1_0.dll");
+  } else {
+    NOTREACHED();
+    return nullptr;
+  }
+}
+
 }  // namespace
 
 GamepadPlatformDataFetcherWin::GamepadPlatformDataFetcherWin()
-    : xinput_dll_(base::FilePath(FILE_PATH_LITERAL("xinput1_3.dll"))),
-      xinput_available_(GetXInputDllFunctions()) {
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-    platform_pad_state_[i].status = DISCONNECTED;
-    pad_state_[i].mapper = NULL;
-    pad_state_[i].axis_mask = 0;
-    pad_state_[i].button_mask = 0;
-  }
-
-  raw_input_fetcher_.reset(new RawInputDataFetcher());
-  raw_input_fetcher_->StartMonitor();
+    : xinput_available_(false) {
 }
 
 GamepadPlatformDataFetcherWin::~GamepadPlatformDataFetcherWin() {
-  raw_input_fetcher_->StopMonitor();
 }
 
-int GamepadPlatformDataFetcherWin::FirstAvailableGamepadId() const {
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-    if (platform_pad_state_[i].status == DISCONNECTED)
-      return i;
-  }
-  return -1;
-}
-
-bool GamepadPlatformDataFetcherWin::HasXInputGamepad(int index) const {
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-    if (platform_pad_state_[i].status == XINPUT_CONNECTED &&
-        platform_pad_state_[i].xinput_index == index)
-      return true;
-  }
-  return false;
-}
-
-bool GamepadPlatformDataFetcherWin::HasRawInputGamepad(
-    const HANDLE handle) const {
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-    if (platform_pad_state_[i].status == RAWINPUT_CONNECTED &&
-        platform_pad_state_[i].raw_input_handle == handle)
-      return true;
-  }
-  return false;
+void GamepadPlatformDataFetcherWin::OnAddedToProvider() {
+  xinput_dll_.Reset(base::LoadNativeLibrary(
+      base::FilePath(XInputDllFileName()), nullptr));
+  xinput_available_ = GetXInputDllFunctions();
 }
 
 void GamepadPlatformDataFetcherWin::EnumerateDevices() {
   TRACE_EVENT0("GAMEPAD", "EnumerateDevices");
 
-  // Mark all disconnected pads DISCONNECTED.
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-    if (!pad_state_[i].data.connected)
-      platform_pad_state_[i].status = DISCONNECTED;
-  }
+  if (xinput_available_) {
+    for (size_t i = 0; i < XUSER_MAX_COUNT; ++i) {
+      // Check to see if the xinput device is connected
+      XINPUT_CAPABILITIES caps;
+      DWORD res = xinput_get_capabilities_(i, XINPUT_FLAG_GAMEPAD, &caps);
+      xinuput_connected_[i] = (res == ERROR_SUCCESS);
+      if (!xinuput_connected_[i])
+        continue;
 
-  for (size_t i = 0; i < XUSER_MAX_COUNT; ++i) {
-    if (HasXInputGamepad(i))
-      continue;
-    int pad_index = FirstAvailableGamepadId();
-    if (pad_index == -1)
-      return;  // We can't add any more gamepads.
-    WebGamepad& pad = pad_state_[pad_index].data;
-    if (xinput_available_ && GetXInputPadConnectivity(i, &pad)) {
-      platform_pad_state_[pad_index].status = XINPUT_CONNECTED;
-      platform_pad_state_[pad_index].xinput_index = i;
-      pad_state_[pad_index].mapper = NULL;
-      pad_state_[pad_index].axis_mask = 0;
-      pad_state_[pad_index].button_mask = 0;
-    }
-  }
+      PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_WIN_XINPUT, i);
+      if (!state)
+        continue;  // No slot available for this gamepad.
 
-  if (raw_input_fetcher_->Available()) {
-    std::vector<RawGamepadInfo*> raw_inputs =
-        raw_input_fetcher_->EnumerateDevices();
-    for (size_t i = 0; i < raw_inputs.size(); ++i) {
-      RawGamepadInfo* gamepad = raw_inputs[i];
-      if (gamepad->buttons_length == 0 && gamepad->axes_length == 0)
-        continue;
-      if (HasRawInputGamepad(gamepad->handle))
-        continue;
-      int pad_index = FirstAvailableGamepadId();
-      if (pad_index == -1)
-        return;
-      WebGamepad& pad = pad_state_[pad_index].data;
-      pad.connected = true;
-      PadState& state = pad_state_[pad_index];
-      PlatformPadState& platform_state = platform_pad_state_[pad_index];
-      platform_state.status = RAWINPUT_CONNECTED;
-      platform_state.raw_input_handle = gamepad->handle;
-
-      std::string vendor = base::StringPrintf("%04x", gamepad->vendor_id);
-      std::string product = base::StringPrintf("%04x", gamepad->product_id);
-      state.mapper = GetGamepadStandardMappingFunction(vendor, product);
-      state.axis_mask = 0;
-      state.button_mask = 0;
-
-      swprintf(pad.id, WebGamepad::idLengthCap,
-        L"%ls (%lsVendor: %04x Product: %04x)",
-        gamepad->id, state.mapper ? L"STANDARD GAMEPAD " : L"",
-        gamepad->vendor_id, gamepad->product_id);
-
-      if (state.mapper)
+      WebGamepad& pad = state->data;
+
+      if (state->active_state == GAMEPAD_NEWLY_ACTIVE) {
+        // This is the first time we've seen this device, so do some one-time
+        // initialization
+        pad.connected = true;
+        swprintf(pad.id,
+                 WebGamepad::idLengthCap,
+                 L"Xbox 360 Controller (XInput STANDARD %ls)",
+                 GamepadSubTypeName(caps.SubType));
         swprintf(pad.mapping, WebGamepad::mappingLengthCap, L"standard");
-      else
-        pad.mapping[0] = 0;
+      }
     }
   }
 }
 
-void GamepadPlatformDataFetcherWin::GetGamepadData(WebGamepads* pads,
-                                                   bool devices_changed_hint) {
+void GamepadPlatformDataFetcherWin::GetGamepadData(bool devices_changed_hint) {
   TRACE_EVENT0("GAMEPAD", "GetGamepadData");
 
-  if (!xinput_available_ &&
-      !raw_input_fetcher_->Available()) {
-    pads->length = 0;
+  if (!xinput_available_)
     return;
-  }
 
   // A note on XInput devices:
   // If we got notification that system devices have been updated, then
@@ -183,71 +131,32 @@ void GamepadPlatformDataFetcherWin::GetGamepadData(WebGamepads* pads,
   if (devices_changed_hint)
     EnumerateDevices();
 
-  pads->length = 0;
-
-  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-    // We rely on device_changed and GetCapabilities to tell us that
-    // something's been connected, but we will mark as disconnected if
-    // Get___PadState returns that we've lost the pad.
-    if (!pad_state_[i].data.connected)
-      continue;
-
-    if (platform_pad_state_[i].status == XINPUT_CONNECTED)
-      GetXInputPadData(i, &pad_state_[i].data);
-    else if (platform_pad_state_[i].status == RAWINPUT_CONNECTED)
-      GetRawInputPadData(i, &pad_state_[i].data);
-
-    MapAndSanitizeGamepadData(&pad_state_[i], &pads->items[i]);
-
-    if (pads->items[i].connected)
-      pads->length++;
+  for (size_t i = 0; i < XUSER_MAX_COUNT; ++i) {
+    if (xinuput_connected_[i])
+      GetXInputPadData(i);
   }
 }
 
-void GamepadPlatformDataFetcherWin::PauseHint(bool pause) {
-  if (pause)
-    raw_input_fetcher_->StopMonitor();
-  else
-    raw_input_fetcher_->StartMonitor();
-}
+void GamepadPlatformDataFetcherWin::GetXInputPadData(int i) {
 
-bool GamepadPlatformDataFetcherWin::GetXInputPadConnectivity(
-    int i,
-    WebGamepad* pad) const {
-  DCHECK(pad);
-  TRACE_EVENT1("GAMEPAD", "GetXInputPadConnectivity", "id", i);
-  XINPUT_CAPABILITIES caps;
-  DWORD res = xinput_get_capabilities_(i, XINPUT_FLAG_GAMEPAD, &caps);
-  if (res == ERROR_DEVICE_NOT_CONNECTED) {
-    pad->connected = false;
-    return false;
-  } else {
-    pad->connected = true;
-    swprintf(pad->id,
-             WebGamepad::idLengthCap,
-             L"Xbox 360 Controller (XInput STANDARD %ls)",
-             GamepadSubTypeName(caps.SubType));
-    swprintf(pad->mapping, WebGamepad::mappingLengthCap, L"standard");
-    return true;
-  }
-}
+  PadState* pad_state = provider()->GetPadState(GAMEPAD_SOURCE_WIN_XINPUT, i);
+  if (!pad_state)
+    return;
+
+  WebGamepad& pad = pad_state->data;
 
-void GamepadPlatformDataFetcherWin::GetXInputPadData(
-    int i,
-    WebGamepad* pad) {
   XINPUT_STATE state;
   memset(&state, 0, sizeof(XINPUT_STATE));
   TRACE_EVENT_BEGIN1("GAMEPAD", "XInputGetState", "id", i);
-  DWORD dwResult = xinput_get_state_(platform_pad_state_[i].xinput_index,
-                                     &state);
+  DWORD dwResult = xinput_get_state_(i, &state);
   TRACE_EVENT_END1("GAMEPAD", "XInputGetState", "id", i);
 
   if (dwResult == ERROR_SUCCESS) {
-    pad->timestamp = state.dwPacketNumber;
-    pad->buttonsLength = 0;
+    pad.timestamp = state.dwPacketNumber;
+    pad.buttonsLength = 0;
     WORD val = state.Gamepad.wButtons;
-#define ADD(b) pad->buttons[pad->buttonsLength].pressed = (val & (b)) != 0; \
-  pad->buttons[pad->buttonsLength++].value = ((val & (b)) ? 1.f : 0.f);
+#define ADD(b) pad.buttons[pad.buttonsLength].pressed = (val & (b)) != 0; \
+  pad.buttons[pad.buttonsLength++].value = ((val & (b)) ? 1.f : 0.f);
     ADD(XINPUT_GAMEPAD_A);
     ADD(XINPUT_GAMEPAD_B);
     ADD(XINPUT_GAMEPAD_X);
@@ -255,14 +164,14 @@ void GamepadPlatformDataFetcherWin::GetXInputPadData(
     ADD(XINPUT_GAMEPAD_LEFT_SHOULDER);
     ADD(XINPUT_GAMEPAD_RIGHT_SHOULDER);
 
-    pad->buttons[pad->buttonsLength].pressed =
+    pad.buttons[pad.buttonsLength].pressed =
       state.Gamepad.bLeftTrigger >= XINPUT_GAMEPAD_TRIGGER_THRESHOLD;
-    pad->buttons[pad->buttonsLength++].value =
+    pad.buttons[pad.buttonsLength++].value =
       state.Gamepad.bLeftTrigger / 255.f;
 
-    pad->buttons[pad->buttonsLength].pressed =
+    pad.buttons[pad.buttonsLength].pressed =
       state.Gamepad.bRightTrigger >= XINPUT_GAMEPAD_TRIGGER_THRESHOLD;
-    pad->buttons[pad->buttonsLength++].value =
+    pad.buttons[pad.buttonsLength++].value =
       state.Gamepad.bRightTrigger / 255.f;
 
     ADD(XINPUT_GAMEPAD_BACK);
@@ -274,11 +183,11 @@ void GamepadPlatformDataFetcherWin::GetXInputPadData(
     ADD(XINPUT_GAMEPAD_DPAD_LEFT);
     ADD(XINPUT_GAMEPAD_DPAD_RIGHT);
 #undef ADD
-    pad->axesLength = 0;
+    pad.axesLength = 0;
 
     float value = 0.0;
 #define ADD(a, factor) value = factor * NormalizeXInputAxis(a); \
-  pad->axes[pad->axesLength++] = value;
+  pad.axes[pad.axesLength++] = value;
 
     // XInput are +up/+right, -down/-left, we want -up/-left.
     ADD(state.Gamepad.sThumbLX, 1);
@@ -286,41 +195,14 @@ void GamepadPlatformDataFetcherWin::GetXInputPadData(
     ADD(state.Gamepad.sThumbRX, 1);
     ADD(state.Gamepad.sThumbRY, -1);
 #undef ADD
-  } else {
-    pad->connected = false;
   }
 }
 
-void GamepadPlatformDataFetcherWin::GetRawInputPadData(
-    int index,
-    WebGamepad* pad) {
-  RawGamepadInfo* gamepad = raw_input_fetcher_->GetGamepadInfo(
-      platform_pad_state_[index].raw_input_handle);
-  if (!gamepad) {
-    pad->connected = false;
-    return;
-  }
-
-  pad->timestamp = gamepad->report_id;
-  pad->buttonsLength = gamepad->buttons_length;
-  pad->axesLength =  gamepad->axes_length;
-
-  for (unsigned int i = 0; i < pad->buttonsLength; i++) {
-    pad->buttons[i].pressed = gamepad->buttons[i];
-    pad->buttons[i].value = gamepad->buttons[i] ? 1.0 : 0.0;
-  }
-
-  for (unsigned int i = 0; i < pad->axesLength; i++)
-    pad->axes[i] = gamepad->axes[i].value;
-}
-
 bool GamepadPlatformDataFetcherWin::GetXInputDllFunctions() {
   xinput_get_capabilities_ = NULL;
   xinput_get_state_ = NULL;
-  xinput_enable_ = reinterpret_cast<XInputEnableFunc>(
+  XInputEnableFunc xinput_enable = reinterpret_cast<XInputEnableFunc>(
       xinput_dll_.GetFunctionPointer("XInputEnable"));
-  if (!xinput_enable_)
-    return false;
   xinput_get_capabilities_ = reinterpret_cast<XInputGetCapabilitiesFunc>(
       xinput_dll_.GetFunctionPointer("XInputGetCapabilities"));
   if (!xinput_get_capabilities_)
@@ -329,7 +211,10 @@ bool GamepadPlatformDataFetcherWin::GetXInputDllFunctions() {
       xinput_dll_.GetFunctionPointer("XInputGetState"));
   if (!xinput_get_state_)
     return false;
-  xinput_enable_(true);
+  if (xinput_enable) {
+    // XInputEnable is unavailable before Win8 and deprecated in Win10.
+    xinput_enable(true);
+  }
   return true;
 }
 
diff --git a/content/browser/gamepad/gamepad_platform_data_fetcher_win.h b/content/browser/gamepad/gamepad_platform_data_fetcher_win.h
index f1efab3..60af0b6 100644
--- a/content/browser/gamepad/gamepad_platform_data_fetcher_win.h
+++ b/content/browser/gamepad/gamepad_platform_data_fetcher_win.h
@@ -5,6 +5,8 @@
 #ifndef CONTENT_BROWSER_GAMEPAD_GAMEPAD_PLATFORM_DATA_FETCHER_WIN_H_
 #define CONTENT_BROWSER_GAMEPAD_GAMEPAD_PLATFORM_DATA_FETCHER_WIN_H_
 
+#include <memory>
+
 #include "build/build_config.h"
 
 #ifndef WIN32_LEAN_AND_MEAN
@@ -18,13 +20,11 @@
 
 #include "base/compiler_specific.h"
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "base/memory/weak_ptr.h"
 #include "base/message_loop/message_loop.h"
 #include "base/scoped_native_library.h"
 #include "content/browser/gamepad/gamepad_data_fetcher.h"
 #include "content/browser/gamepad/gamepad_standard_mappings.h"
-#include "content/browser/gamepad/raw_input_data_fetcher_win.h"
 #include "third_party/WebKit/public/platform/WebGamepads.h"
 
 namespace content {
@@ -33,14 +33,10 @@ class GamepadPlatformDataFetcherWin : public GamepadDataFetcher {
  public:
   GamepadPlatformDataFetcherWin();
   ~GamepadPlatformDataFetcherWin() override;
-  void GetGamepadData(blink::WebGamepads* pads,
-                      bool devices_changed_hint) override;
-  void PauseHint(bool paused) override;
+  void GetGamepadData(bool devices_changed_hint) override;
 
  private:
-  // XInput-specific implementation for GetGamepadData.
-  bool GetXInputGamepadData(blink::WebGamepads* pads,
-                            bool devices_changed_hint);
+  void OnAddedToProvider() override;
 
   // The three function types we use from xinput1_3.dll.
   typedef void (WINAPI *XInputEnableFunc)(BOOL enable);
@@ -49,47 +45,23 @@ class GamepadPlatformDataFetcherWin : public GamepadDataFetcher {
   typedef DWORD (WINAPI *XInputGetStateFunc)(
       DWORD dwUserIndex, XINPUT_STATE* pState);
 
-  // Get functions from dynamically loaded xinput1_3.dll. We don't use
-  // DELAYLOAD because the import library for Win8 SDK pulls xinput1_4 which
-  // isn't redistributable. Returns true if loading was successful. We include
-  // xinput1_3.dll with Chrome.
+  // Get functions from dynamically loading the xinput dll.
+  // Returns true if loading was successful.
   bool GetXInputDllFunctions();
 
   // Scan for connected XInput and DirectInput gamepads.
   void EnumerateDevices();
-  bool GetXInputPadConnectivity(int i, blink::WebGamepad* pad) const;
-
-  void GetXInputPadData(int i, blink::WebGamepad* pad);
-  void GetRawInputPadData(int i, blink::WebGamepad* pad);
-
-  int FirstAvailableGamepadId() const;
-  bool HasXInputGamepad(int index) const;
-  bool HasRawInputGamepad(const HANDLE handle) const;
+  void GetXInputPadData(int i);
 
   base::ScopedNativeLibrary xinput_dll_;
   bool xinput_available_;
 
   // Function pointers to XInput functionality, retrieved in
   // |GetXinputDllFunctions|.
-  XInputEnableFunc xinput_enable_;
   XInputGetCapabilitiesFunc xinput_get_capabilities_;
   XInputGetStateFunc xinput_get_state_;
 
-  enum PadConnectionStatus {
-    DISCONNECTED,
-    XINPUT_CONNECTED,
-    RAWINPUT_CONNECTED
-  };
-
-  struct PlatformPadState {
-    PadConnectionStatus status;
-
-    int xinput_index; // XInput-only
-    HANDLE raw_input_handle;  // RawInput-only fields.
-  };
-  PlatformPadState platform_pad_state_[blink::WebGamepads::itemsLengthCap];
-
-  scoped_ptr<RawInputDataFetcher> raw_input_fetcher_;
+  bool xinuput_connected_[XUSER_MAX_COUNT];
 
   DISALLOW_COPY_AND_ASSIGN(GamepadPlatformDataFetcherWin);
 };
diff --git a/content/browser/gamepad/gamepad_provider.cc b/content/browser/gamepad/gamepad_provider.cc
index fea94e0..f4d0ab4 100644
--- a/content/browser/gamepad/gamepad_provider.cc
+++ b/content/browser/gamepad/gamepad_provider.cc
@@ -7,7 +7,6 @@
 #include <stddef.h>
 #include <string.h>
 #include <cmath>
-#include <set>
 #include <utility>
 #include <vector>
 
@@ -31,6 +30,12 @@
 using blink::WebGamepad;
 using blink::WebGamepads;
 
+namespace {
+
+const float kMinAxisResetValue = 0.1f;
+
+} // namespace
+
 namespace content {
 
 GamepadProvider::ClosureAndThread::ClosureAndThread(
@@ -49,11 +54,12 @@ GamepadProvider::GamepadProvider()
     : is_paused_(true),
       have_scheduled_do_poll_(false),
       devices_changed_(true),
-      ever_had_user_gesture_(false) {
-  Initialize(scoped_ptr<GamepadDataFetcher>());
+      ever_had_user_gesture_(false),
+      sanitize_(true) {
+  Initialize(std::unique_ptr<GamepadDataFetcher>());
 }
 
-GamepadProvider::GamepadProvider(scoped_ptr<GamepadDataFetcher> fetcher)
+GamepadProvider::GamepadProvider(std::unique_ptr<GamepadDataFetcher> fetcher)
     : is_paused_(true),
       have_scheduled_do_poll_(false),
       devices_changed_(true),
@@ -69,7 +75,6 @@ GamepadProvider::~GamepadProvider() {
   // Use Stop() to join the polling thread, as there may be pending callbacks
   // which dereference |polling_thread_|.
   polling_thread_->Stop();
-  data_fetcher_.reset();
 }
 
 base::SharedMemoryHandle GamepadProvider::GetSharedMemoryHandleForProcess(
@@ -124,7 +129,7 @@ void GamepadProvider::OnDevicesChanged(base::SystemMonitor::DeviceType type) {
   devices_changed_ = true;
 }
 
-void GamepadProvider::Initialize(scoped_ptr<GamepadDataFetcher> fetcher) {
+void GamepadProvider::Initialize(std::unique_ptr<GamepadDataFetcher> fetcher) {
   size_t data_size = sizeof(GamepadHardwareBuffer);
   base::SystemMonitor* monitor = base::SystemMonitor::Get();
   if (monitor)
@@ -135,6 +140,9 @@ void GamepadProvider::Initialize(scoped_ptr<GamepadDataFetcher> fetcher) {
   memset(hwbuf, 0, sizeof(GamepadHardwareBuffer));
   pad_states_.reset(new PadState[WebGamepads::itemsLengthCap]);
 
+  for (unsigned i = 0; i < WebGamepads::itemsLengthCap; ++i)
+    ClearPadState(pad_states_.get()[i]);
+
   polling_thread_.reset(new base::Thread("Gamepad polling thread"));
 #if defined(OS_LINUX)
   // On Linux, the data fetcher needs to watch file descriptors, so the message
@@ -152,59 +160,34 @@ void GamepadProvider::Initialize(scoped_ptr<GamepadDataFetcher> fetcher) {
 #endif
   polling_thread_->StartWithOptions(base::Thread::Options(kMessageLoopType, 0));
 
+  if (fetcher) {
+    AddGamepadDataFetcher(std::move(fetcher));
+  } else {
+    AddGamepadPlatformDataFetchers(this);
+  }
+}
+
+void GamepadProvider::AddGamepadDataFetcher(
+    std::unique_ptr<GamepadDataFetcher> fetcher) {
   polling_thread_->task_runner()->PostTask(
-      FROM_HERE, base::Bind(&GamepadProvider::DoInitializePollingThread,
+      FROM_HERE, base::Bind(&GamepadProvider::DoAddGamepadDataFetcher,
                             base::Unretained(this), base::Passed(&fetcher)));
 }
 
-void GamepadProvider::DoInitializePollingThread(
-    scoped_ptr<GamepadDataFetcher> fetcher) {
+void GamepadProvider::DoAddGamepadDataFetcher(
+    std::unique_ptr<GamepadDataFetcher> fetcher) {
   DCHECK(base::MessageLoop::current() == polling_thread_->message_loop());
-  DCHECK(!data_fetcher_.get());  // Should only initialize once.
 
-  if (!fetcher)
-    fetcher.reset(new GamepadPlatformDataFetcher);
-  data_fetcher_ = std::move(fetcher);
+  fetcher->InitializeProvider(this);
+
+  data_fetchers_.push_back(std::move(fetcher));
 }
 
 void GamepadProvider::SendPauseHint(bool paused) {
   DCHECK(base::MessageLoop::current() == polling_thread_->message_loop());
-  if (data_fetcher_)
-    data_fetcher_->PauseHint(paused);
-}
-
-bool GamepadProvider::PadState::Match(const WebGamepad& pad) const {
-  return connected_ == pad.connected &&
-         axes_length_ == pad.axesLength &&
-         buttons_length_ == pad.buttonsLength &&
-         memcmp(id_, pad.id, sizeof(id_)) == 0 &&
-         memcmp(mapping_, pad.mapping, sizeof(mapping_)) == 0;
-}
-
-void GamepadProvider::PadState::SetPad(const WebGamepad& pad) {
-  connected_ = pad.connected;
-  axes_length_ = pad.axesLength;
-  buttons_length_ = pad.buttonsLength;
-  memcpy(id_, pad.id, sizeof(id_));
-  memcpy(mapping_, pad.mapping, sizeof(mapping_));
-}
-
-void GamepadProvider::PadState::SetDisconnected() {
-  connected_ = false;
-  axes_length_ = 0;
-  buttons_length_ = 0;
-  memset(id_, 0, sizeof(id_));
-  memset(mapping_, 0, sizeof(mapping_));
-}
-
-void GamepadProvider::PadState::AsWebGamepad(WebGamepad* pad) {
-  pad->connected = connected_;
-  pad->axesLength = axes_length_;
-  pad->buttonsLength = buttons_length_;
-  memcpy(pad->id, id_, sizeof(id_));
-  memcpy(pad->mapping, mapping_, sizeof(mapping_));
-  memset(pad->axes, 0, sizeof(pad->axes));
-  memset(pad->buttons, 0, sizeof(pad->buttons));
+  for (const auto& it : data_fetchers_) {
+    it->PauseHint(paused);
+  }
 }
 
 void GamepadProvider::DoPoll() {
@@ -226,29 +209,52 @@ void GamepadProvider::DoPoll() {
     devices_changed_ = false;
   }
 
+  // Loop through each registered data fetcher and poll it's gamepad data.
+  // It's expected that GetGamepadData will mark each gamepad as active (via
+  // GetPadState). If a gamepad is not marked as active during the calls to
+  // GetGamepadData then it's assumed to be disconnected.
+  for (const auto& it : data_fetchers_) {
+    it->GetGamepadData(changed);
+  }
+
+  // Send out disconnect events using the last polled data before we wipe it out
+  // in the mapping step.
+  if (ever_had_user_gesture_) {
+    for (unsigned i = 0; i < WebGamepads::itemsLengthCap; ++i) {
+      PadState& state = pad_states_.get()[i];
+
+      if (!state.active_state && state.source != GAMEPAD_SOURCE_NONE) {
+        OnGamepadConnectionChange(false, i, hwbuf->buffer.items[i]);
+        ClearPadState(state);
+      }
+    }
+  }
+
   {
     base::AutoLock lock(shared_memory_lock_);
 
     // Acquire the SeqLock. There is only ever one writer to this data.
     // See gamepad_hardware_buffer.h.
     hwbuf->sequence.WriteBegin();
-    data_fetcher_->GetGamepadData(&hwbuf->buffer, changed);
+    hwbuf->buffer.length = 0;
+    for (unsigned i = 0; i < WebGamepads::itemsLengthCap; ++i) {
+      PadState& state = pad_states_.get()[i];
+      // Must run through the map+sanitize here or CheckForUserGesture may fail.
+      MapAndSanitizeGamepadData(&state, &hwbuf->buffer.items[i]);
+      if (state.active_state)
+        hwbuf->buffer.length++;
+    }
     hwbuf->sequence.WriteEnd();
   }
 
   if (ever_had_user_gesture_) {
     for (unsigned i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-      WebGamepad& pad = hwbuf->buffer.items[i];
       PadState& state = pad_states_.get()[i];
-      if (pad.connected && !state.connected()) {
-        OnGamepadConnectionChange(true, i, pad);
-      } else if (!pad.connected && state.connected()) {
-        OnGamepadConnectionChange(false, i, pad);
-      } else if (pad.connected && state.connected() && !state.Match(pad)) {
-        WebGamepad old_pad;
-        state.AsWebGamepad(&old_pad);
-        OnGamepadConnectionChange(false, i, old_pad);
-        OnGamepadConnectionChange(true, i, pad);
+
+      if (state.active_state) {
+        if (state.active_state == GAMEPAD_NEWLY_ACTIVE)
+          OnGamepadConnectionChange(true, i, hwbuf->buffer.items[i]);
+        state.active_state = GAMEPAD_INACTIVE;
       }
     }
   }
@@ -278,12 +284,6 @@ void GamepadProvider::ScheduleDoPoll() {
 
 void GamepadProvider::OnGamepadConnectionChange(
     bool connected, int index, const WebGamepad& pad) {
-  PadState& state = pad_states_.get()[index];
-  if (connected)
-    state.SetPad(pad);
-  else
-    state.SetDisconnected();
-
   BrowserThread::PostTask(
       BrowserThread::IO,
       FROM_HERE,
@@ -313,7 +313,6 @@ void GamepadProvider::CheckForUserGesture() {
   if (user_gesture_observers_.empty() && ever_had_user_gesture_)
     return;
 
-  bool had_gesture_before = ever_had_user_gesture_;
   const WebGamepads& pads = SharedMemoryAsHardwareBuffer()->buffer;
   if (GamepadsHaveUserGesture(pads)) {
     ever_had_user_gesture_ = true;
@@ -323,10 +322,92 @@ void GamepadProvider::CheckForUserGesture() {
     }
     user_gesture_observers_.clear();
   }
-  if (!had_gesture_before && ever_had_user_gesture_) {
-    // Initialize pad_states_ for the first time.
-    for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
-      pad_states_.get()[i].SetPad(pads.items[i]);
+}
+
+void GamepadProvider::ClearPadState(PadState& state) {
+  memset(&state, 0, sizeof(PadState));
+}
+
+PadState* GamepadProvider::GetPadState(GamepadSource source, int source_id) {
+  // Check to see if the device already has a reserved slot
+  PadState* empty_slot = nullptr;
+  for (size_t i = 0; i < WebGamepads::itemsLengthCap; ++i) {
+    PadState& state = pad_states_.get()[i];
+    if (state.source == source &&
+        state.source_id == source_id) {
+      // Retrieving the pad state marks this gamepad as active.
+      state.active_state = GAMEPAD_ACTIVE;
+      return &state;
+    }
+    if (!empty_slot && state.source == GAMEPAD_SOURCE_NONE)
+      empty_slot = &state;
+  }
+  if (empty_slot) {
+    empty_slot->source = source;
+    empty_slot->source_id = source_id;
+    empty_slot->active_state = GAMEPAD_NEWLY_ACTIVE;
+  }
+  return empty_slot;
+}
+
+void GamepadProvider::MapAndSanitizeGamepadData(
+    PadState* pad_state, WebGamepad* pad) {
+  DCHECK(pad_state);
+  DCHECK(pad);
+
+  if (!pad_state->active_state) {
+    memset(pad, 0, sizeof(WebGamepad));
+    return;
+  }
+
+  // Copy the current state to the output buffer, using the mapping
+  // function, if there is one available.
+  if (pad_state->mapper)
+    pad_state->mapper(pad_state->data, pad);
+  else
+    *pad = pad_state->data;
+
+  pad->connected = true;
+
+  if (!sanitize_)
+    return;
+
+  // About sanitization: Gamepads may report input event if the user is not
+  // interacting with it, due to hardware problems or environmental ones (pad
+  // has something heavy leaning against an axis.) This may cause user gestures
+  // to be detected erroniously, exposing gamepad information when the user had
+  // no intention of doing so. To avoid this we require that each button or axis
+  // report being at rest (zero) at least once before exposing its value to the
+  // Gamepad API. This state is tracked by the axis_mask and button_mask
+  // bitfields. If the bit for an axis or button is 0 it means the axis has
+  // never reported being at rest, and the value will be forced to zero.
+
+  // We can skip axis sanitation if all available axes have been masked.
+  uint32_t full_axis_mask = (1 << pad->axesLength) - 1;
+  if (pad_state->axis_mask != full_axis_mask) {
+    for (size_t axis = 0; axis < pad->axesLength; ++axis) {
+      if (!(pad_state->axis_mask & 1 << axis)) {
+        if (fabs(pad->axes[axis]) < kMinAxisResetValue) {
+          pad_state->axis_mask |= 1 << axis;
+        } else {
+          pad->axes[axis] = 0.0f;
+        }
+      }
+    }
+  }
+
+  // We can skip button sanitation if all available buttons have been masked.
+  uint32_t full_button_mask = (1 << pad->buttonsLength) - 1;
+  if (pad_state->button_mask != full_button_mask) {
+    for (size_t button = 0; button < pad->buttonsLength; ++button) {
+      if (!(pad_state->button_mask & 1 << button)) {
+        if (!pad->buttons[button].pressed) {
+          pad_state->button_mask |= 1 << button;
+        } else {
+          pad->buttons[button].pressed = false;
+          pad->buttons[button].value = 0.0f;
+        }
+      }
     }
   }
 }
diff --git a/content/browser/gamepad/gamepad_provider.h b/content/browser/gamepad/gamepad_provider.h
index fa15411..f46be16 100644
--- a/content/browser/gamepad/gamepad_provider.h
+++ b/content/browser/gamepad/gamepad_provider.h
@@ -5,17 +5,18 @@
 #ifndef CONTENT_BROWSER_GAMEPAD_GAMEPAD_PROVIDER_H_
 #define CONTENT_BROWSER_GAMEPAD_GAMEPAD_PROVIDER_H_
 
+#include <memory>
+#include <stdint.h>
 #include <utility>
 #include <vector>
 
 #include "base/callback_forward.h"
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
-#include "base/memory/scoped_ptr.h"
 #include "base/memory/shared_memory.h"
-#include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 #include "base/system_monitor/system_monitor.h"
+#include "content/browser/gamepad/gamepad_standard_mappings.h"
 #include "content/common/content_export.h"
 #include "third_party/WebKit/public/platform/WebGamepads.h"
 
@@ -29,13 +30,64 @@ namespace content {
 class GamepadDataFetcher;
 struct GamepadHardwareBuffer;
 
+enum GamepadSource {
+  GAMEPAD_SOURCE_NONE = 0,
+  GAMEPAD_SOURCE_ANDROID,
+  GAMEPAD_SOURCE_LINUX_UDEV,
+  GAMEPAD_SOURCE_MAC_HID,
+  GAMEPAD_SOURCE_MAC_XBOX,
+  GAMEPAD_SOURCE_TEST,
+  GAMEPAD_SOURCE_WIN_XINPUT,
+  GAMEPAD_SOURCE_WIN_RAW,
+};
+
+enum GamepadActiveState {
+  GAMEPAD_INACTIVE = 0,
+  GAMEPAD_ACTIVE,
+  GAMEPAD_NEWLY_ACTIVE,
+};
+
+struct PadState {
+  // Which data fetcher provided this gamepad's data.
+  GamepadSource source;
+  // Data fetcher-specific identifier for this gamepad.
+  int source_id;
+
+  // Indicates whether or not the gamepad is actively being updated
+  GamepadActiveState active_state;
+
+  // Gamepad data, unmapped.
+  blink::WebGamepad data;
+
+  // Functions to map from device data to standard layout, if available. May
+  // be null if no mapping is available or needed.
+  GamepadStandardMappingFunction mapper;
+
+  // Sanitization masks
+  // axis_mask and button_mask are bitfields that represent the reset state of
+  // each input. If a button or axis has ever reported 0 in the past the
+  // corresponding bit will be set to 1.
+
+  // If we ever increase the max axis count this will need to be updated.
+  static_assert(blink::WebGamepad::axesLengthCap <=
+      std::numeric_limits<uint32_t>::digits,
+      "axis_mask is not large enough");
+  uint32_t axis_mask;
+
+  // If we ever increase the max button count this will need to be updated.
+  static_assert(blink::WebGamepad::buttonsLengthCap <=
+      std::numeric_limits<uint32_t>::digits,
+      "button_mask is not large enough");
+  uint32_t button_mask;
+};
+
 class CONTENT_EXPORT GamepadProvider :
   public base::SystemMonitor::DevicesChangedObserver {
  public:
   GamepadProvider();
 
   // Manually specifies the data fetcher. Used for testing.
-  explicit GamepadProvider(scoped_ptr<GamepadDataFetcher> fetcher);
+  explicit GamepadProvider(std::unique_ptr<GamepadDataFetcher> fetcher);
 
   ~GamepadProvider() override;
 
@@ -58,12 +110,22 @@ class CONTENT_EXPORT GamepadProvider :
   // base::SystemMonitor::DevicesChangedObserver implementation.
   void OnDevicesChanged(base::SystemMonitor::DeviceType type) override;
 
+  // Add a gamepad data fetcher. Takes ownership of |fetcher|.
+  void AddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher> fetcher);
+
+  // Gets a PadState object for the given source and id. If the device hasn't
+  // been encountered before one of the remaining slots will be reserved for it.
+  // If no slots are available will return NULL.
+  PadState* GetPadState(GamepadSource source, int source_id);
+
+  void SetSanitizationEnabled(bool sanitize) { sanitize_ = sanitize; }
+
  private:
-  void Initialize(scoped_ptr<GamepadDataFetcher> fetcher);
+  void Initialize(std::unique_ptr<GamepadDataFetcher> fetcher);
 
   // Method for setting up the platform-specific data fetcher. Takes ownership
   // of |fetcher|.
-  void DoInitializePollingThread(scoped_ptr<GamepadDataFetcher> fetcher);
+  void DoAddGamepadDataFetcher(std::unique_ptr<GamepadDataFetcher> fetcher);
 
   // Method for sending pause hints to the low-level data fetcher. Runs on
   // polling_thread_.
@@ -84,6 +146,10 @@ class CONTENT_EXPORT GamepadProvider :
 
   // Checks the gamepad state to see if the user has interacted with it.
   void CheckForUserGesture();
+  void ClearPadState(PadState& state);
+
+  void MapAndSanitizeGamepadData(PadState* pad_state,
+                                 blink::WebGamepad* pad);
 
   enum { kDesiredSamplingIntervalMs = 16 };
 
@@ -124,41 +190,22 @@ class CONTENT_EXPORT GamepadProvider :
   bool devices_changed_;
 
   bool ever_had_user_gesture_;
+  bool sanitize_;
 
-  class PadState {
-   public:
-    PadState() {
-      SetDisconnected();
-    }
-
-    bool Match(const blink::WebGamepad& pad) const;
-    void SetPad(const blink::WebGamepad& pad);
-    void SetDisconnected();
-    void AsWebGamepad(blink::WebGamepad* pad);
-
-    bool connected() const { return connected_; }
-
-   private:
-    bool connected_;
-    unsigned axes_length_;
-    unsigned buttons_length_;
-    blink::WebUChar id_[blink::WebGamepad::idLengthCap];
-    blink::WebUChar mapping_[blink::WebGamepad::mappingLengthCap];
-  };
-
-  // Used to detect connections and disconnections.
-  scoped_ptr<PadState[]> pad_states_;
+  // Tracks the state of each gamepad slot.
+  std::unique_ptr<PadState[]> pad_states_;
 
   // Only used on the polling thread.
-  scoped_ptr<GamepadDataFetcher> data_fetcher_;
+  typedef std::vector<std::unique_ptr<GamepadDataFetcher>> GamepadFetcherVector;
+  GamepadFetcherVector data_fetchers_;
 
   base::Lock shared_memory_lock_;
   base::SharedMemory gamepad_shared_memory_;
 
   // Polling is done on this background thread.
-  scoped_ptr<base::Thread> polling_thread_;
+  std::unique_ptr<base::Thread> polling_thread_;
 
-  static GamepadProvider* instance_;
+  //static GamepadProvider* instance_;
 
   DISALLOW_COPY_AND_ASSIGN(GamepadProvider);
 };
diff --git a/content/browser/gamepad/gamepad_provider_unittest.cc b/content/browser/gamepad/gamepad_provider_unittest.cc
index 7e3a29c..b504016 100644
--- a/content/browser/gamepad/gamepad_provider_unittest.cc
+++ b/content/browser/gamepad/gamepad_provider_unittest.cc
@@ -2,12 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "content/browser/gamepad/gamepad_provider.h"
+
+#include <memory>
+
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "base/memory/weak_ptr.h"
 #include "build/build_config.h"
 #include "content/browser/gamepad/gamepad_data_fetcher.h"
-#include "content/browser/gamepad/gamepad_provider.h"
 #include "content/browser/gamepad/gamepad_test_helpers.h"
 #include "content/common/gamepad_hardware_buffer.h"
 #include "content/common/gamepad_messages.h"
@@ -49,7 +51,7 @@ class GamepadProviderTest : public testing::Test, public GamepadTestHelper {
   GamepadProvider* CreateProvider(const WebGamepads& test_data) {
     mock_data_fetcher_ = new MockGamepadDataFetcher(test_data);
     provider_.reset(new GamepadProvider(
-        scoped_ptr<GamepadDataFetcher>(mock_data_fetcher_)));
+        std::unique_ptr<GamepadDataFetcher>(mock_data_fetcher_)));
     return provider_.get();
   }
 
@@ -57,7 +59,7 @@ class GamepadProviderTest : public testing::Test, public GamepadTestHelper {
   GamepadProviderTest() {
   }
 
-  scoped_ptr<GamepadProvider> provider_;
+  std::unique_ptr<GamepadProvider> provider_;
 
   // Pointer owned by the provider.
   MockGamepadDataFetcher* mock_data_fetcher_;
@@ -85,6 +87,7 @@ TEST_F(GamepadProviderTest, MAYBE_PollingAccess) {
   test_data.items[0].axes[1] = .5f;
 
   GamepadProvider* provider = CreateProvider(test_data);
+  provider->SetSanitizationEnabled(false);
   provider->Resume();
 
   message_loop().RunUntilIdle();
@@ -94,7 +97,7 @@ TEST_F(GamepadProviderTest, MAYBE_PollingAccess) {
   // Renderer-side, pull data out of poll buffer.
   base::SharedMemoryHandle handle = provider->GetSharedMemoryHandleForProcess(
       base::GetCurrentProcessHandle());
-  scoped_ptr<base::SharedMemory> shared_memory(
+  std::unique_ptr<base::SharedMemory> shared_memory(
       new base::SharedMemory(handle, true));
   EXPECT_TRUE(shared_memory->Map(sizeof(GamepadHardwareBuffer)));
   void* mem = shared_memory->memory();
@@ -137,6 +140,7 @@ TEST_F(GamepadProviderTest, UserGesture) {
 
   UserGestureListener listener;
   GamepadProvider* provider = CreateProvider(no_button_data);
+  provider->SetSanitizationEnabled(false);
   provider->Resume();
 
   provider->RegisterForUserGesture(listener.GetClosure());
@@ -155,6 +159,99 @@ TEST_F(GamepadProviderTest, UserGesture) {
   EXPECT_TRUE(listener.has_user_gesture());
 }
 
+// Tests that waiting for a user gesture works properly.
+TEST_F(GamepadProviderTest, Sanitization) {
+  WebGamepads active_data;
+  active_data.length = 1;
+  active_data.items[0].connected = true;
+  active_data.items[0].timestamp = 0;
+  active_data.items[0].buttonsLength = 1;
+  active_data.items[0].axesLength = 1;
+  active_data.items[0].buttons[0].value = 1.f;
+  active_data.items[0].buttons[0].pressed = true;
+  active_data.items[0].axes[0] = -1.f;
+
+  WebGamepads zero_data;
+  zero_data.length = 1;
+  zero_data.items[0].connected = true;
+  zero_data.items[0].timestamp = 0;
+  zero_data.items[0].buttonsLength = 1;
+  zero_data.items[0].axesLength = 1;
+  zero_data.items[0].buttons[0].value = 0.f;
+  zero_data.items[0].buttons[0].pressed = false;
+  zero_data.items[0].axes[0] = 0.f;
+
+  UserGestureListener listener;
+  GamepadProvider* provider = CreateProvider(active_data);
+  provider->SetSanitizationEnabled(true);
+  provider->Resume();
+
+  message_loop().RunUntilIdle();
+
+  mock_data_fetcher_->WaitForDataRead();
+
+  // Renderer-side, pull data out of poll buffer.
+  base::SharedMemoryHandle handle = provider->GetSharedMemoryHandleForProcess(
+      base::GetCurrentProcessHandle());
+  scoped_ptr<base::SharedMemory> shared_memory(
+      new base::SharedMemory(handle, true));
+  EXPECT_TRUE(shared_memory->Map(sizeof(GamepadHardwareBuffer)));
+  void* mem = shared_memory->memory();
+
+  GamepadHardwareBuffer* hwbuf = static_cast<GamepadHardwareBuffer*>(mem);
+  // See gamepad_hardware_buffer.h for details on the read discipline.
+  WebGamepads output;
+
+  base::subtle::Atomic32 version;
+  do {
+    version = hwbuf->sequence.ReadBegin();
+    memcpy(&output, &hwbuf->buffer, sizeof(output));
+  } while (hwbuf->sequence.ReadRetry(version));
+
+  // Initial data should all be zeroed out due to sanitization, even though the
+  // gamepad reported input
+  EXPECT_EQ(1u, output.length);
+  EXPECT_EQ(1u, output.items[0].buttonsLength);
+  EXPECT_EQ(0.f, output.items[0].buttons[0].value);
+  EXPECT_EQ(false, output.items[0].buttons[0].pressed);
+  EXPECT_EQ(1u, output.items[0].axesLength);
+  EXPECT_EQ(0.f, output.items[0].axes[0]);
+
+  // Zero out the inputs
+  mock_data_fetcher_->SetTestData(zero_data);
+  mock_data_fetcher_->WaitForDataReadAndCallbacksIssued();
+
+  do {
+    version = hwbuf->sequence.ReadBegin();
+    memcpy(&output, &hwbuf->buffer, sizeof(output));
+  } while (hwbuf->sequence.ReadRetry(version));
+
+  // Should still read zero, which is now an accurate reflection of the data
+  EXPECT_EQ(1u, output.length);
+  EXPECT_EQ(1u, output.items[0].buttonsLength);
+  EXPECT_EQ(0.f, output.items[0].buttons[0].value);
+  EXPECT_EQ(false, output.items[0].buttons[0].pressed);
+  EXPECT_EQ(1u, output.items[0].axesLength);
+  EXPECT_EQ(0.f, output.items[0].axes[0]);
+  
+  // Re-set the active inputs
+  mock_data_fetcher_->SetTestData(active_data);
+  mock_data_fetcher_->WaitForDataReadAndCallbacksIssued();
+
+  do {
+    version = hwbuf->sequence.ReadBegin();
+    memcpy(&output, &hwbuf->buffer, sizeof(output));
+  } while (hwbuf->sequence.ReadRetry(version));
+
+  // Should now accurately reflect the reported data.
+  EXPECT_EQ(1u, output.length);
+  EXPECT_EQ(1u, output.items[0].buttonsLength);
+  EXPECT_EQ(1.f, output.items[0].buttons[0].value);
+  EXPECT_EQ(true, output.items[0].buttons[0].pressed);
+  EXPECT_EQ(1u, output.items[0].axesLength);
+  EXPECT_EQ(-1.f, output.items[0].axes[0]);
+}
+
 }  // namespace
 
 }  // namespace content
diff --git a/content/browser/gamepad/gamepad_service.cc b/content/browser/gamepad/gamepad_service.cc
index 411ae01..ef56d31 100644
--- a/content/browser/gamepad/gamepad_service.cc
+++ b/content/browser/gamepad/gamepad_service.cc
@@ -27,7 +27,7 @@ GamepadService::GamepadService()
   SetInstance(this);
 }
 
-GamepadService::GamepadService(scoped_ptr<GamepadDataFetcher> fetcher)
+GamepadService::GamepadService(std::unique_ptr<GamepadDataFetcher> fetcher)
     : provider_(new GamepadProvider(std::move(fetcher))),
       num_active_consumers_(0),
       gesture_callback_pending_(false) {
diff --git a/content/browser/gamepad/gamepad_service.h b/content/browser/gamepad/gamepad_service.h
index 22bea8c..d3cb62b 100644
--- a/content/browser/gamepad/gamepad_service.h
+++ b/content/browser/gamepad/gamepad_service.h
@@ -5,11 +5,11 @@
 #ifndef CONTENT_BROWSER_GAMEPAD_GAMEPAD_SERVICE_H_
 #define CONTENT_BROWSER_GAMEPAD_GAMEPAD_SERVICE_H_
 
+#include <memory>
 #include <set>
 
 #include "base/callback_forward.h"
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "base/memory/shared_memory.h"
 #include "base/memory/singleton.h"
 #include "base/threading/thread_checker.h"
@@ -79,6 +79,8 @@ class CONTENT_EXPORT GamepadService {
   // Called on IO thread when a gamepad is disconnected.
   void OnGamepadDisconnected(int index, const blink::WebGamepad& pad);
 
+  GamepadProvider* provider() { return provider_.get(); }
+
  private:
   friend struct base::DefaultSingletonTraits<GamepadService>;
   friend class GamepadServiceTestConstructor;
@@ -88,7 +90,7 @@ class CONTENT_EXPORT GamepadService {
 
   // Constructor for testing. This specifies the data fetcher to use for a
   // provider, bypassing the default platform one.
-  GamepadService(scoped_ptr<GamepadDataFetcher> fetcher);
+  GamepadService(std::unique_ptr<GamepadDataFetcher> fetcher);
 
   virtual ~GamepadService();
 
@@ -111,7 +113,7 @@ class CONTENT_EXPORT GamepadService {
     mutable bool did_observe_user_gesture;
   };
 
-  scoped_ptr<GamepadProvider> provider_;
+  std::unique_ptr<GamepadProvider> provider_;
 
   base::ThreadChecker thread_checker_;
 
diff --git a/content/browser/gamepad/gamepad_service_unittest.cc b/content/browser/gamepad/gamepad_service_unittest.cc
index 5b9d1c2..a6c2265 100644
--- a/content/browser/gamepad/gamepad_service_unittest.cc
+++ b/content/browser/gamepad/gamepad_service_unittest.cc
@@ -2,13 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "content/browser/gamepad/gamepad_service.h"
+
 #include <string.h>
 
+#include <memory>
+
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "base/run_loop.h"
 #include "content/browser/gamepad/gamepad_consumer.h"
-#include "content/browser/gamepad/gamepad_service.h"
 #include "content/browser/gamepad/gamepad_test_helpers.h"
 #include "content/public/test/test_browser_thread_bundle.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -69,7 +71,7 @@ class GamepadServiceTest : public testing::Test {
  private:
   MockGamepadDataFetcher* fetcher_;
   GamepadService* service_;
-  scoped_ptr<ConnectionListener> connection_listener_;
+  std::unique_ptr<ConnectionListener> connection_listener_;
   TestBrowserThreadBundle browser_thread_;
   WebGamepads test_data_;
 
@@ -80,7 +82,7 @@ GamepadServiceTest::GamepadServiceTest()
     : browser_thread_(TestBrowserThreadBundle::IO_MAINLOOP) {
   memset(&test_data_, 0, sizeof(test_data_));
 
-  // Set it so that we have user gesture.
+  // Must be set to zero initially to pass sanitiation
   test_data_.items[0].buttonsLength = 1;
   test_data_.items[0].buttons[0].value = 1.f;
   test_data_.items[0].buttons[0].pressed = true;
@@ -92,7 +94,8 @@ GamepadServiceTest::~GamepadServiceTest() {
 
 void GamepadServiceTest::SetUp() {
   fetcher_ = new MockGamepadDataFetcher(test_data_);
-  service_ = new GamepadService(scoped_ptr<GamepadDataFetcher>(fetcher_));
+  service_ = new GamepadService(std::unique_ptr<GamepadDataFetcher>(fetcher_));
+  service_->provider()->SetSanitizationEnabled(false);
   connection_listener_.reset((new ConnectionListener));
   service_->ConsumerBecameActive(connection_listener_.get());
 }
diff --git a/content/browser/gamepad/gamepad_test_helpers.cc b/content/browser/gamepad/gamepad_test_helpers.cc
index fc79dcb..19e34c1 100644
--- a/content/browser/gamepad/gamepad_test_helpers.cc
+++ b/content/browser/gamepad/gamepad_test_helpers.cc
@@ -17,11 +17,17 @@ MockGamepadDataFetcher::MockGamepadDataFetcher(
 MockGamepadDataFetcher::~MockGamepadDataFetcher() {
 }
 
-void MockGamepadDataFetcher::GetGamepadData(blink::WebGamepads* pads,
-                                            bool devices_changed_hint) {
+void MockGamepadDataFetcher::GetGamepadData(bool devices_changed_hint) {
   {
     base::AutoLock lock(lock_);
-    *pads = test_data_;
+
+    for (unsigned int i = 0; i < blink::WebGamepads::itemsLengthCap; ++i) {
+      if (test_data_.items[i].connected) {
+        PadState* pad = provider()->GetPadState(GAMEPAD_SOURCE_TEST, i);
+        if (pad)
+          memcpy(&pad->data, &test_data_.items[i], sizeof(blink::WebGamepad));
+      }
+    }
   }
   read_data_.Signal();
 }
@@ -54,7 +60,7 @@ GamepadServiceTestConstructor::GamepadServiceTestConstructor(
     const blink::WebGamepads& test_data) {
   data_fetcher_ = new MockGamepadDataFetcher(test_data);
   gamepad_service_ =
-      new GamepadService(scoped_ptr<GamepadDataFetcher>(data_fetcher_));
+      new GamepadService(std::unique_ptr<GamepadDataFetcher>(data_fetcher_));
 }
 
 GamepadServiceTestConstructor::~GamepadServiceTestConstructor() {
diff --git a/content/browser/gamepad/gamepad_test_helpers.h b/content/browser/gamepad/gamepad_test_helpers.h
index 5e30f99..3acfac2 100644
--- a/content/browser/gamepad/gamepad_test_helpers.h
+++ b/content/browser/gamepad/gamepad_test_helpers.h
@@ -5,8 +5,9 @@
 #ifndef CONTENT_BROWSER_GAMEPAD_GAMEPAD_TEST_HELPERS_H_
 #define CONTENT_BROWSER_GAMEPAD_GAMEPAD_TEST_HELPERS_H_
 
+#include <memory>
+
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "base/message_loop/message_loop.h"
 #include "base/synchronization/lock.h"
 #include "base/synchronization/waitable_event.h"
@@ -27,8 +28,7 @@ class MockGamepadDataFetcher : public GamepadDataFetcher {
   ~MockGamepadDataFetcher() override;
 
   // GamepadDataFetcher.
-  void GetGamepadData(blink::WebGamepads* pads,
-                      bool devices_changed_hint) override;
+  void GetGamepadData(bool devices_changed_hint) override;
 
   // Blocks the current thread until the GamepadProvider reads from this
   // fetcher on the background thread.
diff --git a/content/browser/gamepad/raw_input_data_fetcher_win.cc b/content/browser/gamepad/raw_input_data_fetcher_win.cc
index 0693eef..efa2805 100644
--- a/content/browser/gamepad/raw_input_data_fetcher_win.cc
+++ b/content/browser/gamepad/raw_input_data_fetcher_win.cc
@@ -8,7 +8,6 @@
 
 #include "base/macros.h"
 #include "base/trace_event/trace_event.h"
-#include "content/common/gamepad_hardware_buffer.h"
 #include "content/common/gamepad_messages.h"
 
 namespace content {
@@ -44,10 +43,11 @@ RawGamepadInfo::~RawGamepadInfo() {
 }
 
 RawInputDataFetcher::RawInputDataFetcher()
-    : hid_dll_(base::FilePath(FILE_PATH_LITERAL("hid.dll"))),
-      rawinput_available_(GetHidDllFunctions()),
+    : rawinput_available_(false),
       filter_xinput_(true),
-      events_monitored_(false) {
+      events_monitored_(false),
+      last_source_id_(0),
+      last_enumeration_id_(0) {
 }
 
 RawInputDataFetcher::~RawInputDataFetcher() {
@@ -60,9 +60,15 @@ void RawInputDataFetcher::WillDestroyCurrentMessageLoop() {
   StopMonitor();
 }
 
+void RawInputDataFetcher::OnAddedToProvider() {
+  hid_dll_.Reset(base::LoadNativeLibrary(
+      base::FilePath(FILE_PATH_LITERAL("hid.dll")), nullptr));
+  rawinput_available_ = GetHidDllFunctions();
+}
+
 RAWINPUTDEVICE* RawInputDataFetcher::GetRawInputDevices(DWORD flags) {
   size_t usage_count = arraysize(DeviceUsages);
-  scoped_ptr<RAWINPUTDEVICE[]> devices(new RAWINPUTDEVICE[usage_count]);
+  std::unique_ptr<RAWINPUTDEVICE[]> devices(new RAWINPUTDEVICE[usage_count]);
   for (size_t i = 0; i < usage_count; ++i) {
     devices[i].dwFlags = flags;
     devices[i].usUsagePage = 1;
@@ -72,6 +78,13 @@ RAWINPUTDEVICE* RawInputDataFetcher::GetRawInputDevices(DWORD flags) {
   return devices.release();
 }
 
+void RawInputDataFetcher::PauseHint(bool pause) {
+  if (pause)
+    StopMonitor();
+  else
+    StartMonitor();
+}
+
 void RawInputDataFetcher::StartMonitor() {
   if (!rawinput_available_ || events_monitored_)
     return;
@@ -87,7 +100,8 @@ void RawInputDataFetcher::StartMonitor() {
   }
 
   // Register to receive raw HID input.
-  scoped_ptr<RAWINPUTDEVICE[]> devices(GetRawInputDevices(RIDEV_INPUTSINK));
+  std::unique_ptr<RAWINPUTDEVICE[]> devices(
+      GetRawInputDevices(RIDEV_INPUTSINK));
   if (!RegisterRawInputDevices(devices.get(), arraysize(DeviceUsages),
       sizeof(RAWINPUTDEVICE))) {
     PLOG(ERROR) << "RegisterRawInputDevices() failed for RIDEV_INPUTSINK";
@@ -109,7 +123,7 @@ void RawInputDataFetcher::StopMonitor() {
 
   // Stop receiving raw input.
   DCHECK(window_);
-  scoped_ptr<RAWINPUTDEVICE[]> devices(GetRawInputDevices(RIDEV_REMOVE));
+  std::unique_ptr<RAWINPUTDEVICE[]> devices(GetRawInputDevices(RIDEV_REMOVE));
 
   if (!RegisterRawInputDevices(devices.get(), arraysize(DeviceUsages),
       sizeof(RAWINPUTDEVICE))) {
@@ -131,56 +145,116 @@ void RawInputDataFetcher::ClearControllers() {
   }
 }
 
-std::vector<RawGamepadInfo*> RawInputDataFetcher::EnumerateDevices() {
-  std::vector<RawGamepadInfo*> valid_controllers;
+void RawInputDataFetcher::GetGamepadData(bool devices_changed_hint) {
+  if (!rawinput_available_)
+    return;
 
-  ClearControllers();
+  if (devices_changed_hint)
+    EnumerateDevices();
+
+  for (const auto& controller : controllers_) {
+    RawGamepadInfo* gamepad = controller.second;
+    PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_WIN_RAW,
+                                              gamepad->source_id);
+    if (!state)
+      continue;
+
+    WebGamepad& pad = state->data;
+
+    pad.timestamp = gamepad->report_id;
+    pad.buttonsLength = gamepad->buttons_length;
+    pad.axesLength =  gamepad->axes_length;
+
+    for (unsigned int i = 0; i < pad.buttonsLength; i++) {
+      pad.buttons[i].pressed = gamepad->buttons[i];
+      pad.buttons[i].value = gamepad->buttons[i] ? 1.0 : 0.0;
+    }
+
+    for (unsigned int i = 0; i < pad.axesLength; i++)
+      pad.axes[i] = gamepad->axes[i].value;
+  }
+}
+
+void RawInputDataFetcher::EnumerateDevices() {
+  last_enumeration_id_++;
 
   UINT count = 0;
   UINT result = GetRawInputDeviceList(NULL, &count, sizeof(RAWINPUTDEVICELIST));
   if (result == static_cast<UINT>(-1)) {
     PLOG(ERROR) << "GetRawInputDeviceList() failed";
-    return valid_controllers;
+    return;
   }
   DCHECK_EQ(0u, result);
 
-  scoped_ptr<RAWINPUTDEVICELIST[]> device_list(new RAWINPUTDEVICELIST[count]);
+  std::unique_ptr<RAWINPUTDEVICELIST[]> device_list(
+      new RAWINPUTDEVICELIST[count]);
   result = GetRawInputDeviceList(device_list.get(), &count,
       sizeof(RAWINPUTDEVICELIST));
   if (result == static_cast<UINT>(-1)) {
     PLOG(ERROR) << "GetRawInputDeviceList() failed";
-    return valid_controllers;
+    return;
   }
   DCHECK_EQ(count, result);
 
   for (UINT i = 0; i < count; ++i) {
     if (device_list[i].dwType == RIM_TYPEHID) {
       HANDLE device_handle = device_list[i].hDevice;
-      RawGamepadInfo* gamepad_info = ParseGamepadInfo(device_handle);
-      if (gamepad_info) {
-        controllers_[device_handle] = gamepad_info;
-        valid_controllers.push_back(gamepad_info);
+      ControllerMap::iterator controller = controllers_.find(device_handle);
+      
+      RawGamepadInfo* gamepad;
+      if (controller != controllers_.end()) {
+        gamepad = controller->second;
+      } else {
+        gamepad = ParseGamepadInfo(device_handle);
+        if (!gamepad)
+          continue;
+
+        PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_WIN_RAW,
+                                                  gamepad->source_id);
+        if (!state)
+          continue;  // No slot available for this gamepad.
+
+        controllers_[device_handle] = gamepad;
+
+        WebGamepad& pad = state->data;
+        pad.connected = true;
+
+        std::string vendor = base::StringPrintf("%04x", gamepad->vendor_id);
+        std::string product = base::StringPrintf("%04x", gamepad->product_id);
+        state->mapper = GetGamepadStandardMappingFunction(vendor, product);
+        state->axis_mask = 0;
+        state->button_mask = 0;
+
+        swprintf(pad.id, WebGamepad::idLengthCap,
+          L"%ls (%lsVendor: %04x Product: %04x)",
+          gamepad->id, state->mapper ? L"STANDARD GAMEPAD " : L"",
+          gamepad->vendor_id, gamepad->product_id);
+
+        if (state->mapper)
+          swprintf(pad.mapping, WebGamepad::mappingLengthCap, L"standard");
+        else
+          pad.mapping[0] = 0;
       }
+
+      gamepad->enumeration_id = last_enumeration_id_;
     }
   }
-  return valid_controllers;
-}
 
-RawGamepadInfo* RawInputDataFetcher::GetGamepadInfo(HANDLE handle) {
-  std::map<HANDLE, RawGamepadInfo*>::iterator it = controllers_.find(handle);
-  if (it != controllers_.end())
-    return it->second;
+  // Clear out old controllers that weren't part of this enumeration pass.
+  for (const auto& controller : controllers_) {
+    RawGamepadInfo* gamepad = controller.second;
+    if (gamepad->enumeration_id != last_enumeration_id_) {
+      controllers_.erase(gamepad->handle);
+      delete gamepad;
+    }
+  }
 
-  return NULL;
+  return;
 }
 
 RawGamepadInfo* RawInputDataFetcher::ParseGamepadInfo(HANDLE hDevice) {
   UINT size = 0;
 
-  // Do we already have this device in the map?
-  if (GetGamepadInfo(hDevice))
-    return NULL;
-
   // Query basic device info.
   UINT result = GetRawInputDeviceInfo(hDevice, RIDI_DEVICEINFO,
       NULL, &size);
@@ -190,7 +264,7 @@ RawGamepadInfo* RawInputDataFetcher::ParseGamepadInfo(HANDLE hDevice) {
   }
   DCHECK_EQ(0u, result);
 
-  scoped_ptr<uint8_t[]> di_buffer(new uint8_t[size]);
+  std::unique_ptr<uint8_t[]> di_buffer(new uint8_t[size]);
   RID_DEVICE_INFO* device_info =
       reinterpret_cast<RID_DEVICE_INFO*>(di_buffer.get());
   result = GetRawInputDeviceInfo(hDevice, RIDI_DEVICEINFO,
@@ -213,7 +287,8 @@ RawGamepadInfo* RawInputDataFetcher::ParseGamepadInfo(HANDLE hDevice) {
   if (!valid_type)
     return NULL;
 
-  scoped_ptr<RawGamepadInfo> gamepad_info(new RawGamepadInfo);
+  std::unique_ptr<RawGamepadInfo> gamepad_info(new RawGamepadInfo);
+  gamepad_info->source_id = ++last_source_id_;
   gamepad_info->handle = hDevice;
   gamepad_info->report_id = 0;
   gamepad_info->vendor_id = device_info->hid.dwVendorId;
@@ -232,7 +307,7 @@ RawGamepadInfo* RawInputDataFetcher::ParseGamepadInfo(HANDLE hDevice) {
   }
   DCHECK_EQ(0u, result);
 
-  scoped_ptr<wchar_t[]> name_buffer(new wchar_t[size]);
+  std::unique_ptr<wchar_t[]> name_buffer(new wchar_t[size]);
   result = GetRawInputDeviceInfo(hDevice, RIDI_DEVICENAME,
       name_buffer.get(), &size);
   if (result == static_cast<UINT>(-1)) {
@@ -287,7 +362,8 @@ RawGamepadInfo* RawInputDataFetcher::ParseGamepadInfo(HANDLE hDevice) {
   // Query button information.
   USHORT count = caps.NumberInputButtonCaps;
   if (count > 0) {
-    scoped_ptr<HIDP_BUTTON_CAPS[]> button_caps(new HIDP_BUTTON_CAPS[count]);
+    std::unique_ptr<HIDP_BUTTON_CAPS[]> button_caps(
+        new HIDP_BUTTON_CAPS[count]);
     status = hidp_get_button_caps_(
         HidP_Input, button_caps.get(), &count, gamepad_info->preparsed_data);
     DCHECK_EQ(HIDP_STATUS_SUCCESS, status);
@@ -305,7 +381,7 @@ RawGamepadInfo* RawInputDataFetcher::ParseGamepadInfo(HANDLE hDevice) {
 
   // Query axis information.
   count = caps.NumberInputValueCaps;
-  scoped_ptr<HIDP_VALUE_CAPS[]> axes_caps(new HIDP_VALUE_CAPS[count]);
+  std::unique_ptr<HIDP_VALUE_CAPS[]> axes_caps(new HIDP_VALUE_CAPS[count]);
   status = hidp_get_value_caps_(HidP_Input, axes_caps.get(), &count,
       gamepad_info->preparsed_data);
 
@@ -353,6 +429,10 @@ RawGamepadInfo* RawInputDataFetcher::ParseGamepadInfo(HANDLE hDevice) {
     }
   }
 
+  // Sometimes devices show up with no buttons or axes. Don't return these.
+  if (gamepad_info->buttons_length == 0 && gamepad_info->axes_length == 0)
+    return nullptr;
+
   return gamepad_info.release();
 }
 
@@ -377,7 +457,8 @@ void RawInputDataFetcher::UpdateGamepad(
                         reinterpret_cast<PCHAR>(input->data.hid.bRawData),
                         input->data.hid.dwSizeHid);
 
-    scoped_ptr<USAGE_AND_PAGE[]> usages(new USAGE_AND_PAGE[buttons_length]);
+    std::unique_ptr<USAGE_AND_PAGE[]> usages(
+        new USAGE_AND_PAGE[buttons_length]);
     status =
         hidp_get_usages_ex_(HidP_Input,
                             0,
@@ -445,7 +526,7 @@ LRESULT RawInputDataFetcher::OnInput(HRAWINPUT input_handle) {
   DCHECK_EQ(0u, result);
 
   // Retrieve the input record.
-  scoped_ptr<uint8_t[]> buffer(new uint8_t[size]);
+  std::unique_ptr<uint8_t[]> buffer(new uint8_t[size]);
   RAWINPUT* input = reinterpret_cast<RAWINPUT*>(buffer.get());
   result = GetRawInputData(
       input_handle, RID_INPUT, buffer.get(), &size, sizeof(RAWINPUTHEADER));
@@ -457,9 +538,9 @@ LRESULT RawInputDataFetcher::OnInput(HRAWINPUT input_handle) {
 
   // Notify the observer about events generated locally.
   if (input->header.dwType == RIM_TYPEHID && input->header.hDevice != NULL) {
-    RawGamepadInfo* gamepad = GetGamepadInfo(input->header.hDevice);
-    if (gamepad)
-      UpdateGamepad(input, gamepad);
+    ControllerMap::iterator it = controllers_.find(input->header.hDevice);
+    if (it != controllers_.end())
+      UpdateGamepad(input, it->second);
   }
 
   return DefRawInputProc(&input, 1, sizeof(RAWINPUTHEADER));
diff --git a/content/browser/gamepad/raw_input_data_fetcher_win.h b/content/browser/gamepad/raw_input_data_fetcher_win.h
index 69b780d..964ff7f 100644
--- a/content/browser/gamepad/raw_input_data_fetcher_win.h
+++ b/content/browser/gamepad/raw_input_data_fetcher_win.h
@@ -5,24 +5,23 @@
 #ifndef CONTENT_BROWSER_GAMEPAD_RAW_INPUT_DATA_FETCHER_WIN_H_
 #define CONTENT_BROWSER_GAMEPAD_RAW_INPUT_DATA_FETCHER_WIN_H_
 
-#include "build/build_config.h"
-
 #include <stdint.h>
 #include <stdlib.h>
 #include <Unknwn.h>
 #include <WinDef.h>
 #include <windows.h>
-
 #include <hidsdi.h>
+
 #include <map>
+#include <memory>
 #include <vector>
 
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
 #include "base/memory/weak_ptr.h"
 #include "base/message_loop/message_loop.h"
 #include "base/scoped_native_library.h"
 #include "base/win/message_window.h"
+#include "build/build_config.h"
 #include "content/browser/gamepad/gamepad_data_fetcher.h"
 #include "content/browser/gamepad/gamepad_standard_mappings.h"
 #include "third_party/WebKit/public/platform/WebGamepads.h"
@@ -40,8 +39,10 @@ struct RawGamepadInfo {
   RawGamepadInfo();
   ~RawGamepadInfo();
 
+  int source_id;
+  int enumeration_id;
   HANDLE handle;
-  scoped_ptr<uint8_t[]> ppd_buffer;
+  std::unique_ptr<uint8_t[]> ppd_buffer;
   PHIDP_PREPARSED_DATA preparsed_data;
 
   uint32_t report_id;
@@ -58,7 +59,8 @@ struct RawGamepadInfo {
 };
 
 class RawInputDataFetcher
-    : public base::SupportsWeakPtr<RawInputDataFetcher>,
+    : public GamepadDataFetcher,
+      public base::SupportsWeakPtr<RawInputDataFetcher>,
       public base::MessageLoop::DestructionObserver {
  public:
   explicit RawInputDataFetcher();
@@ -67,14 +69,15 @@ class RawInputDataFetcher
   // DestructionObserver overrides.
   void WillDestroyCurrentMessageLoop() override;
 
-  bool Available() { return rawinput_available_; }
-  void StartMonitor();
-  void StopMonitor();
-
-  std::vector<RawGamepadInfo*> EnumerateDevices();
-  RawGamepadInfo* GetGamepadInfo(HANDLE handle);
+  void GetGamepadData(bool devices_changed_hint) override;
+  void PauseHint(bool paused) override;
 
  private:
+  void OnAddedToProvider() override;
+
+  void StartMonitor();
+  void StopMonitor();
+  void EnumerateDevices();
   RawGamepadInfo* ParseGamepadInfo(HANDLE hDevice);
   void UpdateGamepad(RAWINPUT* input, RawGamepadInfo* gamepad_info);
   // Handles WM_INPUT messages.
@@ -120,12 +123,15 @@ class RawInputDataFetcher
   bool GetHidDllFunctions();
 
   base::ScopedNativeLibrary hid_dll_;
-  scoped_ptr<base::win::MessageWindow> window_;
+  std::unique_ptr<base::win::MessageWindow> window_;
   bool rawinput_available_;
   bool filter_xinput_;
   bool events_monitored_;
+  int last_source_id_;
+  int last_enumeration_id_;
 
-  std::map<HANDLE, RawGamepadInfo*> controllers_;
+  typedef std::map<HANDLE, RawGamepadInfo*> ControllerMap;
+  ControllerMap controllers_;
 
   // Function pointers to HID functionality, retrieved in
   // |GetHidDllFunctions|.
diff --git a/content/browser/gamepad/xbox_data_fetcher_mac.cc b/content/browser/gamepad/xbox_data_fetcher_mac.cc
deleted file mode 100644
index 7ef3531..0000000
--- a/content/browser/gamepad/xbox_data_fetcher_mac.cc
+++ b/content/browser/gamepad/xbox_data_fetcher_mac.cc
@@ -1,809 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "content/browser/gamepad/xbox_data_fetcher_mac.h"
-
-#include <algorithm>
-#include <cmath>
-#include <limits>
-
-#include <CoreFoundation/CoreFoundation.h>
-#include <IOKit/IOCFPlugIn.h>
-#include <IOKit/IOKitLib.h>
-#include <IOKit/usb/IOUSBLib.h>
-#include <IOKit/usb/USB.h>
-
-#include "base/logging.h"
-#include "base/mac/foundation_util.h"
-
-namespace {
-const int kVendorMicrosoft = 0x045e;
-const int kProductXbox360Controller = 0x028e;
-const int kProductXboxOneController = 0x02d1;
-
-const int kXbox360ReadEndpoint = 1;
-const int kXbox360ControlEndpoint = 2;
-
-const int kXboxOneReadEndpoint = 2;
-const int kXboxOneControlEndpoint = 1;
-
-enum {
-  STATUS_MESSAGE_BUTTONS = 0,
-  STATUS_MESSAGE_LED = 1,
-
-  // Apparently this message tells you if the rumble pack is disabled in the
-  // controller. If the rumble pack is disabled, vibration control messages
-  // have no effect.
-  STATUS_MESSAGE_RUMBLE = 3,
-};
-
-enum {
-  XBOX_ONE_STATUS_MESSAGE_BUTTONS = 0x20,
-};
-
-enum {
-  CONTROL_MESSAGE_SET_RUMBLE = 0,
-  CONTROL_MESSAGE_SET_LED = 1,
-};
-
-#pragma pack(push, 1)
-struct Xbox360ButtonData {
-  bool dpad_up    : 1;
-  bool dpad_down  : 1;
-  bool dpad_left  : 1;
-  bool dpad_right : 1;
-
-  bool start             : 1;
-  bool back              : 1;
-  bool stick_left_click  : 1;
-  bool stick_right_click : 1;
-
-  bool bumper_left  : 1;
-  bool bumper_right : 1;
-  bool guide        : 1;
-  bool dummy1       : 1;  // Always 0.
-
-  bool a : 1;
-  bool b : 1;
-  bool x : 1;
-  bool y : 1;
-
-  uint8_t trigger_left;
-  uint8_t trigger_right;
-
-  int16_t stick_left_x;
-  int16_t stick_left_y;
-  int16_t stick_right_x;
-  int16_t stick_right_y;
-
-  // Always 0.
-  uint32_t dummy2;
-  uint16_t dummy3;
-};
-
-struct XboxOneButtonData {
-  bool sync   : 1;
-  bool dummy1 : 1;  // Always 0.
-  bool start  : 1;
-  bool back   : 1;
-
-  bool a : 1;
-  bool b : 1;
-  bool x : 1;
-  bool y : 1;
-
-  bool dpad_up    : 1;
-  bool dpad_down  : 1;
-  bool dpad_left  : 1;
-  bool dpad_right : 1;
-
-  bool bumper_left       : 1;
-  bool bumper_right      : 1;
-  bool stick_left_click  : 1;
-  bool stick_right_click : 1;
-
-  uint16_t trigger_left;
-  uint16_t trigger_right;
-
-  int16_t stick_left_x;
-  int16_t stick_left_y;
-  int16_t stick_right_x;
-  int16_t stick_right_y;
-};
-#pragma pack(pop)
-
-static_assert(sizeof(Xbox360ButtonData) == 18, "xbox button data wrong size");
-static_assert(sizeof(XboxOneButtonData) == 14, "xbox button data wrong size");
-
-// From MSDN:
-// http://msdn.microsoft.com/en-us/library/windows/desktop/ee417001(v=vs.85).aspx#dead_zone
-const int16_t kLeftThumbDeadzone = 7849;
-const int16_t kRightThumbDeadzone = 8689;
-const uint8_t kXbox360TriggerDeadzone = 30;
-const uint16_t kXboxOneTriggerMax = 1023;
-const uint16_t kXboxOneTriggerDeadzone = 120;
-
-void NormalizeAxis(int16_t x,
-                   int16_t y,
-                   int16_t deadzone,
-                   float* x_out,
-                   float* y_out) {
-  float x_val = x;
-  float y_val = y;
-
-  // Determine how far the stick is pushed.
-  float real_magnitude = std::sqrt(x_val * x_val + y_val * y_val);
-
-  // Check if the controller is outside a circular dead zone.
-  if (real_magnitude > deadzone) {
-    // Clip the magnitude at its expected maximum value.
-    float magnitude = std::min(32767.0f, real_magnitude);
-
-    // Adjust magnitude relative to the end of the dead zone.
-    magnitude -= deadzone;
-
-    // Normalize the magnitude with respect to its expected range giving a
-    // magnitude value of 0.0 to 1.0
-    float ratio = (magnitude / (32767 - deadzone)) / real_magnitude;
-
-    // Y is negated because xbox controllers have an opposite sign from
-    // the 'standard controller' recommendations.
-    *x_out = x_val * ratio;
-    *y_out = -y_val * ratio;
-  } else {
-    // If the controller is in the deadzone zero out the magnitude.
-    *x_out = *y_out = 0.0f;
-  }
-}
-
-float NormalizeTrigger(uint8_t value) {
-  return value < kXbox360TriggerDeadzone
-             ? 0
-             : static_cast<float>(value - kXbox360TriggerDeadzone) /
-                   (std::numeric_limits<uint8_t>::max() -
-                    kXbox360TriggerDeadzone);
-}
-
-float NormalizeXboxOneTrigger(uint16_t value) {
-  return value < kXboxOneTriggerDeadzone ? 0 :
-      static_cast<float>(value - kXboxOneTriggerDeadzone) /
-          (kXboxOneTriggerMax - kXboxOneTriggerDeadzone);
-}
-
-void NormalizeXbox360ButtonData(const Xbox360ButtonData& data,
-    XboxController::Data* normalized_data) {
-  normalized_data->buttons[0] = data.a;
-  normalized_data->buttons[1] = data.b;
-  normalized_data->buttons[2] = data.x;
-  normalized_data->buttons[3] = data.y;
-  normalized_data->buttons[4] = data.bumper_left;
-  normalized_data->buttons[5] = data.bumper_right;
-  normalized_data->buttons[6] = data.back;
-  normalized_data->buttons[7] = data.start;
-  normalized_data->buttons[8] = data.stick_left_click;
-  normalized_data->buttons[9] = data.stick_right_click;
-  normalized_data->buttons[10] = data.dpad_up;
-  normalized_data->buttons[11] = data.dpad_down;
-  normalized_data->buttons[12] = data.dpad_left;
-  normalized_data->buttons[13] = data.dpad_right;
-  normalized_data->buttons[14] = data.guide;
-  normalized_data->triggers[0] = NormalizeTrigger(data.trigger_left);
-  normalized_data->triggers[1] = NormalizeTrigger(data.trigger_right);
-  NormalizeAxis(data.stick_left_x,
-                data.stick_left_y,
-                kLeftThumbDeadzone,
-                &normalized_data->axes[0],
-                &normalized_data->axes[1]);
-  NormalizeAxis(data.stick_right_x,
-                data.stick_right_y,
-                kRightThumbDeadzone,
-                &normalized_data->axes[2],
-                &normalized_data->axes[3]);
-}
-
-void NormalizeXboxOneButtonData(const XboxOneButtonData& data,
-    XboxController::Data* normalized_data) {
-  normalized_data->buttons[0] = data.a;
-  normalized_data->buttons[1] = data.b;
-  normalized_data->buttons[2] = data.x;
-  normalized_data->buttons[3] = data.y;
-  normalized_data->buttons[4] = data.bumper_left;
-  normalized_data->buttons[5] = data.bumper_right;
-  normalized_data->buttons[6] = data.back;
-  normalized_data->buttons[7] = data.start;
-  normalized_data->buttons[8] = data.stick_left_click;
-  normalized_data->buttons[9] = data.stick_right_click;
-  normalized_data->buttons[10] = data.dpad_up;
-  normalized_data->buttons[11] = data.dpad_down;
-  normalized_data->buttons[12] = data.dpad_left;
-  normalized_data->buttons[13] = data.dpad_right;
-  normalized_data->buttons[14] = data.sync;
-  normalized_data->triggers[0] = NormalizeXboxOneTrigger(data.trigger_left);
-  normalized_data->triggers[1] = NormalizeXboxOneTrigger(data.trigger_right);
-  NormalizeAxis(data.stick_left_x,
-                data.stick_left_y,
-                kLeftThumbDeadzone,
-                &normalized_data->axes[0],
-                &normalized_data->axes[1]);
-  NormalizeAxis(data.stick_right_x,
-                data.stick_right_y,
-                kRightThumbDeadzone,
-                &normalized_data->axes[2],
-                &normalized_data->axes[3]);
-}
-
-}  // namespace
-
-XboxController::XboxController(Delegate* delegate)
-    : device_(NULL),
-      interface_(NULL),
-      device_is_open_(false),
-      interface_is_open_(false),
-      read_buffer_size_(0),
-      led_pattern_(LED_NUM_PATTERNS),
-      location_id_(0),
-      delegate_(delegate),
-      controller_type_(UNKNOWN_CONTROLLER),
-      read_endpoint_(0),
-      control_endpoint_(0) {
-}
-
-XboxController::~XboxController() {
-  if (source_)
-    CFRunLoopSourceInvalidate(source_);
-  if (interface_ && interface_is_open_)
-    (*interface_)->USBInterfaceClose(interface_);
-  if (device_ && device_is_open_)
-    (*device_)->USBDeviceClose(device_);
-}
-
-bool XboxController::OpenDevice(io_service_t service) {
-  IOCFPlugInInterface **plugin;
-  SInt32 score;  // Unused, but required for IOCreatePlugInInterfaceForService.
-  kern_return_t kr =
-      IOCreatePlugInInterfaceForService(service,
-                                        kIOUSBDeviceUserClientTypeID,
-                                        kIOCFPlugInInterfaceID,
-                                        &plugin,
-                                        &score);
-  if (kr != KERN_SUCCESS)
-    return false;
-  base::mac::ScopedIOPluginInterface<IOCFPlugInInterface> plugin_ref(plugin);
-
-  HRESULT res =
-      (*plugin)->QueryInterface(plugin,
-                                CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID320),
-                                (LPVOID *)&device_);
-  if (!SUCCEEDED(res) || !device_)
-    return false;
-
-  UInt16 vendor_id;
-  kr = (*device_)->GetDeviceVendor(device_, &vendor_id);
-  if (kr != KERN_SUCCESS || vendor_id != kVendorMicrosoft)
-    return false;
-
-  UInt16 product_id;
-  kr = (*device_)->GetDeviceProduct(device_, &product_id);
-  if (kr != KERN_SUCCESS)
-    return false;
-
-  IOUSBFindInterfaceRequest request;
-  switch (product_id) {
-    case kProductXbox360Controller:
-      controller_type_ = XBOX_360_CONTROLLER;
-      read_endpoint_ = kXbox360ReadEndpoint;
-      control_endpoint_ = kXbox360ControlEndpoint;
-      request.bInterfaceClass = 255;
-      request.bInterfaceSubClass = 93;
-      request.bInterfaceProtocol = 1;
-      request.bAlternateSetting = kIOUSBFindInterfaceDontCare;
-      break;
-    case kProductXboxOneController:
-      controller_type_ = XBOX_ONE_CONTROLLER;
-      read_endpoint_ = kXboxOneReadEndpoint;
-      control_endpoint_ = kXboxOneControlEndpoint;
-      request.bInterfaceClass = 255;
-      request.bInterfaceSubClass = 71;
-      request.bInterfaceProtocol = 208;
-      request.bAlternateSetting = kIOUSBFindInterfaceDontCare;
-      break;
-    default:
-      return false;
-  }
-
-  // Open the device and configure it.
-  kr = (*device_)->USBDeviceOpen(device_);
-  if (kr != KERN_SUCCESS)
-    return false;
-  device_is_open_ = true;
-
-  // Xbox controllers have one configuration option which has configuration
-  // value 1. Try to set it and fail if it couldn't be configured.
-  IOUSBConfigurationDescriptorPtr config_desc;
-  kr = (*device_)->GetConfigurationDescriptorPtr(device_, 0, &config_desc);
-  if (kr != KERN_SUCCESS)
-    return false;
-  kr = (*device_)->SetConfiguration(device_, config_desc->bConfigurationValue);
-  if (kr != KERN_SUCCESS)
-    return false;
-
-  // The device has 4 interfaces. They are as follows:
-  // Protocol 1:
-  //  - Endpoint 1 (in) : Controller events, including button presses.
-  //  - Endpoint 2 (out): Rumble pack and LED control
-  // Protocol 2 has a single endpoint to read from a connected ChatPad device.
-  // Protocol 3 is used by a connected headset device.
-  // The device also has an interface on subclass 253, protocol 10 with no
-  // endpoints.  It is unused.
-  //
-  // We don't currently support the ChatPad or headset, so protocol 1 is the
-  // only protocol we care about.
-  //
-  // For more detail, see
-  // https://github.com/Grumbel/xboxdrv/blob/master/PROTOCOL
-  io_iterator_t iter;
-  kr = (*device_)->CreateInterfaceIterator(device_, &request, &iter);
-  if (kr != KERN_SUCCESS)
-    return false;
-  base::mac::ScopedIOObject<io_iterator_t> iter_ref(iter);
-
-  // There should be exactly one USB interface which matches the requested
-  // settings.
-  io_service_t usb_interface = IOIteratorNext(iter);
-  if (!usb_interface)
-    return false;
-
-  // We need to make an InterfaceInterface to communicate with the device
-  // endpoint. This is the same process as earlier: first make a
-  // PluginInterface from the io_service then make the InterfaceInterface from
-  // that.
-  IOCFPlugInInterface **plugin_interface;
-  kr = IOCreatePlugInInterfaceForService(usb_interface,
-                                         kIOUSBInterfaceUserClientTypeID,
-                                         kIOCFPlugInInterfaceID,
-                                         &plugin_interface,
-                                         &score);
-  if (kr != KERN_SUCCESS || !plugin_interface)
-    return false;
-  base::mac::ScopedIOPluginInterface<IOCFPlugInInterface> interface_ref(
-      plugin_interface);
-
-  // Release the USB interface, and any subsequent interfaces returned by the
-  // iterator. (There shouldn't be any, but in case a future device does
-  // contain more interfaces, this will serve to avoid memory leaks.)
-  do {
-    IOObjectRelease(usb_interface);
-  } while ((usb_interface = IOIteratorNext(iter)));
-
-  // Actually create the interface.
-  res = (*plugin_interface)->QueryInterface(
-      plugin_interface,
-      CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID300),
-      (LPVOID *)&interface_);
-
-  if (!SUCCEEDED(res) || !interface_)
-    return false;
-
-  // Actually open the interface.
-  kr = (*interface_)->USBInterfaceOpen(interface_);
-  if (kr != KERN_SUCCESS)
-    return false;
-  interface_is_open_ = true;
-
-  CFRunLoopSourceRef source_ref;
-  kr = (*interface_)->CreateInterfaceAsyncEventSource(interface_, &source_ref);
-  if (kr != KERN_SUCCESS || !source_ref)
-    return false;
-  source_.reset(source_ref);
-  CFRunLoopAddSource(CFRunLoopGetCurrent(), source_, kCFRunLoopDefaultMode);
-
-  // The interface should have two pipes. Pipe 1 with direction kUSBIn and pipe
-  // 2 with direction kUSBOut. Both pipes should have type kUSBInterrupt.
-  uint8_t num_endpoints;
-  kr = (*interface_)->GetNumEndpoints(interface_, &num_endpoints);
-  if (kr != KERN_SUCCESS || num_endpoints < 2)
-    return false;
-
-  for (int i = 1; i <= 2; i++) {
-    uint8_t direction;
-    uint8_t number;
-    uint8_t transfer_type;
-    uint16_t max_packet_size;
-    uint8_t interval;
-
-    kr = (*interface_)->GetPipeProperties(interface_,
-                                          i,
-                                          &direction,
-                                          &number,
-                                          &transfer_type,
-                                          &max_packet_size,
-                                          &interval);
-    if (kr != KERN_SUCCESS || transfer_type != kUSBInterrupt) {
-      return false;
-    }
-    if (i == read_endpoint_) {
-      if (direction != kUSBIn)
-        return false;
-      read_buffer_.reset(new uint8_t[max_packet_size]);
-      read_buffer_size_ = max_packet_size;
-      QueueRead();
-    } else if (i == control_endpoint_) {
-      if (direction != kUSBOut)
-        return false;
-      if (controller_type_ == XBOX_ONE_CONTROLLER)
-        WriteXboxOneInit();
-    }
-  }
-
-  // The location ID is unique per controller, and can be used to track
-  // controllers through reconnections (though if a controller is detached from
-  // one USB hub and attached to another, the location ID will change).
-  kr = (*device_)->GetLocationID(device_, &location_id_);
-  if (kr != KERN_SUCCESS)
-    return false;
-
-  return true;
-}
-
-void XboxController::SetLEDPattern(LEDPattern pattern) {
-  led_pattern_ = pattern;
-  const UInt8 length = 3;
-
-  // This buffer will be released in WriteComplete when WritePipeAsync
-  // finishes.
-  UInt8* buffer = new UInt8[length];
-  buffer[0] = static_cast<UInt8>(CONTROL_MESSAGE_SET_LED);
-  buffer[1] = length;
-  buffer[2] = static_cast<UInt8>(pattern);
-  kern_return_t kr = (*interface_)->WritePipeAsync(interface_,
-                                                   control_endpoint_,
-                                                   buffer,
-                                                   (UInt32)length,
-                                                   WriteComplete,
-                                                   buffer);
-  if (kr != KERN_SUCCESS) {
-    delete[] buffer;
-    IOError();
-    return;
-  }
-}
-
-int XboxController::GetVendorId() const {
-  return kVendorMicrosoft;
-}
-
-int XboxController::GetProductId() const {
-  if (controller_type_ == XBOX_360_CONTROLLER)
-    return kProductXbox360Controller;
-  else
-    return kProductXboxOneController;
-}
-
-XboxController::ControllerType XboxController::GetControllerType() const {
-  return controller_type_;
-}
-
-void XboxController::WriteComplete(void* context, IOReturn result, void* arg0) {
-  UInt8* buffer = static_cast<UInt8*>(context);
-  delete[] buffer;
-
-  // Ignoring any errors sending data, because they will usually only occur
-  // when the device is disconnected, in which case it really doesn't matter if
-  // the data got to the controller or not.
-  if (result != kIOReturnSuccess)
-    return;
-}
-
-void XboxController::GotData(void* context, IOReturn result, void* arg0) {
-  size_t bytes_read = reinterpret_cast<size_t>(arg0);
-  XboxController* controller = static_cast<XboxController*>(context);
-
-  if (result != kIOReturnSuccess) {
-    // This will happen if the device was disconnected. The gamepad has
-    // probably been destroyed by a meteorite.
-    controller->IOError();
-    return;
-  }
-
-  if (controller->GetControllerType() == XBOX_360_CONTROLLER)
-    controller->ProcessXbox360Packet(bytes_read);
-  else
-    controller->ProcessXboxOnePacket(bytes_read);
-
-  // Queue up another read.
-  controller->QueueRead();
-}
-
-void XboxController::ProcessXbox360Packet(size_t length) {
-  if (length < 2)
-    return;
-  DCHECK(length <= read_buffer_size_);
-  if (length > read_buffer_size_) {
-    IOError();
-    return;
-  }
-  uint8_t* buffer = read_buffer_.get();
-
-  if (buffer[1] != length)
-    // Length in packet doesn't match length reported by USB.
-    return;
-
-  uint8_t type = buffer[0];
-  buffer += 2;
-  length -= 2;
-  switch (type) {
-    case STATUS_MESSAGE_BUTTONS: {
-      if (length != sizeof(Xbox360ButtonData))
-        return;
-      Xbox360ButtonData* data = reinterpret_cast<Xbox360ButtonData*>(buffer);
-      Data normalized_data;
-      NormalizeXbox360ButtonData(*data, &normalized_data);
-      delegate_->XboxControllerGotData(this, normalized_data);
-      break;
-    }
-    case STATUS_MESSAGE_LED:
-      if (length != 3)
-        return;
-      // The controller sends one of these messages every time the LED pattern
-      // is set, as well as once when it is plugged in.
-      if (led_pattern_ == LED_NUM_PATTERNS && buffer[0] < LED_NUM_PATTERNS)
-        led_pattern_ = static_cast<LEDPattern>(buffer[0]);
-      break;
-    default:
-      // Unknown packet: ignore!
-      break;
-  }
-}
-
-void XboxController::ProcessXboxOnePacket(size_t length) {
-  if (length < 2)
-    return;
-  DCHECK(length <= read_buffer_size_);
-  if (length > read_buffer_size_) {
-    IOError();
-    return;
-  }
-  uint8_t* buffer = read_buffer_.get();
-
-  uint8_t type = buffer[0];
-  buffer += 4;
-  length -= 4;
-  switch (type) {
-    case XBOX_ONE_STATUS_MESSAGE_BUTTONS: {
-      if (length != sizeof(XboxOneButtonData))
-        return;
-      XboxOneButtonData* data = reinterpret_cast<XboxOneButtonData*>(buffer);
-      Data normalized_data;
-      NormalizeXboxOneButtonData(*data, &normalized_data);
-      delegate_->XboxControllerGotData(this, normalized_data);
-      break;
-    }
-    default:
-      // Unknown packet: ignore!
-      break;
-  }
-}
-
-void XboxController::QueueRead() {
-  kern_return_t kr = (*interface_)->ReadPipeAsync(interface_,
-                                                  read_endpoint_,
-                                                  read_buffer_.get(),
-                                                  read_buffer_size_,
-                                                  GotData,
-                                                  this);
-  if (kr != KERN_SUCCESS)
-    IOError();
-}
-
-void XboxController::IOError() {
-  delegate_->XboxControllerError(this);
-}
-
-void XboxController::WriteXboxOneInit() {
-  const UInt8 length = 2;
-
-  // This buffer will be released in WriteComplete when WritePipeAsync
-  // finishes.
-  UInt8* buffer = new UInt8[length];
-  buffer[0] = 0x05;
-  buffer[1] = 0x20;
-  kern_return_t kr = (*interface_)->WritePipeAsync(interface_,
-                                                   control_endpoint_,
-                                                   buffer,
-                                                   (UInt32)length,
-                                                   WriteComplete,
-                                                   buffer);
-  if (kr != KERN_SUCCESS) {
-    delete[] buffer;
-    IOError();
-    return;
-  }
-}
-
-//-----------------------------------------------------------------------------
-
-XboxDataFetcher::XboxDataFetcher(Delegate* delegate)
-    : delegate_(delegate),
-      listening_(false),
-      source_(NULL),
-      port_(NULL) {
-}
-
-XboxDataFetcher::~XboxDataFetcher() {
-  while (!controllers_.empty()) {
-    RemoveController(*controllers_.begin());
-  }
-  UnregisterFromNotifications();
-}
-
-void XboxDataFetcher::DeviceAdded(void* context, io_iterator_t iterator) {
-  DCHECK(context);
-  XboxDataFetcher* fetcher = static_cast<XboxDataFetcher*>(context);
-  io_service_t ref;
-  while ((ref = IOIteratorNext(iterator))) {
-    base::mac::ScopedIOObject<io_service_t> scoped_ref(ref);
-    XboxController* controller = new XboxController(fetcher);
-    if (controller->OpenDevice(ref)) {
-      fetcher->AddController(controller);
-    } else {
-      delete controller;
-    }
-  }
-}
-
-void XboxDataFetcher::DeviceRemoved(void* context, io_iterator_t iterator) {
-  DCHECK(context);
-  XboxDataFetcher* fetcher = static_cast<XboxDataFetcher*>(context);
-  io_service_t ref;
-  while ((ref = IOIteratorNext(iterator))) {
-    base::mac::ScopedIOObject<io_service_t> scoped_ref(ref);
-    base::ScopedCFTypeRef<CFNumberRef> number(
-        base::mac::CFCastStrict<CFNumberRef>(
-            IORegistryEntryCreateCFProperty(ref,
-                                            CFSTR(kUSBDevicePropertyLocationID),
-                                            kCFAllocatorDefault,
-                                            kNilOptions)));
-    UInt32 location_id = 0;
-    CFNumberGetValue(number, kCFNumberSInt32Type, &location_id);
-    fetcher->RemoveControllerByLocationID(location_id);
-  }
-}
-
-bool XboxDataFetcher::RegisterForNotifications() {
-  if (listening_)
-    return true;
-  port_ = IONotificationPortCreate(kIOMasterPortDefault);
-  if (!port_)
-    return false;
-  source_ = IONotificationPortGetRunLoopSource(port_);
-  if (!source_)
-    return false;
-  CFRunLoopAddSource(CFRunLoopGetCurrent(), source_, kCFRunLoopDefaultMode);
-
-  listening_ = true;
-
-  if (!RegisterForDeviceNotifications(
-      kVendorMicrosoft, kProductXboxOneController,
-      &xbox_one_device_added_iter_,
-      &xbox_one_device_removed_iter_))
-    return false;
-
-  if (!RegisterForDeviceNotifications(
-      kVendorMicrosoft, kProductXbox360Controller,
-      &xbox_360_device_added_iter_,
-      &xbox_360_device_removed_iter_))
-    return false;
-
-  return true;
-}
-
-bool XboxDataFetcher::RegisterForDeviceNotifications(
-    int vendor_id,
-    int product_id,
-    base::mac::ScopedIOObject<io_iterator_t>* added_iter,
-    base::mac::ScopedIOObject<io_iterator_t>* removed_iter) {
-  base::ScopedCFTypeRef<CFNumberRef> vendor_cf(CFNumberCreate(
-      kCFAllocatorDefault, kCFNumberSInt32Type, &vendor_id));
-  base::ScopedCFTypeRef<CFNumberRef> product_cf(CFNumberCreate(
-      kCFAllocatorDefault, kCFNumberSInt32Type, &product_id));
-  base::ScopedCFTypeRef<CFMutableDictionaryRef> matching_dict(
-      IOServiceMatching(kIOUSBDeviceClassName));
-  if (!matching_dict)
-    return false;
-  CFDictionarySetValue(matching_dict, CFSTR(kUSBVendorID), vendor_cf);
-  CFDictionarySetValue(matching_dict, CFSTR(kUSBProductID), product_cf);
-
-  // IOServiceAddMatchingNotification() releases the dictionary when it's done.
-  // Retain it before each call to IOServiceAddMatchingNotification to keep
-  // things balanced.
-  CFRetain(matching_dict);
-  io_iterator_t device_added_iter;
-  IOReturn ret;
-  ret = IOServiceAddMatchingNotification(port_,
-                                         kIOFirstMatchNotification,
-                                         matching_dict,
-                                         DeviceAdded,
-                                         this,
-                                         &device_added_iter);
-  added_iter->reset(device_added_iter);
-  if (ret != kIOReturnSuccess) {
-    LOG(ERROR) << "Error listening for Xbox controller add events: " << ret;
-    return false;
-  }
-  DeviceAdded(this, added_iter->get());
-
-  CFRetain(matching_dict);
-  io_iterator_t device_removed_iter;
-  ret = IOServiceAddMatchingNotification(port_,
-                                         kIOTerminatedNotification,
-                                         matching_dict,
-                                         DeviceRemoved,
-                                         this,
-                                         &device_removed_iter);
-  removed_iter->reset(device_removed_iter);
-  if (ret != kIOReturnSuccess) {
-    LOG(ERROR) << "Error listening for Xbox controller remove events: " << ret;
-    return false;
-  }
-  DeviceRemoved(this, removed_iter->get());
-  return true;
-}
-
-void XboxDataFetcher::UnregisterFromNotifications() {
-  if (!listening_)
-    return;
-  listening_ = false;
-  if (source_)
-    CFRunLoopSourceInvalidate(source_);
-  if (port_)
-    IONotificationPortDestroy(port_);
-  port_ = NULL;
-}
-
-XboxController* XboxDataFetcher::ControllerForLocation(UInt32 location_id) {
-  for (std::set<XboxController*>::iterator i = controllers_.begin();
-       i != controllers_.end();
-       ++i) {
-    if ((*i)->location_id() == location_id)
-      return *i;
-  }
-  return NULL;
-}
-
-void XboxDataFetcher::AddController(XboxController* controller) {
-  DCHECK(!ControllerForLocation(controller->location_id()))
-      << "Controller with location ID " << controller->location_id()
-      << " already exists in the set of controllers.";
-  controllers_.insert(controller);
-  delegate_->XboxDeviceAdd(controller);
-}
-
-void XboxDataFetcher::RemoveController(XboxController* controller) {
-  delegate_->XboxDeviceRemove(controller);
-  controllers_.erase(controller);
-  delete controller;
-}
-
-void XboxDataFetcher::RemoveControllerByLocationID(uint32_t location_id) {
-  XboxController* controller = NULL;
-  for (std::set<XboxController*>::iterator i = controllers_.begin();
-       i != controllers_.end();
-       ++i) {
-    if ((*i)->location_id() == location_id) {
-      controller = *i;
-      break;
-    }
-  }
-  if (controller)
-    RemoveController(controller);
-}
-
-void XboxDataFetcher::XboxControllerGotData(XboxController* controller,
-                                            const XboxController::Data& data) {
-  delegate_->XboxValueChanged(controller, data);
-}
-
-void XboxDataFetcher::XboxControllerError(XboxController* controller) {
-  RemoveController(controller);
-}
diff --git a/content/browser/gamepad/xbox_data_fetcher_mac.h b/content/browser/gamepad/xbox_data_fetcher_mac.h
index 599a63c..54dd147 100644
--- a/content/browser/gamepad/xbox_data_fetcher_mac.h
+++ b/content/browser/gamepad/xbox_data_fetcher_mac.h
@@ -10,13 +10,19 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include <memory>
 #include <set>
 
 #include "base/mac/scoped_cftyperef.h"
 #include "base/mac/scoped_ioobject.h"
 #include "base/mac/scoped_ioplugininterface.h"
 #include "base/macros.h"
-#include "base/memory/scoped_ptr.h"
+#include "content/browser/gamepad/gamepad_data_fetcher.h"
+
+struct IOUSBDeviceStruct320;
+struct IOUSBInterfaceStruct300;
+
+namespace content {
 
 class XboxController {
  public:
@@ -101,11 +107,11 @@ class XboxController {
 
   // Handle for the USB device. IOUSBDeviceStruct320 is the latest version of
   // the device API that is supported on Mac OS 10.6.
-  base::mac::ScopedIOPluginInterface<struct IOUSBDeviceStruct320> device_;
+  base::mac::ScopedIOPluginInterface<IOUSBDeviceStruct320> device_;
 
   // Handle for the interface on the device which sends button and analog data.
   // The other interfaces (for the ChatPad and headset) are ignored.
-  base::mac::ScopedIOPluginInterface<struct IOUSBInterfaceStruct300> interface_;
+  base::mac::ScopedIOPluginInterface<IOUSBInterfaceStruct300> interface_;
 
   bool device_is_open_;
   bool interface_is_open_;
@@ -119,7 +125,7 @@ class XboxController {
   // byte header (type, total length) so we can reframe the packet data
   // ourselves.
   uint16_t read_buffer_size_;
-  scoped_ptr<uint8_t[]> read_buffer_;
+  std::unique_ptr<uint8_t[]> read_buffer_;
 
   // The pattern that the LEDs on the device are currently displaying, or
   // LED_NUM_PATTERNS if unknown.
@@ -136,18 +142,13 @@ class XboxController {
   DISALLOW_COPY_AND_ASSIGN(XboxController);
 };
 
-class XboxDataFetcher : public XboxController::Delegate {
+class XboxDataFetcher : public GamepadDataFetcher,
+                        public XboxController::Delegate {
  public:
-  class Delegate {
-   public:
-    virtual void XboxDeviceAdd(XboxController* device) = 0;
-    virtual void XboxDeviceRemove(XboxController* device) = 0;
-    virtual void XboxValueChanged(XboxController* device,
-                                  const XboxController::Data& data) = 0;
-  };
+  XboxDataFetcher();
+  ~XboxDataFetcher() override;
 
-  explicit XboxDataFetcher(Delegate* delegate);
-  virtual ~XboxDataFetcher();
+  void GetGamepadData(bool devices_changed_hint) override;
 
   bool RegisterForNotifications();
   bool RegisterForDeviceNotifications(
@@ -162,6 +163,7 @@ class XboxDataFetcher : public XboxController::Delegate {
  private:
   static void DeviceAdded(void* context, io_iterator_t iterator);
   static void DeviceRemoved(void* context, io_iterator_t iterator);
+  void OnAddedToProvider() override;
   void AddController(XboxController* controller);
   void RemoveController(XboxController* controller);
   void RemoveControllerByLocationID(uint32_t id);
@@ -169,7 +171,7 @@ class XboxDataFetcher : public XboxController::Delegate {
                              const XboxController::Data& data) override;
   void XboxControllerError(XboxController* controller) override;
 
-  Delegate* delegate_;
+  //Delegate* delegate_;
 
   std::set<XboxController*> controllers_;
 
@@ -187,4 +189,6 @@ class XboxDataFetcher : public XboxController::Delegate {
   DISALLOW_COPY_AND_ASSIGN(XboxDataFetcher);
 };
 
+} // namespace content
+
 #endif  // CONTENT_BROWSER_GAMEPAD_XBOX_DATA_FETCHER_MAC_H_
diff --git a/content/browser/gamepad/xbox_data_fetcher_mac.mm b/content/browser/gamepad/xbox_data_fetcher_mac.mm
new file mode 100644
index 0000000..5f46676
--- a/content/browser/gamepad/xbox_data_fetcher_mac.mm
+++ b/content/browser/gamepad/xbox_data_fetcher_mac.mm
@@ -0,0 +1,894 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/gamepad/xbox_data_fetcher_mac.h"
+
+#include <algorithm>
+#include <cmath>
+#include <limits>
+
+#include <CoreFoundation/CoreFoundation.h>
+#include <IOKit/IOCFPlugIn.h>
+#include <IOKit/IOKitLib.h>
+#include <IOKit/usb/IOUSBLib.h>
+#include <IOKit/usb/USB.h>
+
+#include "base/logging.h"
+#include "base/mac/foundation_util.h"
+
+using blink::WebGamepad;
+
+namespace content {
+
+namespace {
+const int kVendorMicrosoft = 0x045e;
+const int kProductXbox360Controller = 0x028e;
+const int kProductXboxOneController = 0x02d1;
+
+const int kXbox360ReadEndpoint = 1;
+const int kXbox360ControlEndpoint = 2;
+
+const int kXboxOneReadEndpoint = 2;
+const int kXboxOneControlEndpoint = 1;
+
+enum {
+  STATUS_MESSAGE_BUTTONS = 0,
+  STATUS_MESSAGE_LED = 1,
+
+  // Apparently this message tells you if the rumble pack is disabled in the
+  // controller. If the rumble pack is disabled, vibration control messages
+  // have no effect.
+  STATUS_MESSAGE_RUMBLE = 3,
+};
+
+enum {
+  XBOX_ONE_STATUS_MESSAGE_BUTTONS = 0x20,
+};
+
+enum {
+  CONTROL_MESSAGE_SET_RUMBLE = 0,
+  CONTROL_MESSAGE_SET_LED = 1,
+};
+
+#pragma pack(push, 1)
+struct Xbox360ButtonData {
+  bool dpad_up    : 1;
+  bool dpad_down  : 1;
+  bool dpad_left  : 1;
+  bool dpad_right : 1;
+
+  bool start             : 1;
+  bool back              : 1;
+  bool stick_left_click  : 1;
+  bool stick_right_click : 1;
+
+  bool bumper_left  : 1;
+  bool bumper_right : 1;
+  bool guide        : 1;
+  bool dummy1       : 1;  // Always 0.
+
+  bool a : 1;
+  bool b : 1;
+  bool x : 1;
+  bool y : 1;
+
+  uint8_t trigger_left;
+  uint8_t trigger_right;
+
+  int16_t stick_left_x;
+  int16_t stick_left_y;
+  int16_t stick_right_x;
+  int16_t stick_right_y;
+
+  // Always 0.
+  uint32_t dummy2;
+  uint16_t dummy3;
+};
+
+struct XboxOneButtonData {
+  bool sync   : 1;
+  bool dummy1 : 1;  // Always 0.
+  bool start  : 1;
+  bool back   : 1;
+
+  bool a : 1;
+  bool b : 1;
+  bool x : 1;
+  bool y : 1;
+
+  bool dpad_up    : 1;
+  bool dpad_down  : 1;
+  bool dpad_left  : 1;
+  bool dpad_right : 1;
+
+  bool bumper_left       : 1;
+  bool bumper_right      : 1;
+  bool stick_left_click  : 1;
+  bool stick_right_click : 1;
+
+  uint16_t trigger_left;
+  uint16_t trigger_right;
+
+  int16_t stick_left_x;
+  int16_t stick_left_y;
+  int16_t stick_right_x;
+  int16_t stick_right_y;
+};
+#pragma pack(pop)
+
+static_assert(sizeof(Xbox360ButtonData) == 18, "xbox button data wrong size");
+static_assert(sizeof(XboxOneButtonData) == 14, "xbox button data wrong size");
+
+// From MSDN:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/ee417001(v=vs.85).aspx#dead_zone
+const int16_t kLeftThumbDeadzone = 7849;
+const int16_t kRightThumbDeadzone = 8689;
+const uint8_t kXbox360TriggerDeadzone = 30;
+const uint16_t kXboxOneTriggerMax = 1023;
+const uint16_t kXboxOneTriggerDeadzone = 120;
+
+void NormalizeAxis(int16_t x,
+                   int16_t y,
+                   int16_t deadzone,
+                   float* x_out,
+                   float* y_out) {
+  float x_val = x;
+  float y_val = y;
+
+  // Determine how far the stick is pushed.
+  float real_magnitude = std::sqrt(x_val * x_val + y_val * y_val);
+
+  // Check if the controller is outside a circular dead zone.
+  if (real_magnitude > deadzone) {
+    // Clip the magnitude at its expected maximum value.
+    float magnitude = std::min(32767.0f, real_magnitude);
+
+    // Adjust magnitude relative to the end of the dead zone.
+    magnitude -= deadzone;
+
+    // Normalize the magnitude with respect to its expected range giving a
+    // magnitude value of 0.0 to 1.0
+    float ratio = (magnitude / (32767 - deadzone)) / real_magnitude;
+
+    // Y is negated because xbox controllers have an opposite sign from
+    // the 'standard controller' recommendations.
+    *x_out = x_val * ratio;
+    *y_out = -y_val * ratio;
+  } else {
+    // If the controller is in the deadzone zero out the magnitude.
+    *x_out = *y_out = 0.0f;
+  }
+}
+
+float NormalizeTrigger(uint8_t value) {
+  return value < kXbox360TriggerDeadzone
+             ? 0
+             : static_cast<float>(value - kXbox360TriggerDeadzone) /
+                   (std::numeric_limits<uint8_t>::max() -
+                    kXbox360TriggerDeadzone);
+}
+
+float NormalizeXboxOneTrigger(uint16_t value) {
+  return value < kXboxOneTriggerDeadzone ? 0 :
+      static_cast<float>(value - kXboxOneTriggerDeadzone) /
+          (kXboxOneTriggerMax - kXboxOneTriggerDeadzone);
+}
+
+void NormalizeXbox360ButtonData(const Xbox360ButtonData& data,
+    XboxController::Data* normalized_data) {
+  normalized_data->buttons[0] = data.a;
+  normalized_data->buttons[1] = data.b;
+  normalized_data->buttons[2] = data.x;
+  normalized_data->buttons[3] = data.y;
+  normalized_data->buttons[4] = data.bumper_left;
+  normalized_data->buttons[5] = data.bumper_right;
+  normalized_data->buttons[6] = data.back;
+  normalized_data->buttons[7] = data.start;
+  normalized_data->buttons[8] = data.stick_left_click;
+  normalized_data->buttons[9] = data.stick_right_click;
+  normalized_data->buttons[10] = data.dpad_up;
+  normalized_data->buttons[11] = data.dpad_down;
+  normalized_data->buttons[12] = data.dpad_left;
+  normalized_data->buttons[13] = data.dpad_right;
+  normalized_data->buttons[14] = data.guide;
+  normalized_data->triggers[0] = NormalizeTrigger(data.trigger_left);
+  normalized_data->triggers[1] = NormalizeTrigger(data.trigger_right);
+  NormalizeAxis(data.stick_left_x,
+                data.stick_left_y,
+                kLeftThumbDeadzone,
+                &normalized_data->axes[0],
+                &normalized_data->axes[1]);
+  NormalizeAxis(data.stick_right_x,
+                data.stick_right_y,
+                kRightThumbDeadzone,
+                &normalized_data->axes[2],
+                &normalized_data->axes[3]);
+}
+
+void NormalizeXboxOneButtonData(const XboxOneButtonData& data,
+    XboxController::Data* normalized_data) {
+  normalized_data->buttons[0] = data.a;
+  normalized_data->buttons[1] = data.b;
+  normalized_data->buttons[2] = data.x;
+  normalized_data->buttons[3] = data.y;
+  normalized_data->buttons[4] = data.bumper_left;
+  normalized_data->buttons[5] = data.bumper_right;
+  normalized_data->buttons[6] = data.back;
+  normalized_data->buttons[7] = data.start;
+  normalized_data->buttons[8] = data.stick_left_click;
+  normalized_data->buttons[9] = data.stick_right_click;
+  normalized_data->buttons[10] = data.dpad_up;
+  normalized_data->buttons[11] = data.dpad_down;
+  normalized_data->buttons[12] = data.dpad_left;
+  normalized_data->buttons[13] = data.dpad_right;
+  normalized_data->buttons[14] = data.sync;
+  normalized_data->triggers[0] = NormalizeXboxOneTrigger(data.trigger_left);
+  normalized_data->triggers[1] = NormalizeXboxOneTrigger(data.trigger_right);
+  NormalizeAxis(data.stick_left_x,
+                data.stick_left_y,
+                kLeftThumbDeadzone,
+                &normalized_data->axes[0],
+                &normalized_data->axes[1]);
+  NormalizeAxis(data.stick_right_x,
+                data.stick_right_y,
+                kRightThumbDeadzone,
+                &normalized_data->axes[2],
+                &normalized_data->axes[3]);
+}
+
+void CopyNSStringAsUTF16LittleEndian(
+    NSString* src, blink::WebUChar* dest, size_t dest_len) {
+  NSData* as16 = [src dataUsingEncoding:NSUTF16LittleEndianStringEncoding];
+  memset(dest, 0, dest_len);
+  [as16 getBytes:dest length:dest_len - sizeof(blink::WebUChar)];
+}
+
+}  // namespace
+
+XboxController::XboxController(Delegate* delegate)
+    : device_(NULL),
+      interface_(NULL),
+      device_is_open_(false),
+      interface_is_open_(false),
+      read_buffer_size_(0),
+      led_pattern_(LED_NUM_PATTERNS),
+      location_id_(0),
+      delegate_(delegate),
+      controller_type_(UNKNOWN_CONTROLLER),
+      read_endpoint_(0),
+      control_endpoint_(0) {
+}
+
+XboxController::~XboxController() {
+  if (source_)
+    CFRunLoopSourceInvalidate(source_);
+  if (interface_ && interface_is_open_)
+    (*interface_)->USBInterfaceClose(interface_);
+  if (device_ && device_is_open_)
+    (*device_)->USBDeviceClose(device_);
+}
+
+bool XboxController::OpenDevice(io_service_t service) {
+  IOCFPlugInInterface **plugin;
+  SInt32 score;  // Unused, but required for IOCreatePlugInInterfaceForService.
+  kern_return_t kr =
+      IOCreatePlugInInterfaceForService(service,
+                                        kIOUSBDeviceUserClientTypeID,
+                                        kIOCFPlugInInterfaceID,
+                                        &plugin,
+                                        &score);
+  if (kr != KERN_SUCCESS)
+    return false;
+  base::mac::ScopedIOPluginInterface<IOCFPlugInInterface> plugin_ref(plugin);
+
+  HRESULT res =
+      (*plugin)->QueryInterface(plugin,
+                                CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID320),
+                                (LPVOID *)&device_);
+  if (!SUCCEEDED(res) || !device_)
+    return false;
+
+  UInt16 vendor_id;
+  kr = (*device_)->GetDeviceVendor(device_, &vendor_id);
+  if (kr != KERN_SUCCESS || vendor_id != kVendorMicrosoft)
+    return false;
+
+  UInt16 product_id;
+  kr = (*device_)->GetDeviceProduct(device_, &product_id);
+  if (kr != KERN_SUCCESS)
+    return false;
+
+  IOUSBFindInterfaceRequest request;
+  switch (product_id) {
+    case kProductXbox360Controller:
+      controller_type_ = XBOX_360_CONTROLLER;
+      read_endpoint_ = kXbox360ReadEndpoint;
+      control_endpoint_ = kXbox360ControlEndpoint;
+      request.bInterfaceClass = 255;
+      request.bInterfaceSubClass = 93;
+      request.bInterfaceProtocol = 1;
+      request.bAlternateSetting = kIOUSBFindInterfaceDontCare;
+      break;
+    case kProductXboxOneController:
+      controller_type_ = XBOX_ONE_CONTROLLER;
+      read_endpoint_ = kXboxOneReadEndpoint;
+      control_endpoint_ = kXboxOneControlEndpoint;
+      request.bInterfaceClass = 255;
+      request.bInterfaceSubClass = 71;
+      request.bInterfaceProtocol = 208;
+      request.bAlternateSetting = kIOUSBFindInterfaceDontCare;
+      break;
+    default:
+      return false;
+  }
+
+  // Open the device and configure it.
+  kr = (*device_)->USBDeviceOpen(device_);
+  if (kr != KERN_SUCCESS)
+    return false;
+  device_is_open_ = true;
+
+  // Xbox controllers have one configuration option which has configuration
+  // value 1. Try to set it and fail if it couldn't be configured.
+  IOUSBConfigurationDescriptorPtr config_desc;
+  kr = (*device_)->GetConfigurationDescriptorPtr(device_, 0, &config_desc);
+  if (kr != KERN_SUCCESS)
+    return false;
+  kr = (*device_)->SetConfiguration(device_, config_desc->bConfigurationValue);
+  if (kr != KERN_SUCCESS)
+    return false;
+
+  // The device has 4 interfaces. They are as follows:
+  // Protocol 1:
+  //  - Endpoint 1 (in) : Controller events, including button presses.
+  //  - Endpoint 2 (out): Rumble pack and LED control
+  // Protocol 2 has a single endpoint to read from a connected ChatPad device.
+  // Protocol 3 is used by a connected headset device.
+  // The device also has an interface on subclass 253, protocol 10 with no
+  // endpoints.  It is unused.
+  //
+  // We don't currently support the ChatPad or headset, so protocol 1 is the
+  // only protocol we care about.
+  //
+  // For more detail, see
+  // https://github.com/Grumbel/xboxdrv/blob/master/PROTOCOL
+  io_iterator_t iter;
+  kr = (*device_)->CreateInterfaceIterator(device_, &request, &iter);
+  if (kr != KERN_SUCCESS)
+    return false;
+  base::mac::ScopedIOObject<io_iterator_t> iter_ref(iter);
+
+  // There should be exactly one USB interface which matches the requested
+  // settings.
+  io_service_t usb_interface = IOIteratorNext(iter);
+  if (!usb_interface)
+    return false;
+
+  // We need to make an InterfaceInterface to communicate with the device
+  // endpoint. This is the same process as earlier: first make a
+  // PluginInterface from the io_service then make the InterfaceInterface from
+  // that.
+  IOCFPlugInInterface **plugin_interface;
+  kr = IOCreatePlugInInterfaceForService(usb_interface,
+                                         kIOUSBInterfaceUserClientTypeID,
+                                         kIOCFPlugInInterfaceID,
+                                         &plugin_interface,
+                                         &score);
+  if (kr != KERN_SUCCESS || !plugin_interface)
+    return false;
+  base::mac::ScopedIOPluginInterface<IOCFPlugInInterface> interface_ref(
+      plugin_interface);
+
+  // Release the USB interface, and any subsequent interfaces returned by the
+  // iterator. (There shouldn't be any, but in case a future device does
+  // contain more interfaces, this will serve to avoid memory leaks.)
+  do {
+    IOObjectRelease(usb_interface);
+  } while ((usb_interface = IOIteratorNext(iter)));
+
+  // Actually create the interface.
+  res = (*plugin_interface)->QueryInterface(
+      plugin_interface,
+      CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID300),
+      (LPVOID *)&interface_);
+
+  if (!SUCCEEDED(res) || !interface_)
+    return false;
+
+  // Actually open the interface.
+  kr = (*interface_)->USBInterfaceOpen(interface_);
+  if (kr != KERN_SUCCESS)
+    return false;
+  interface_is_open_ = true;
+
+  CFRunLoopSourceRef source_ref;
+  kr = (*interface_)->CreateInterfaceAsyncEventSource(interface_, &source_ref);
+  if (kr != KERN_SUCCESS || !source_ref)
+    return false;
+  source_.reset(source_ref);
+  CFRunLoopAddSource(CFRunLoopGetCurrent(), source_, kCFRunLoopDefaultMode);
+
+  // The interface should have two pipes. Pipe 1 with direction kUSBIn and pipe
+  // 2 with direction kUSBOut. Both pipes should have type kUSBInterrupt.
+  uint8_t num_endpoints;
+  kr = (*interface_)->GetNumEndpoints(interface_, &num_endpoints);
+  if (kr != KERN_SUCCESS || num_endpoints < 2)
+    return false;
+
+  for (int i = 1; i <= 2; i++) {
+    uint8_t direction;
+    uint8_t number;
+    uint8_t transfer_type;
+    uint16_t max_packet_size;
+    uint8_t interval;
+
+    kr = (*interface_)->GetPipeProperties(interface_,
+                                          i,
+                                          &direction,
+                                          &number,
+                                          &transfer_type,
+                                          &max_packet_size,
+                                          &interval);
+    if (kr != KERN_SUCCESS || transfer_type != kUSBInterrupt) {
+      return false;
+    }
+    if (i == read_endpoint_) {
+      if (direction != kUSBIn)
+        return false;
+      read_buffer_.reset(new uint8_t[max_packet_size]);
+      read_buffer_size_ = max_packet_size;
+      QueueRead();
+    } else if (i == control_endpoint_) {
+      if (direction != kUSBOut)
+        return false;
+      if (controller_type_ == XBOX_ONE_CONTROLLER)
+        WriteXboxOneInit();
+    }
+  }
+
+  // The location ID is unique per controller, and can be used to track
+  // controllers through reconnections (though if a controller is detached from
+  // one USB hub and attached to another, the location ID will change).
+  kr = (*device_)->GetLocationID(device_, &location_id_);
+  if (kr != KERN_SUCCESS)
+    return false;
+
+  return true;
+}
+
+void XboxController::SetLEDPattern(LEDPattern pattern) {
+  led_pattern_ = pattern;
+  const UInt8 length = 3;
+
+  // This buffer will be released in WriteComplete when WritePipeAsync
+  // finishes.
+  UInt8* buffer = new UInt8[length];
+  buffer[0] = static_cast<UInt8>(CONTROL_MESSAGE_SET_LED);
+  buffer[1] = length;
+  buffer[2] = static_cast<UInt8>(pattern);
+  kern_return_t kr = (*interface_)->WritePipeAsync(interface_,
+                                                   control_endpoint_,
+                                                   buffer,
+                                                   (UInt32)length,
+                                                   WriteComplete,
+                                                   buffer);
+  if (kr != KERN_SUCCESS) {
+    delete[] buffer;
+    IOError();
+    return;
+  }
+}
+
+int XboxController::GetVendorId() const {
+  return kVendorMicrosoft;
+}
+
+int XboxController::GetProductId() const {
+  if (controller_type_ == XBOX_360_CONTROLLER)
+    return kProductXbox360Controller;
+  else
+    return kProductXboxOneController;
+}
+
+XboxController::ControllerType XboxController::GetControllerType() const {
+  return controller_type_;
+}
+
+void XboxController::WriteComplete(void* context, IOReturn result, void* arg0) {
+  UInt8* buffer = static_cast<UInt8*>(context);
+  delete[] buffer;
+
+  // Ignoring any errors sending data, because they will usually only occur
+  // when the device is disconnected, in which case it really doesn't matter if
+  // the data got to the controller or not.
+  if (result != kIOReturnSuccess)
+    return;
+}
+
+void XboxController::GotData(void* context, IOReturn result, void* arg0) {
+  size_t bytes_read = reinterpret_cast<size_t>(arg0);
+  XboxController* controller = static_cast<XboxController*>(context);
+
+  if (result != kIOReturnSuccess) {
+    // This will happen if the device was disconnected. The gamepad has
+    // probably been destroyed by a meteorite.
+    controller->IOError();
+    return;
+  }
+
+  if (controller->GetControllerType() == XBOX_360_CONTROLLER)
+    controller->ProcessXbox360Packet(bytes_read);
+  else
+    controller->ProcessXboxOnePacket(bytes_read);
+
+  // Queue up another read.
+  controller->QueueRead();
+}
+
+void XboxController::ProcessXbox360Packet(size_t length) {
+  if (length < 2)
+    return;
+  DCHECK(length <= read_buffer_size_);
+  if (length > read_buffer_size_) {
+    IOError();
+    return;
+  }
+  uint8_t* buffer = read_buffer_.get();
+
+  if (buffer[1] != length)
+    // Length in packet doesn't match length reported by USB.
+    return;
+
+  uint8_t type = buffer[0];
+  buffer += 2;
+  length -= 2;
+  switch (type) {
+    case STATUS_MESSAGE_BUTTONS: {
+      if (length != sizeof(Xbox360ButtonData))
+        return;
+      Xbox360ButtonData* data = reinterpret_cast<Xbox360ButtonData*>(buffer);
+      Data normalized_data;
+      NormalizeXbox360ButtonData(*data, &normalized_data);
+      delegate_->XboxControllerGotData(this, normalized_data);
+      break;
+    }
+    case STATUS_MESSAGE_LED:
+      if (length != 3)
+        return;
+      // The controller sends one of these messages every time the LED pattern
+      // is set, as well as once when it is plugged in.
+      if (led_pattern_ == LED_NUM_PATTERNS && buffer[0] < LED_NUM_PATTERNS)
+        led_pattern_ = static_cast<LEDPattern>(buffer[0]);
+      break;
+    default:
+      // Unknown packet: ignore!
+      break;
+  }
+}
+
+void XboxController::ProcessXboxOnePacket(size_t length) {
+  if (length < 2)
+    return;
+  DCHECK(length <= read_buffer_size_);
+  if (length > read_buffer_size_) {
+    IOError();
+    return;
+  }
+  uint8_t* buffer = read_buffer_.get();
+
+  uint8_t type = buffer[0];
+  buffer += 4;
+  length -= 4;
+  switch (type) {
+    case XBOX_ONE_STATUS_MESSAGE_BUTTONS: {
+      if (length != sizeof(XboxOneButtonData))
+        return;
+      XboxOneButtonData* data = reinterpret_cast<XboxOneButtonData*>(buffer);
+      Data normalized_data;
+      NormalizeXboxOneButtonData(*data, &normalized_data);
+      delegate_->XboxControllerGotData(this, normalized_data);
+      break;
+    }
+    default:
+      // Unknown packet: ignore!
+      break;
+  }
+}
+
+void XboxController::QueueRead() {
+  kern_return_t kr = (*interface_)->ReadPipeAsync(interface_,
+                                                  read_endpoint_,
+                                                  read_buffer_.get(),
+                                                  read_buffer_size_,
+                                                  GotData,
+                                                  this);
+  if (kr != KERN_SUCCESS)
+    IOError();
+}
+
+void XboxController::IOError() {
+  delegate_->XboxControllerError(this);
+}
+
+void XboxController::WriteXboxOneInit() {
+  const UInt8 length = 2;
+
+  // This buffer will be released in WriteComplete when WritePipeAsync
+  // finishes.
+  UInt8* buffer = new UInt8[length];
+  buffer[0] = 0x05;
+  buffer[1] = 0x20;
+  kern_return_t kr = (*interface_)->WritePipeAsync(interface_,
+                                                   control_endpoint_,
+                                                   buffer,
+                                                   (UInt32)length,
+                                                   WriteComplete,
+                                                   buffer);
+  if (kr != KERN_SUCCESS) {
+    delete[] buffer;
+    IOError();
+    return;
+  }
+}
+
+//-----------------------------------------------------------------------------
+
+XboxDataFetcher::XboxDataFetcher()
+    : listening_(false),
+      source_(NULL),
+      port_(NULL) {
+}
+
+XboxDataFetcher::~XboxDataFetcher() {
+  while (!controllers_.empty()) {
+    RemoveController(*controllers_.begin());
+  }
+  UnregisterFromNotifications();
+}
+
+void XboxDataFetcher::GetGamepadData(bool devices_changed_hint) {
+  // This just loops through all the connected pads and "pings" them to indicate
+  // that they're still active.
+  for (const auto& controller : controllers_) {
+    provider()->GetPadState(GAMEPAD_SOURCE_MAC_XBOX, controller->location_id());
+  }
+}
+
+void XboxDataFetcher::OnAddedToProvider() {
+  RegisterForNotifications();
+}
+
+void XboxDataFetcher::DeviceAdded(void* context, io_iterator_t iterator) {
+  DCHECK(context);
+  XboxDataFetcher* fetcher = static_cast<XboxDataFetcher*>(context);
+  io_service_t ref;
+  while ((ref = IOIteratorNext(iterator))) {
+    base::mac::ScopedIOObject<io_service_t> scoped_ref(ref);
+    XboxController* controller = new XboxController(fetcher);
+    if (controller->OpenDevice(ref)) {
+      fetcher->AddController(controller);
+    } else {
+      delete controller;
+    }
+  }
+}
+
+void XboxDataFetcher::DeviceRemoved(void* context, io_iterator_t iterator) {
+  DCHECK(context);
+  XboxDataFetcher* fetcher = static_cast<XboxDataFetcher*>(context);
+  io_service_t ref;
+  while ((ref = IOIteratorNext(iterator))) {
+    base::mac::ScopedIOObject<io_service_t> scoped_ref(ref);
+    base::ScopedCFTypeRef<CFNumberRef> number(
+        base::mac::CFCastStrict<CFNumberRef>(
+            IORegistryEntryCreateCFProperty(ref,
+                                            CFSTR(kUSBDevicePropertyLocationID),
+                                            kCFAllocatorDefault,
+                                            kNilOptions)));
+    UInt32 location_id = 0;
+    CFNumberGetValue(number, kCFNumberSInt32Type, &location_id);
+    fetcher->RemoveControllerByLocationID(location_id);
+  }
+}
+
+bool XboxDataFetcher::RegisterForNotifications() {
+  if (listening_)
+    return true;
+  port_ = IONotificationPortCreate(kIOMasterPortDefault);
+  if (!port_)
+    return false;
+  source_ = IONotificationPortGetRunLoopSource(port_);
+  if (!source_)
+    return false;
+  CFRunLoopAddSource(CFRunLoopGetCurrent(), source_, kCFRunLoopDefaultMode);
+
+  listening_ = true;
+
+  if (!RegisterForDeviceNotifications(
+      kVendorMicrosoft, kProductXboxOneController,
+      &xbox_one_device_added_iter_,
+      &xbox_one_device_removed_iter_))
+    return false;
+
+  if (!RegisterForDeviceNotifications(
+      kVendorMicrosoft, kProductXbox360Controller,
+      &xbox_360_device_added_iter_,
+      &xbox_360_device_removed_iter_))
+    return false;
+
+  return true;
+}
+
+bool XboxDataFetcher::RegisterForDeviceNotifications(
+    int vendor_id,
+    int product_id,
+    base::mac::ScopedIOObject<io_iterator_t>* added_iter,
+    base::mac::ScopedIOObject<io_iterator_t>* removed_iter) {
+  base::ScopedCFTypeRef<CFNumberRef> vendor_cf(CFNumberCreate(
+      kCFAllocatorDefault, kCFNumberSInt32Type, &vendor_id));
+  base::ScopedCFTypeRef<CFNumberRef> product_cf(CFNumberCreate(
+      kCFAllocatorDefault, kCFNumberSInt32Type, &product_id));
+  base::ScopedCFTypeRef<CFMutableDictionaryRef> matching_dict(
+      IOServiceMatching(kIOUSBDeviceClassName));
+  if (!matching_dict)
+    return false;
+  CFDictionarySetValue(matching_dict, CFSTR(kUSBVendorID), vendor_cf);
+  CFDictionarySetValue(matching_dict, CFSTR(kUSBProductID), product_cf);
+
+  // IOServiceAddMatchingNotification() releases the dictionary when it's done.
+  // Retain it before each call to IOServiceAddMatchingNotification to keep
+  // things balanced.
+  CFRetain(matching_dict);
+  io_iterator_t device_added_iter;
+  IOReturn ret;
+  ret = IOServiceAddMatchingNotification(port_,
+                                         kIOFirstMatchNotification,
+                                         matching_dict,
+                                         DeviceAdded,
+                                         this,
+                                         &device_added_iter);
+  added_iter->reset(device_added_iter);
+  if (ret != kIOReturnSuccess) {
+    LOG(ERROR) << "Error listening for Xbox controller add events: " << ret;
+    return false;
+  }
+  DeviceAdded(this, added_iter->get());
+
+  CFRetain(matching_dict);
+  io_iterator_t device_removed_iter;
+  ret = IOServiceAddMatchingNotification(port_,
+                                         kIOTerminatedNotification,
+                                         matching_dict,
+                                         DeviceRemoved,
+                                         this,
+                                         &device_removed_iter);
+  removed_iter->reset(device_removed_iter);
+  if (ret != kIOReturnSuccess) {
+    LOG(ERROR) << "Error listening for Xbox controller remove events: " << ret;
+    return false;
+  }
+  DeviceRemoved(this, removed_iter->get());
+  return true;
+}
+
+void XboxDataFetcher::UnregisterFromNotifications() {
+  if (!listening_)
+    return;
+  listening_ = false;
+  if (source_)
+    CFRunLoopSourceInvalidate(source_);
+  if (port_)
+    IONotificationPortDestroy(port_);
+  port_ = NULL;
+}
+
+XboxController* XboxDataFetcher::ControllerForLocation(UInt32 location_id) {
+  for (std::set<XboxController*>::iterator i = controllers_.begin();
+       i != controllers_.end();
+       ++i) {
+    if ((*i)->location_id() == location_id)
+      return *i;
+  }
+  return NULL;
+}
+
+void XboxDataFetcher::AddController(XboxController* controller) {
+  DCHECK(!ControllerForLocation(controller->location_id()))
+      << "Controller with location ID " << controller->location_id()
+      << " already exists in the set of controllers.";
+  //delegate_->XboxDeviceAdd(controller);
+
+  PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_MAC_XBOX,
+                                            controller->location_id());
+  if (!state) {
+    delete controller;
+    return; // No available slot for this device
+  }
+
+  controllers_.insert(controller);
+
+  controller->SetLEDPattern(
+      (XboxController::LEDPattern)(XboxController::LED_FLASH_TOP_LEFT +
+          controller->location_id()));
+
+  NSString* ident = [NSString stringWithFormat:
+      @"%@ (STANDARD GAMEPAD Vendor: %04x Product: %04x)",
+          controller->GetControllerType() == XboxController::XBOX_360_CONTROLLER
+              ? @"Xbox 360 Controller"
+              : @"Xbox One Controller",
+          controller->GetProductId(), controller->GetVendorId()];
+  CopyNSStringAsUTF16LittleEndian(
+      ident,
+      state->data.id,
+      sizeof(state->data.id));
+
+  CopyNSStringAsUTF16LittleEndian(
+    @"standard",
+    state->data.mapping,
+    sizeof(state->data.mapping));
+
+  state->data.connected = true;
+  state->data.axesLength = 4;
+  state->data.buttonsLength = 17;
+  state->data.timestamp = 0;
+  state->mapper = 0;
+  state->axis_mask = 0;
+  state->button_mask = 0;
+}
+
+void XboxDataFetcher::RemoveController(XboxController* controller) {
+  //delegate_->XboxDeviceRemove(controller);
+  controllers_.erase(controller);
+  delete controller;
+}
+
+void XboxDataFetcher::RemoveControllerByLocationID(uint32_t location_id) {
+  XboxController* controller = NULL;
+  for (std::set<XboxController*>::iterator i = controllers_.begin();
+       i != controllers_.end();
+       ++i) {
+    if ((*i)->location_id() == location_id) {
+      controller = *i;
+      break;
+    }
+  }
+  if (controller)
+    RemoveController(controller);
+}
+
+void XboxDataFetcher::XboxControllerGotData(XboxController* controller,
+                                            const XboxController::Data& data) {
+  //delegate_->XboxValueChanged(controller, data);
+
+  PadState* state = provider()->GetPadState(GAMEPAD_SOURCE_MAC_XBOX,
+                                            controller->location_id());
+  if (!state)
+    return; // No available slot for this device
+
+  WebGamepad& pad = state->data;
+
+  for (size_t i = 0; i < 6; i++) {
+    pad.buttons[i].pressed = data.buttons[i];
+    pad.buttons[i].value = data.buttons[i] ? 1.0f : 0.0f;
+  }
+  pad.buttons[6].pressed = data.triggers[0] > kDefaultButtonPressedThreshold;
+  pad.buttons[6].value = data.triggers[0];
+  pad.buttons[7].pressed = data.triggers[1] > kDefaultButtonPressedThreshold;
+  pad.buttons[7].value = data.triggers[1];
+  for (size_t i = 8; i < 17; i++) {
+    pad.buttons[i].pressed = data.buttons[i - 2];
+    pad.buttons[i].value = data.buttons[i - 2] ? 1.0f : 0.0f;
+  }
+  for (size_t i = 0; i < arraysize(data.axes); i++) {
+    pad.axes[i] = data.axes[i];
+  }
+
+  pad.timestamp = base::TimeTicks::Now().ToInternalValue();
+}
+
+void XboxDataFetcher::XboxControllerError(XboxController* controller) {
+  RemoveController(controller);
+}
+
+} // namespace content
diff --git a/content/content_browser.gypi b/content/content_browser.gypi
index 1953f4c..8e715f5 100644
--- a/content/content_browser.gypi
+++ b/content/content_browser.gypi
@@ -799,7 +799,7 @@
       'browser/gamepad/gamepad_standard_mappings_win.cc',
       'browser/gamepad/raw_input_data_fetcher_win.cc',
       'browser/gamepad/raw_input_data_fetcher_win.h',
-      'browser/gamepad/xbox_data_fetcher_mac.cc',
+      'browser/gamepad/xbox_data_fetcher_mac.mm',
       'browser/gamepad/xbox_data_fetcher_mac.h',
       'browser/geofencing/geofencing_dispatcher_host.cc',
       'browser/geofencing/geofencing_dispatcher_host.h',
-- 
2.7.4.windows.1

